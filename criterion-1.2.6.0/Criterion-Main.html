<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Criterion.Main</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Criterion.Main.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">criterion-1.2.6.0: Robust, reliable performance measurement and analysis</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2009-2014 Bryan O'Sullivan</td></tr><tr><th>License</th><td>BSD-style</td></tr><tr><th>Maintainer</th><td>bos@serpentine.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Criterion.Main</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">How to write benchmarks</a><ul><li><a href="#g:2">Benchmarking IO actions</a></li><li><a href="#g:3">Benchmarking pure code</a></li><li><a href="#g:4">Fully evaluating a result</a></li></ul></li><li><a href="#g:5">Types</a></li><li><a href="#g:6">Creating a benchmark suite</a><ul><li><a href="#g:7">Running a benchmark</a></li></ul></li><li><a href="#g:8">Turning a suite of benchmarks into a program</a></li><li><a href="#g:9">Other useful code</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Wrappers for compiling and running benchmarks quickly and easily.
 See <code><a href="Criterion-Main.html#v:defaultMain">defaultMain</a></code> below for an example.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Benchmark">Benchmark</a></li><li class="src short"><a href="#v:env">env</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env -&gt; (env -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a>) -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></li><li class="src short"><a href="#v:envWithCleanup">envWithCleanup</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a) -&gt; (env -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a>) -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></li><li class="src short"><a href="#v:perBatchEnv">perBatchEnv</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b) =&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env) -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:perBatchEnvWithCleanup">perBatchEnvWithCleanup</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b) =&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env) -&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()) -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:perRunEnv">perRunEnv</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b) =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:perRunEnvWithCleanup">perRunEnvWithCleanup</a> :: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b) =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()) -&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:toBenchmarkable">toBenchmarkable</a> :: (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:bench">bench</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></li><li class="src short"><a href="#v:bgroup">bgroup</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></li><li class="src short"><a href="#v:nf">nf</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b =&gt; (a -&gt; b) -&gt; a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:whnf">whnf</a> :: (a -&gt; b) -&gt; a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:nfIO">nfIO</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:whnfIO">whnfIO</a> :: <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></li><li class="src short"><a href="#v:defaultMain">defaultMain</a> :: [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:defaultMainWith">defaultMainWith</a> :: <a href="Criterion-Types.html#t:Config">Config</a> -&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:defaultConfig">defaultConfig</a> :: <a href="Criterion-Types.html#t:Config">Config</a></li><li class="src short"><a href="#v:makeMatcher">makeMatcher</a> :: <a href="Criterion-Main-Options.html#t:MatchType">MatchType</a> -&gt; [<a href="../base-4.10.1.0/Data-String.html#t:String">String</a>] -&gt; <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> (<a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:runMode">runMode</a> :: <a href="Criterion-Main-Options.html#t:Mode">Mode</a> -&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">How to write benchmarks</h1><div class="doc"><p>The <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code> type is a container for code that can be
 benchmarked.  The value inside must run a benchmark the given
 number of times.  We are most interested in benchmarking two
 things:</p><ul><li><code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> actions.  Any <code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> action can be benchmarked directly.</li><li>Pure functions.  GHC optimises aggressively when compiling with
   <code>-O</code>, so it is easy to write innocent-looking benchmark code that
   doesn't measure the performance of a pure function at all.  We
   work around this by benchmarking both a function and its final
   argument together.</li></ul></div><h2 id="g:2">Benchmarking IO actions</h2><div class="doc"><p>Any <code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> action can be benchmarked easily if its type resembles
 this:</p><pre><code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> a
</pre></div><h2 id="g:3">Benchmarking pure code</h2><div class="doc"><p>Because GHC optimises aggressively when compiling with <code>-O</code>, it is
 potentially easy to write innocent-looking benchmark code that will
 only be evaluated once, for which all but the first iteration of
 the timing loop will be timing the cost of doing nothing.</p><p>To work around this, we provide two functions for benchmarking pure
 code.</p><p>The first will cause results to be fully evaluated to normal form
 (NF):</p><pre><code><a href="Criterion-Main.html#v:nf">nf</a></code> :: <code>NFData</code> b =&gt; (a -&gt; b) -&gt; a -&gt; <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code>
</pre><p>The second will cause results to be evaluated to weak head normal
 form (the Haskell default):</p><pre><code><a href="Criterion-Main.html#v:whnf">whnf</a></code> :: (a -&gt; b) -&gt; a -&gt; <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code>
</pre><p>As both of these types suggest, when you want to benchmark a
 function, you must supply two values:</p><ul><li>The first element is the function, saturated with all but its
   last argument.</li><li>The second element is the last argument to the function.</li></ul><p>Here is an example that makes the use of these functions clearer.
 Suppose we want to benchmark the following function:</p><pre>firstN :: Int -&gt; [Int]
firstN k = take k [(0::Int)..]
</pre><p>So in the easy case, we construct a benchmark as follows:</p><pre><code><a href="Criterion-Main.html#v:nf">nf</a></code> firstN 1000
</pre></div><h2 id="g:4">Fully evaluating a result</h2><div class="doc"><p>The <code><a href="Criterion-Main.html#v:whnf">whnf</a></code> harness for evaluating a pure function only evaluates
 the result to weak head normal form (WHNF).  If you need the result
 evaluated all the way to normal form, use the <code><a href="Criterion-Main.html#v:nf">nf</a></code> function to
 force its complete evaluation.</p><p>Using the <code>firstN</code> example from earlier, to naive eyes it might
 <em>appear</em> that the following code ought to benchmark the production
 of the first 1000 list elements:</p><pre><code><a href="Criterion-Main.html#v:whnf">whnf</a></code> firstN 1000
</pre><p>Since we are using <code><a href="Criterion-Main.html#v:whnf">whnf</a></code>, in this case the result will only be
 forced until it reaches WHNF, so what this would <em>actually</em>
 benchmark is merely how long it takes to produce the first list
 element!</p></div><h1 id="g:5">Types</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Benchmarkable" class="def">Benchmarkable</a> <a href="src/Criterion.Types.html#Benchmarkable" class="link">Source</a> <a href="#t:Benchmarkable" class="selflink">#</a></p><div class="doc"><p>A pure function or impure action that can be benchmarked. The
 <code><a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a></code> parameter indicates the number of times to run the given
 function or action.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Benchmark" class="def">Benchmark</a> <a href="src/Criterion.Types.html#Benchmark" class="link">Source</a> <a href="#t:Benchmark" class="selflink">#</a></p><div class="doc"><p>Specification of a collection of benchmarks and environments. A
 benchmark may consist of:</p><ul><li>An environment that creates input data for benchmarks, created
   with <code><a href="Criterion-Main.html#v:env">env</a></code>.</li><li>A single <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code> item with a name, created with <code><a href="Criterion-Main.html#v:bench">bench</a></code>.</li><li>A (possibly nested) group of <code><a href="Criterion-Main.html#t:Benchmark">Benchmark</a></code>s, created with <code><a href="Criterion-Main.html#v:bgroup">bgroup</a></code>.</li></ul></div><div class="subs instances"><p id="control.i:Benchmark" class="caption collapser" onclick="toggleSection('i:Benchmark')">Instances</p><div id="section.i:Benchmark" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Benchmark:Show:1" class="instance expander" onclick="toggleSection('i:id:Benchmark:Show:1')"></span> <a href="../base-4.10.1.0/Text-Show.html#t:Show">Show</a> <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></span> <a href="src/Criterion.Types.html#line-601" class="link">Source</a> <a href="#t:Benchmark" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Benchmark:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a> -&gt; <a href="../base-4.10.1.0/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Criterion-Main.html#t:Benchmark">Benchmark</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><h1 id="g:6">Creating a benchmark suite</h1><div class="top"><p class="src"><a id="v:env" class="def">env</a> <a href="src/Criterion.Types.html#env" class="link">Source</a> <a href="#v:env" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env</td><td class="doc"><p>Create the environment.  The environment will be evaluated to
 normal form before being passed to the benchmark.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a>)</td><td class="doc"><p>Take the newly created environment and make it available to
 the given benchmarks.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Run a benchmark (or collection of benchmarks) in the given
 environment.  The purpose of an environment is to lazily create
 input data to pass to the functions that will be benchmarked.</p><p>A common example of environment data is input that is read from a
 file.  Another is a large data structure constructed in-place.</p><p><strong>Motivation.</strong> In earlier versions of criterion, all benchmark
 inputs were always created when a program started running.  By
 deferring the creation of an environment when its associated
 benchmarks need the its, we avoid two problems that this strategy
 caused:</p><ul><li>Memory pressure distorted the results of unrelated benchmarks.
   If one benchmark needed e.g. a gigabyte-sized input, it would
   force the garbage collector to do extra work when running some
   other benchmark that had no use for that input.  Since the data
   created by an environment is only available when it is in scope,
   it should be garbage collected before other benchmarks are run.</li><li>The time cost of generating all needed inputs could be
   significant in cases where no inputs (or just a few) were really
   needed.  This occurred often, for instance when just one out of a
   large suite of benchmarks was run, or when a user would list the
   collection of benchmarks without running any.</li></ul><p><strong>Creation.</strong> An environment is created right before its related
 benchmarks are run.  The <code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> action that creates the environment
 is run, then the newly created environment is evaluated to normal
 form (hence the <code><a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a></code> constraint) before being passed to the
 function that receives the environment.</p><p><strong>Complex environments.</strong> If you need to create an environment that
 contains multiple values, simply pack the values into a tuple.</p><p><strong>Lazy pattern matching.</strong> In situations where a &quot;real&quot;
 environment is not needed, e.g. if a list of benchmark names is
 being generated, a value which throws an exception will be passed
 to the function that receives the environment.  This avoids the
 overhead of generating an environment that will not actually be
 used.</p><p>The function that receives the environment must use lazy pattern
 matching to deconstruct the tuple (e.g., <code>~(x, y)</code>, not <code>(x, y)</code>),
 as use of strict pattern matching will cause a crash if an
 exception-throwing value is passed in.</p><p><strong>Example.</strong> This program runs benchmarks in an environment that
 contains two values.  The first value is the contents of a text
 file; the second is a string.  Pay attention to the use of a lazy
 pattern to deconstruct the tuple in the function that returns the
 benchmarks to be run.</p><pre>setupEnv = do
  let small = replicate 1000 (1 :: Int)
  big &lt;- map length . words &lt;$&gt; readFile &quot;/usr/dict/words&quot;
  return (small, big)

main = defaultMain [
   -- notice the lazy pattern match here!
   env setupEnv $ \ ~(small,big) -&gt; bgroup &quot;main&quot; [
   bgroup &quot;small&quot; [
     bench &quot;length&quot; $ whnf length small
   , bench &quot;length . filter&quot; $ whnf (length . filter (==1)) small
   ]
 ,  bgroup &quot;big&quot; [
     bench &quot;length&quot; $ whnf length big
   , bench &quot;length . filter&quot; $ whnf (length . filter (==1)) big
   ]
 ] ]</pre><p><strong>Discussion.</strong> The environment created in the example above is
 intentionally <em>not</em> ideal.  As Haskell's scoping rules suggest, the
 variable <code>big</code> is in scope for the benchmarks that use only
 <code>small</code>.  It would be better to create a separate environment for
 <code>big</code>, so that it will not be kept alive while the unrelated
 benchmarks are being run.</p></div></div><div class="top"><p class="src"><a id="v:envWithCleanup" class="def">envWithCleanup</a> <a href="src/Criterion.Types.html#envWithCleanup" class="link">Source</a> <a href="#v:envWithCleanup" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env</td><td class="doc"><p>Create the environment.  The environment will be evaluated to
 normal form before being passed to the benchmark.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a)</td><td class="doc"><p>Clean up the created environment.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a>)</td><td class="doc"><p>Take the newly created environment and make it available to
 the given benchmarks.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Criterion-Main.html#v:env">env</a></code>, but but allows for an additional callback
 to clean up the environment. Resource clean up is exception safe, that is,
 it runs even if the <code><a href="Criterion-Main.html#t:Benchmark">Benchmark</a></code> throws an exception.</p></div></div><div class="top"><p class="src"><a id="v:perBatchEnv" class="def">perBatchEnv</a> <a href="src/Criterion.Types.html#perBatchEnv" class="link">Source</a> <a href="#v:perBatchEnv" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env)</td><td class="doc"><p>Create an environment for a batch of N runs. The environment will be
 evaluated to normal form before running.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b)</td><td class="doc"><p>Function returning the IO action that should be benchmarked with the
 newly generated environment.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a Benchmarkable where a fresh environment is allocated for every
 batch of runs of the benchmarkable.</p><p>The environment is evaluated to normal form before the benchmark is run.</p><p>When using <code><a href="Criterion-Main.html#v:whnf">whnf</a></code>, <code><a href="Criterion-Main.html#v:whnfIO">whnfIO</a></code>, etc. Criterion creates a <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code>
 whichs runs a batch of <code>N</code> repeat runs of that expressions. Criterion may
 run any number of these batches to get accurate measurements. Environments
 created by <code><a href="Criterion-Main.html#v:env">env</a></code> and <code><a href="Criterion-Main.html#v:envWithCleanup">envWithCleanup</a></code>, are shared across all these batches
 of runs.</p><p>This is fine for simple benchmarks on static input, but when benchmarking
 IO operations where these operations can modify (and especially grow) the
 environment this means that later batches might have their accuracy effected
 due to longer, for example, longer garbage collection pauses.</p><p>An example: Suppose we want to benchmark writing to a Chan, if we allocate
 the Chan using environment and our benchmark consists of <code>writeChan env ()</code>,
 the contents and thus size of the Chan will grow with every repeat. If
 Criterion runs a 1,000 batches of 1,000 repeats, the result is that the
 channel will have 999,000 items in it by the time the last batch is run.
 Since GHC GC has to copy the live set for every major GC this means our last
 set of writes will suffer a lot of noise of the previous repeats.</p><p>By allocating a fresh environment for every batch of runs this function
 should eliminate this effect.</p></div></div><div class="top"><p class="src"><a id="v:perBatchEnvWithCleanup" class="def">perBatchEnvWithCleanup</a> <a href="src/Criterion.Types.html#perBatchEnvWithCleanup" class="link">Source</a> <a href="#v:perBatchEnvWithCleanup" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env)</td><td class="doc"><p>Create an environment for a batch of N runs. The environment will be
 evaluated to normal form before running.</p></td></tr><tr><td class="src">-&gt; (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ())</td><td class="doc"><p>Clean up the created environment.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b)</td><td class="doc"><p>Function returning the IO action that should be benchmarked with the
 newly generated environment.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Criterion-Main.html#v:perBatchEnv">perBatchEnv</a></code>, but but allows for an additional callback
 to clean up the environment. Resource clean up is exception safe, that is,
 it runs even if the <code><a href="Criterion-Main.html#t:Benchmark">Benchmark</a></code> throws an exception.</p></div></div><div class="top"><p class="src"><a id="v:perRunEnv" class="def">perRunEnv</a> <a href="src/Criterion.Types.html#perRunEnv" class="link">Source</a> <a href="#v:perRunEnv" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env</td><td class="doc"><p>Action that creates the environment for a single run.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b)</td><td class="doc"><p>Function returning the IO action that should be benchmarked with the
 newly genereted environment.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a Benchmarkable where a fresh environment is allocated for every
 run of the operation to benchmark. This is useful for benchmarking mutable
 operations that need a fresh environment, such as sorting a mutable Vector.</p><p>As with <code><a href="Criterion-Main.html#v:env">env</a></code> and <code><a href="Criterion-Main.html#v:perBatchEnv">perBatchEnv</a></code> the environment is evaluated to normal form
 before the benchmark is run.</p><p>This introduces extra noise and result in reduce accuracy compared to other
 Criterion benchmarks. But allows easier benchmarking for mutable operations
 than was previously possible.</p></div></div><div class="top"><p class="src"><a id="v:perRunEnvWithCleanup" class="def">perRunEnvWithCleanup</a> <a href="src/Criterion.Types.html#perRunEnvWithCleanup" class="link">Source</a> <a href="#v:perRunEnvWithCleanup" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> env, <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> env</td><td class="doc"><p>Action that creates the environment for a single run.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ())</td><td class="doc"><p>Clean up the created environment.</p></td></tr><tr><td class="src">-&gt; (env -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> b)</td><td class="doc"><p>Function returning the IO action that should be benchmarked with the
 newly genereted environment.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Criterion-Main.html#v:perRunEnv">perRunEnv</a></code>, but but allows for an additional callback
 to clean up the environment. Resource clean up is exception safe, that is,
 it runs even if the <code><a href="Criterion-Main.html#t:Benchmark">Benchmark</a></code> throws an exception.</p></div></div><div class="top"><p class="src"><a id="v:toBenchmarkable" class="def">toBenchmarkable</a> :: (<a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> <a href="src/Criterion.Types.html#toBenchmarkable" class="link">Source</a> <a href="#v:toBenchmarkable" class="selflink">#</a></p><div class="doc"><p>Construct a <code><a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></code> value from an impure action, where the <code><a href="../base-4.10.1.0/Data-Int.html#t:Int64">Int64</a></code>
 parameter indicates the number of times to run the action.</p></div></div><div class="top"><p class="src"><a id="v:bench" class="def">bench</a> <a href="src/Criterion.Types.html#bench" class="link">Source</a> <a href="#v:bench" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a></td><td class="doc"><p>A name to identify the benchmark.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a></td><td class="doc"><p>An activity to be benchmarked.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a single benchmark.</p></div></div><div class="top"><p class="src"><a id="v:bgroup" class="def">bgroup</a> <a href="src/Criterion.Types.html#bgroup" class="link">Source</a> <a href="#v:bgroup" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a></td><td class="doc"><p>A name to identify the group of benchmarks.</p></td></tr><tr><td class="src">-&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>]</td><td class="doc"><p>Benchmarks to group under this name.</p></td></tr><tr><td class="src">-&gt; <a href="Criterion-Main.html#t:Benchmark">Benchmark</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Group several benchmarks together under a common name.</p></div></div><h2 id="g:7">Running a benchmark</h2><div class="top"><p class="src"><a id="v:nf" class="def">nf</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> b =&gt; (a -&gt; b) -&gt; a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> <a href="src/Criterion.Types.html#nf" class="link">Source</a> <a href="#v:nf" class="selflink">#</a></p><div class="doc"><p>Apply an argument to a function, and evaluate the result to
 normal form (NF).</p></div></div><div class="top"><p class="src"><a id="v:whnf" class="def">whnf</a> :: (a -&gt; b) -&gt; a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> <a href="src/Criterion.Types.html#whnf" class="link">Source</a> <a href="#v:whnf" class="selflink">#</a></p><div class="doc"><p>Apply an argument to a function, and evaluate the result to weak
 head normal form (WHNF).</p></div></div><div class="top"><p class="src"><a id="v:nfIO" class="def">nfIO</a> :: <a href="../abstract-par-0.3.3/Control-Monad-Par-Class.html#t:NFData">NFData</a> a =&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> <a href="src/Criterion.Types.html#nfIO" class="link">Source</a> <a href="#v:nfIO" class="selflink">#</a></p><div class="doc"><p>Perform an action, then evaluate its result to normal form.
 This is particularly useful for forcing a lazy <code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> action to be
 completely performed.</p></div></div><div class="top"><p class="src"><a id="v:whnfIO" class="def">whnfIO</a> :: <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> a -&gt; <a href="Criterion-Main.html#t:Benchmarkable">Benchmarkable</a> <a href="src/Criterion.Types.html#whnfIO" class="link">Source</a> <a href="#v:whnfIO" class="selflink">#</a></p><div class="doc"><p>Perform an action, then evaluate its result to weak head normal
 form (WHNF).  This is useful for forcing an <code><a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a></code> action whose result
 is an expression to be evaluated down to a more useful value.</p></div></div><h1 id="g:8">Turning a suite of benchmarks into a program</h1><div class="top"><p class="src"><a id="v:defaultMain" class="def">defaultMain</a> :: [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> () <a href="src/Criterion.Main.html#defaultMain" class="link">Source</a> <a href="#v:defaultMain" class="selflink">#</a></p><div class="doc"><p>An entry point that can be used as a <code>main</code> function.</p><pre>import Criterion.Main

fib :: Int -&gt; Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

main = defaultMain [
       bgroup &quot;fib&quot; [ bench &quot;10&quot; $ whnf fib 10
                    , bench &quot;35&quot; $ whnf fib 35
                    , bench &quot;37&quot; $ whnf fib 37
                    ]
                   ]</pre></div></div><div class="top"><p class="src"><a id="v:defaultMainWith" class="def">defaultMainWith</a> :: <a href="Criterion-Types.html#t:Config">Config</a> -&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> () <a href="src/Criterion.Main.html#defaultMainWith" class="link">Source</a> <a href="#v:defaultMainWith" class="selflink">#</a></p><div class="doc"><p>An entry point that can be used as a <code>main</code> function, with
 configurable defaults.</p><p>Example:</p><pre>import Criterion.Main.Options
import Criterion.Main

myConfig = defaultConfig {
              -- Resample 10 times for bootstrapping
              resamples = 10
           }

main = defaultMainWith myConfig [
         bench &quot;fib 30&quot; $ whnf fib 30
       ]</pre><p>If you save the above example as <code>&quot;Fib.hs&quot;</code>, you should be able
 to compile it as follows:</p><pre>ghc -O --make Fib</pre><p>Run <code>&quot;Fib --help&quot;</code> on the command line to get a list of command
 line options.</p></div></div><div class="top"><p class="src"><a id="v:defaultConfig" class="def">defaultConfig</a> :: <a href="Criterion-Types.html#t:Config">Config</a> <a href="src/Criterion.Main.Options.html#defaultConfig" class="link">Source</a> <a href="#v:defaultConfig" class="selflink">#</a></p><div class="doc"><p>Default benchmarking configuration.</p></div></div><h1 id="g:9">Other useful code</h1><div class="top"><p class="src"><a id="v:makeMatcher" class="def">makeMatcher</a> <a href="src/Criterion.Main.html#makeMatcher" class="link">Source</a> <a href="#v:makeMatcher" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Criterion-Main-Options.html#t:MatchType">MatchType</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; [<a href="../base-4.10.1.0/Data-String.html#t:String">String</a>]</td><td class="doc"><p>Command line arguments.</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.10.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> (<a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a function that can tell if a name given on the command
 line matches a benchmark.</p></div></div><div class="top"><p class="src"><a id="v:runMode" class="def">runMode</a> :: <a href="Criterion-Main-Options.html#t:Mode">Mode</a> -&gt; [<a href="Criterion-Main.html#t:Benchmark">Benchmark</a>] -&gt; <a href="../base-4.10.1.0/System-IO.html#t:IO">IO</a> () <a href="src/Criterion.Main.html#runMode" class="link">Source</a> <a href="#v:runMode" class="selflink">#</a></p><div class="doc"><p>Run a set of <code><a href="Criterion-Main.html#t:Benchmark">Benchmark</a></code>s with the given <code><a href="Criterion-Main-Options.html#t:Mode">Mode</a></code>.</p><p>This can be useful if you have a <code><a href="Criterion-Main-Options.html#t:Mode">Mode</a></code> from some other source (e.g. from a
 one in your benchmark driver's command-line parser).</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>