-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Working with colours in Accelerate
--   
--   This package provides data types for colours and transparency for use
--   with Accelerate. For further information refer to the main
--   <i>Accelerate</i> package:
--   <a>http://hackage.haskell.org/package/accelerate</a>.
@package colour-accelerate
@version 0.2.0.0


-- | Names for "familiar" colours, taken from
--   <a>http://paulbourke.net/texture_colour/colourspace/</a>
module Data.Array.Accelerate.Data.Colour.Names
class NamedColour c

antiqueWhite :: NamedColour c => c

azure :: NamedColour c => c

bisque :: NamedColour c => c

blanchedAlmond :: NamedColour c => c

cornsilk :: NamedColour c => c

eggshell :: NamedColour c => c

floralWhite :: NamedColour c => c

gainsboro :: NamedColour c => c

ghostWhite :: NamedColour c => c

honeydew :: NamedColour c => c

ivory :: NamedColour c => c

lavender :: NamedColour c => c

lavenderBlush :: NamedColour c => c

lemonChiffon :: NamedColour c => c

linen :: NamedColour c => c

mintCream :: NamedColour c => c

mistyRose :: NamedColour c => c

moccasin :: NamedColour c => c

navajoWhite :: NamedColour c => c

oldLace :: NamedColour c => c

papayaWhip :: NamedColour c => c

peachPuff :: NamedColour c => c

seashell :: NamedColour c => c

snow :: NamedColour c => c

thistle :: NamedColour c => c

titaniumWhite :: NamedColour c => c

wheat :: NamedColour c => c

white :: NamedColour c => c

whiteSmoke :: NamedColour c => c

zincWhite :: NamedColour c => c

coldGrey :: NamedColour c => c

dimGrey :: NamedColour c => c

grey :: NamedColour c => c

lightGrey :: NamedColour c => c

slateGrey :: NamedColour c => c

slateGreyDark :: NamedColour c => c

slateGreyLight :: NamedColour c => c

warmGrey :: NamedColour c => c

black :: NamedColour c => c

ivoryBlack :: NamedColour c => c

lampBlack :: NamedColour c => c

alizarinCrimson :: NamedColour c => c

brick :: NamedColour c => c

cadmiumRedDeep :: NamedColour c => c

coral :: NamedColour c => c

coralLight :: NamedColour c => c

deepPink :: NamedColour c => c

englishRed :: NamedColour c => c

firebrick :: NamedColour c => c

geraniumLake :: NamedColour c => c

hotPink :: NamedColour c => c

indianRed :: NamedColour c => c

lightSalmon :: NamedColour c => c

madderLakeDeep :: NamedColour c => c

maroon :: NamedColour c => c

pink :: NamedColour c => c

pinkLight :: NamedColour c => c

raspberry :: NamedColour c => c

red :: NamedColour c => c

roseMadder :: NamedColour c => c

salmon :: NamedColour c => c

tomato :: NamedColour c => c

venetianRed :: NamedColour c => c

beige :: NamedColour c => c

brown :: NamedColour c => c

brownMadder :: NamedColour c => c

brownOchre :: NamedColour c => c

burlywood :: NamedColour c => c

burntSienna :: NamedColour c => c

burntUmber :: NamedColour c => c

chocolate :: NamedColour c => c

deepOchre :: NamedColour c => c

flesh :: NamedColour c => c

fleshOchre :: NamedColour c => c

goldOchre :: NamedColour c => c

greenishUmber :: NamedColour c => c

khaki :: NamedColour c => c

khakiDark :: NamedColour c => c

lightBeige :: NamedColour c => c

peru :: NamedColour c => c

rosyBrown :: NamedColour c => c

rawSienna :: NamedColour c => c

rawUmber :: NamedColour c => c

sepia :: NamedColour c => c

sienna :: NamedColour c => c

saddleBrown :: NamedColour c => c

sandyBrown :: NamedColour c => c

tan :: NamedColour c => c

vanDykeBrown :: NamedColour c => c

cadmiumOrange :: NamedColour c => c

cadmiumRedLight :: NamedColour c => c

carrot :: NamedColour c => c

darkOrange :: NamedColour c => c

marsOrange :: NamedColour c => c

marsYellow :: NamedColour c => c

orange :: NamedColour c => c

orangeRed :: NamedColour c => c

yellowOchre :: NamedColour c => c

aureolineYellow :: NamedColour c => c

banana :: NamedColour c => c

cadmiumLemon :: NamedColour c => c

cadmiumYellow :: NamedColour c => c

gold :: NamedColour c => c

goldenrod :: NamedColour c => c

goldenrodDark :: NamedColour c => c

goldenrodLight :: NamedColour c => c

goldenrodPale :: NamedColour c => c

lightGoldenrod :: NamedColour c => c

melon :: NamedColour c => c

naplesYellowDeep :: NamedColour c => c

yellow :: NamedColour c => c

yellowLight :: NamedColour c => c

chartreuse :: NamedColour c => c

chromeoxideGreen :: NamedColour c => c

cinnabarGreen :: NamedColour c => c

cobaltGreen :: NamedColour c => c

emeraldGreen :: NamedColour c => c

forestGreen :: NamedColour c => c

green :: NamedColour c => c

greenDark :: NamedColour c => c

greenPale :: NamedColour c => c

greenYellow :: NamedColour c => c

lawnGreen :: NamedColour c => c

limeGreen :: NamedColour c => c

mint :: NamedColour c => c

olive :: NamedColour c => c

oliveDrab :: NamedColour c => c

oliveGreenDark :: NamedColour c => c

permanentGreen :: NamedColour c => c

sapGreen :: NamedColour c => c

seaGreen :: NamedColour c => c

seaGreenDark :: NamedColour c => c

seaGreenMedium :: NamedColour c => c

seaGreenLight :: NamedColour c => c

springGreen :: NamedColour c => c

springGreenMedium :: NamedColour c => c

terreVerte :: NamedColour c => c

viridianLight :: NamedColour c => c

yellowGreen :: NamedColour c => c

aquamarine :: NamedColour c => c

aquamarineMedium :: NamedColour c => c

cyan :: NamedColour c => c

cyanWhite :: NamedColour c => c

turquoise :: NamedColour c => c

turquoiseDark :: NamedColour c => c

turquoiseMedium :: NamedColour c => c

turquoisePale :: NamedColour c => c

aliceBlue :: NamedColour c => c

blue :: NamedColour c => c

blueLight :: NamedColour c => c

blueMedium :: NamedColour c => c

cadet :: NamedColour c => c

cobalt :: NamedColour c => c

cornflower :: NamedColour c => c

cerulean :: NamedColour c => c

dodgerBlue :: NamedColour c => c

indigo :: NamedColour c => c

manganeseBlue :: NamedColour c => c

midnightBlue :: NamedColour c => c

navy :: NamedColour c => c

peacock :: NamedColour c => c

powderBlue :: NamedColour c => c

royalBlue :: NamedColour c => c

slateBlue :: NamedColour c => c

slateBlueDark :: NamedColour c => c

slateBlueLight :: NamedColour c => c

slateBlueMedium :: NamedColour c => c

skyBlue :: NamedColour c => c

skyBlueDeep :: NamedColour c => c

skyBlueLight :: NamedColour c => c

steelBlue :: NamedColour c => c

steelBlueLight :: NamedColour c => c

turquoiseBlue :: NamedColour c => c

ultramarine :: NamedColour c => c

blueViolet :: NamedColour c => c

cobaltVioletDeep :: NamedColour c => c

magenta :: NamedColour c => c

orchid :: NamedColour c => c

orchidDark :: NamedColour c => c

orchidMedium :: NamedColour c => c

permanentViolet :: NamedColour c => c

plum :: NamedColour c => c

purple :: NamedColour c => c

purpleMedium :: NamedColour c => c

ultramarineViolet :: NamedColour c => c

violet :: NamedColour c => c

violetDark :: NamedColour c => c

violetRed :: NamedColour c => c

violetRedMedium :: NamedColour c => c

violetRedPale :: NamedColour c => c
instance (Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Data.Colour.Names.NamedColour c) => Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Smart.Exp c)


-- | RGB triples for an unspecified colour space
module Data.Array.Accelerate.Data.Colour.RGB

-- | An RGB colour value
type Colour = RGB Float
data RGB a
RGB :: a -> a -> a -> RGB a

-- | Construct an RGB colour from individual channel components. The
--   components will be clamped to the range [0..1].
rgb :: Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct a colour from 8-bit-per-channel colour components.
rgb8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Clamp each component of a colour to the range [0..1].
clamp :: Exp Colour -> Exp Colour

-- | Blend two colours in the given proportions.
--   
--   Note that this uses an approximation of gamma=2 (i.e. sum-of-squares
--   method). It is recommended to instead convert to the sRGB colour space
--   if you want more accurate colour blending, or if you intend to use the
--   gamma-corrected values more than once (e.g. in a stencil).
--   
--   <pre>
--   blend c1 c2 ~= SRGB.toRGB ( (SRGB.fromRGB c1 + SRGB.fromRGB c2) / 2 )
--   </pre>
--   
--   See the Blur program in the examples for a comparison of mixing
--   colours in the RGB and sRGB colour spaces.
blend :: Exp Float -> Exp Float -> Exp Colour -> Exp Colour -> Exp Colour

-- | Luminance of an RGB colour (Y component of a YUV colour).
luminance :: Exp Colour -> Exp Float

-- | Convert a Colour into a packed-word RGBA representation
packRGB :: Exp Colour -> Exp Word32

-- | Convert a colour into a packed-word ABGR representation
packBGR :: Exp Colour -> Exp Word32

-- | Convert a colour from a packed-word RGBA representation
unpackRGB :: Exp Word32 -> Exp Colour

-- | Convert a colour from a packed-word ABGR representation
unpackBGR :: Exp Word32 -> Exp Colour
packRGB8 :: Exp (RGB Word8) -> Exp Word32
packBGR8 :: Exp (RGB Word8) -> Exp Word32
unpackRGB8 :: Exp Word32 -> Exp (RGB Word8)
unpackBGR8 :: Exp Word32 -> Exp (RGB Word8)
instance GHC.Base.Functor Data.Array.Accelerate.Data.Colour.RGB.RGB
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGB.RGB (Data.Array.Accelerate.Smart.Exp a))
instance GHC.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance (GHC.Num.Num a, GHC.Real.Fractional a) => GHC.Real.Fractional (Data.Array.Accelerate.Data.Colour.RGB.RGB a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGB.RGB a))
instance Data.Array.Accelerate.Classes.Fractional.Fractional a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGB.RGB a))
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.RGB.RGB GHC.Word.Word8)
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.RGB.RGB GHC.Types.Float)


-- | Colours in the HSV (hue-saturation-value) cylindrical-coordinate
--   representation of points in the RGB colour space.
module Data.Array.Accelerate.Data.Colour.HSV

-- | A HSV colour value
type Colour = HSV Float
data HSV a
HSV :: a -> a -> a -> HSV a

-- | Construct a HSV colour value from the individual channel components.
--   The hue component is measured in degrees and wrapped to the range
--   [0..360), while the saturation and value are clamped to the range
--   [0..1].
hsv :: Exp Float -> Exp Float -> Exp Float -> Exp Colour
clamp :: Exp Colour -> Exp Colour

-- | Convert a HSV colour to an RGB colour-space value
toRGB :: Exp (HSV Float) -> Exp (RGB Float)

-- | Convert a point in the RGB colour-space to a point in the HSV
--   colour-space.
fromRGB :: Exp (RGB Float) -> Exp (HSV Float)

-- | Return the HSV-hue of an RGB colour
hue :: Exp (RGB Float) -> Exp Float

-- | Return the HSV-saturation of an RGB colour
saturation :: Exp (RGB Float) -> Exp Float

-- | Return the HSV-value of an RGB colour
value :: Exp (RGB Float) -> Exp Float
instance GHC.Base.Functor Data.Array.Accelerate.Data.Colour.HSV.HSV
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSV.HSV (Data.Array.Accelerate.Smart.Exp a))
instance GHC.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance (GHC.Num.Num a, GHC.Real.Fractional a) => GHC.Real.Fractional (Data.Array.Accelerate.Data.Colour.HSV.HSV a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSV.HSV a))
instance Data.Array.Accelerate.Classes.Fractional.Fractional a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSV.HSV a))
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.HSV.HSV GHC.Types.Float)


-- | Colours in the HSL (hue-saturation-lightness) cylindrical-coordinate
--   representation of points in the RGB colour space.
module Data.Array.Accelerate.Data.Colour.HSL

-- | A HSL colour value
type Colour = HSL Float
data HSL a
HSL :: a -> a -> a -> HSL a

-- | Construct a HSL colour value from the individual channel components.
--   The hue component is measured in degrees and wrapped to the range
--   [0..360), while the saturation and value are clamped to the range
--   [0..1].
hsl :: Exp Float -> Exp Float -> Exp Float -> Exp Colour
clamp :: Exp Colour -> Exp Colour

-- | Convert a HSL colour to an RGB colour-space value
toRGB :: Exp (HSL Float) -> Exp (RGB Float)

-- | Convert a point in the RGB colour-space to a point in the HSL
--   colour-space.
fromRGB :: Exp (RGB Float) -> Exp (HSL Float)

-- | Return the HSL-hue of an RGB colour
hue :: Exp (RGB Float) -> Exp Float

-- | Return the HSL-saturation of an RGB colour
saturation :: Exp (RGB Float) -> Exp Float

-- | Return the HSL-lightness of an RGB colour
lightness :: Exp (RGB Float) -> Exp Float
instance GHC.Base.Functor Data.Array.Accelerate.Data.Colour.HSL.HSL
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSL.HSL (Data.Array.Accelerate.Smart.Exp a))
instance GHC.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance (GHC.Num.Num a, GHC.Real.Fractional a) => GHC.Real.Fractional (Data.Array.Accelerate.Data.Colour.HSL.HSL a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSL.HSL a))
instance Data.Array.Accelerate.Classes.Fractional.Fractional a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.HSL.HSL a))
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.HSL.HSL GHC.Types.Float)


-- | RGBA quadruples for an unspecified colour space
module Data.Array.Accelerate.Data.Colour.RGBA

-- | An RGBA colour value.
type Colour = RGBA Float

-- | An RGBA colour value to hold the colour components. All components lie
--   in the range [0..1).
--   
--   We need to parameterise by a type so that we can have both Exp (RGBA
--   a) and RGBA (Exp a).
data RGBA a
RGBA :: a -> a -> a -> a -> RGBA a

-- | Construct an RGBA colour from individual channel components. The
--   components will be clamped to the range [0..1].
rgba :: Exp Float -> Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct a colour from 8-bits-per-channel colour components.
rgba8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Clamp each component to the range [0..1]
clamp :: Exp Colour -> Exp Colour

-- | Blend two colours in the given proportions.
--   
--   Note that this uses an approximation of gamma=2 (i.e. sum-of-squares
--   method). It is recommended to instead convert to the sRGB colour space
--   if you want more accurate colour blending, or if you intend to use the
--   gamma-corrected values more than once (e.g. in a stencil).
--   
--   <pre>
--   blend c1 c2 ~= SRGB.toRGB ( (SRGB.fromRGB c1 + SRGB.fromRGB c2) / 2 )
--   </pre>
--   
--   See the Blur program in the examples for a comparison of mixing
--   colours in the RGB and sRGB colour spaces.
blend :: Exp Float -> Exp Float -> Exp Colour -> Exp Colour -> Exp Colour

-- | Luminance of an RGB colour (Y component of a YUV colour).
luminance :: Exp Colour -> Exp Float

-- | Set the opacity of the given colour. The opacity is clamped to the
--   range [0..1].
opacity :: Exp Float -> Exp Colour -> Exp Colour

-- | A completely opaque colour
opaque :: Exp Colour -> Exp Colour

-- | Make colour transparent
transparent :: Exp Colour -> Exp Colour

-- | Convert a Colour into a packed-word RGBA representation
packRGBA :: Exp Colour -> Exp Word32

-- | Convert a colour into a packed-word ABGR representation
packABGR :: Exp Colour -> Exp Word32

-- | Convert a colour from a packed-word RGBA representation
unpackRGBA :: Exp Word32 -> Exp Colour

-- | Convert a colour from a packed-word ABGR representation
unpackABGR :: Exp Word32 -> Exp Colour
packRGBA8 :: Exp (RGBA Word8) -> Exp Word32
packABGR8 :: Exp (RGBA Word8) -> Exp Word32
unpackRGBA8 :: Exp Word32 -> Exp (RGBA Word8)
unpackABGR8 :: Exp Word32 -> Exp (RGBA Word8)
instance GHC.Base.Functor Data.Array.Accelerate.Data.Colour.RGBA.RGBA
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGBA.RGBA (Data.Array.Accelerate.Smart.Exp a))
instance GHC.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance (GHC.Num.Num a, GHC.Real.Fractional a) => GHC.Real.Fractional (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a))
instance Data.Array.Accelerate.Classes.Fractional.Fractional a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Data.Colour.RGBA.RGBA a))
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.RGBA.RGBA GHC.Word.Word8)
instance Data.Array.Accelerate.Data.Colour.Names.NamedColour (Data.Array.Accelerate.Data.Colour.RGBA.RGBA GHC.Types.Float)


-- | Colours in the sRGB standard.
module Data.Array.Accelerate.Data.Colour.SRGB

-- | An sRGB colour value
type Colour = SRGB Float

-- | Synonym for an RGB colour that is in the sRGB colour space.
type SRGB a = RGB a

-- | Construct an sRGB colour from individual channel components. The
--   components will be clamped to the range [0..1].
srgb :: Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct an sRGB colour from 8-bit-per-channel colour components.
srgb8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Convert a colour in the linear sRGB colour space into the non-linear
--   RGB colour space.
toRGB :: Exp (SRGB Float) -> Exp (RGB Float)

-- | Convert a colour in the non-linear RGB colour space into the linear
--   sRGB colour space.
fromRGB :: Exp (RGB Float) -> Exp (SRGB Float)
