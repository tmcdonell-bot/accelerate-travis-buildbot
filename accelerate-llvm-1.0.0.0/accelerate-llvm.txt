-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Accelerate backend generating LLVM
--   
--   This library implements direct LLVM IR generation for the
--   <i>Accelerate</i> language. For further information, refer to the main
--   <a>accelerate</a> package.
--   
--   <ul>
--   <li><i><i>Dependencies</i></i></li>
--   </ul>
--   
--   Haskell dependencies are available from Hackage. The following
--   external libraries are alse required:
--   
--   <ul>
--   <li><a>LLVM</a></li>
--   <li><a>libFFI</a> (if using <a>accelerate-llvm-native</a>)</li>
--   <li><a>CUDA</a> (if using <a>accelerate-llvm-ptx</a>)</li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Installing LLVM</i></i></li>
--   </ul>
--   
--   <i>Homebrew</i>
--   
--   Example using Homebrew on macOS:
--   
--   <pre>
--   brew install llvm-hs/homebrew-llvm/llvm-4.0
--   </pre>
--   
--   <i>Debian &amp; Ubuntu</i>
--   
--   For Debian/Ubuntu based Linux distributions, the LLVM.org website
--   provides binary distribution packages. Check <a>apt.llvm.org</a> for
--   instructions for adding the correct package database for your OS
--   version, and then:
--   
--   <pre>
--   apt-get install llvm-4.0-dev
--   </pre>
--   
--   <i>Building from source</i>
--   
--   If your OS does not have an appropriate LLVM distribution available,
--   you can also build from source. Detailed build instructions are
--   available on <a>LLVM.org</a>. Make sure to include the cmake build
--   options <tt>-DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON</tt>
--   so that the <tt>libLLVM</tt> shared library will be built.
--   
--   If using the <tt>accelerate-llvm-ptx</tt> backend, also ensure that
--   the <tt>LLVM_TARGETS_TO_BUILD</tt> option includes the <tt>NVPTX</tt>
--   target (if not specified, all targets are built).
--   
--   <ul>
--   <li><i><i>Installing accelerate-llvm</i></i></li>
--   </ul>
--   
--   To use <tt>accelerate-llvm</tt> it is important that the
--   <tt>llvm-hs</tt> package is installed against the <tt>libLLVM</tt>
--   shared library, rather than statically linked, so that we can use LLVM
--   from GHCi and Template Haskell. This is the default configuration, but
--   you can also enforce this explicitly by adding the following to your
--   <tt>stack.yaml</tt> file:
--   
--   <pre>
--   flags:
--     llvm-hs:
--       shared-llvm: true
--   </pre>
--   
--   Or by specifying the <tt>shared-llvm</tt> flag to cabal:
--   
--   <pre>
--   cabal install llvm-hs -fshared-llvm
--   </pre>
@package accelerate-llvm
@version 1.0.0.0


module Data.Array.Accelerate.LLVM.Link.Cache
data LinkCache f o
new :: IO (LinkCache f o)
dlsym :: Int -> LinkCache f o -> IO (f, o) -> IO (Lifetime f)


module Data.Array.Accelerate.LLVM.Embed
class Embed arch

-- | Turn the compiled object into a TemplateHaskell expression, suitable
--   for use in a splice. The splice should evaluate into the
--   backend-specific executable representation.
embedForTarget :: Embed arch => ObjectR arch -> Q (TExp (ExecutableR arch))

-- | Embed the compiled array function into a TemplateHaskell expression,
--   suitable for use in a splice.
embedAfun :: Embed arch => CompiledAfun arch f -> Q (TExp (ExecAfun arch f))
embedOpenAfun :: Embed arch => CompiledOpenAfun arch aenv f -> Q (TExp (ExecOpenAfun arch aenv f))
