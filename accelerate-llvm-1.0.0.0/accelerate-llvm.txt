-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Accelerate backend generating LLVM
--   
--   This library implements direct LLVM IR generation for the
--   <i>Accelerate</i> language. For further information, refer to the main
--   <a>accelerate</a> package.
--   
--   <ul>
--   <li><i><i>Dependencies</i></i></li>
--   </ul>
--   
--   Haskell dependencies are available from Hackage. The following
--   external libraries are alse required:
--   
--   <ul>
--   <li><a>LLVM</a></li>
--   <li><a>libFFI</a> (if using <a>accelerate-llvm-native</a>)</li>
--   <li><a>CUDA</a> (if using <a>accelerate-llvm-ptx</a>)</li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Installing LLVM</i></i></li>
--   </ul>
--   
--   <i>Homebrew</i>
--   
--   Example using Homebrew on macOS:
--   
--   <pre>
--   brew install llvm-hs/homebrew-llvm/llvm-4.0
--   </pre>
--   
--   <i>Debian &amp; Ubuntu</i>
--   
--   For Debian/Ubuntu based Linux distributions, the LLVM.org website
--   provides binary distribution packages. Check <a>apt.llvm.org</a> for
--   instructions for adding the correct package database for your OS
--   version, and then:
--   
--   <pre>
--   apt-get install llvm-4.0-dev
--   </pre>
--   
--   <i>Building from source</i>
--   
--   If your OS does not have an appropriate LLVM distribution available,
--   you can also build from source. Detailed build instructions are
--   available on <a>LLVM.org</a>. Make sure to include the cmake build
--   options <tt>-DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON</tt>
--   so that the <tt>libLLVM</tt> shared library will be built.
--   
--   If using the <tt>accelerate-llvm-ptx</tt> backend, also ensure that
--   the <tt>LLVM_TARGETS_TO_BUILD</tt> option includes the <tt>NVPTX</tt>
--   target (if not specified, all targets are built).
--   
--   <ul>
--   <li><i><i>Installing accelerate-llvm</i></i></li>
--   </ul>
--   
--   To use <tt>accelerate-llvm</tt> it is important that the
--   <tt>llvm-hs</tt> package is installed against the <tt>libLLVM</tt>
--   shared library, rather than statically linked, so that we can use LLVM
--   from GHCi and Template Haskell. This is the default configuration, but
--   you can also enforce this explicitly by adding the following to your
--   <tt>stack.yaml</tt> file:
--   
--   <pre>
--   flags:
--     llvm-hs:
--       shared-llvm: true
--   </pre>
--   
--   Or by specifying the <tt>shared-llvm</tt> flag to cabal:
--   
--   <pre>
--   cabal install llvm-hs -fshared-llvm
--   </pre>
@package accelerate-llvm
@version 1.0.0.0


module Data.ByteString.Short.Extra

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString :: *

-- | <i>O(n)</i> <tt><a>take</a> n</tt> applied to the ShortByteString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt> as
--   a new ShortByteString, or <tt>xs</tt> itself if <tt>n &gt;
--   <a>length</a> xs</tt>
take :: Int -> ShortByteString -> ShortByteString


module Data.ByteString.Short.Char8

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString :: *

-- | <i>O(n)</i> Convert a <a>ShortByteString</a> into a list.
unpack :: ShortByteString -> [Char]
