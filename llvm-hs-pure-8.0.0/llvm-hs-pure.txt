-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure Haskell LLVM functionality (no FFI).
--   
--   llvm-hs-pure is a set of pure Haskell types and functions for
--   interacting with LLVM <a>http://llvm.org/</a>. It includes an ADT to
--   represent LLVM IR (<a>http://llvm.org/docs/LangRef.html</a>). The
--   llvm-hs package builds on this one with FFI bindings to LLVM, but
--   llvm-hs-pure does not require LLVM to be available.
@package llvm-hs-pure
@version 8.0.0


-- | This module is presents a prelude mostly like the
--   post-Applicative-Monad world of base &gt;= 4.8 / ghc &gt;= 7.10, as
--   well as the post-Semigroup-Monoid world of base &gt;= 4.11 / ghc &gt;=
--   8.4, even on earlier versions. It's intended as an internal library
--   for llvm-hs-pure and llvm-hs; it's exposed only to be shared between
--   the two.
module LLVM.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: () => [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: () => a -> b -> b

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: () => (a -> Bool) -> [a] -> [a]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: () => [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: () => (a, b) -> a

-- | Extract the second component of a pair.
snd :: () => (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: () => (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   '(+)', '(*)' and <a>exp</a> are customarily expected to define an
--   exponential field and have the following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = @exp a * exp b</li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   '(+)' and '(*)' are customarily expected to define a division ring and
--   have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the 'div'/'mod'
--   and 'quot'/'rem' pairs, given suitable Euclidean functions <tt>f</tt>
--   and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However, '(+)' and
--   '(*)' are customarily expected to define a ring and have the following
--   properties:
--   
--   <ul>
--   <li><i><b>Associativity of (+)</b></i> <tt>(x + y) + z</tt> = <tt>x +
--   (y + z)</tt></li>
--   <li><i><b>Commutativity of (+)</b></i> <tt>x + y</tt> = <tt>y +
--   x</tt></li>
--   <li><i><b><tt>fromInteger 0</tt> is the additive identity</b></i>
--   <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of (*)</b></i> <tt>(x * y) * z</tt> = <tt>x *
--   (y * z)</tt></li>
--   <li><i><b><tt>fromInteger 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of (*) with respect to (+)</b></i> <tt>a * (b
--   + c)</tt> = <tt>(a * b) + (a * c)</tt> and <tt>(b + c) * a</tt> =
--   <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <tt>Rational</tt> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <
infix 4 <=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><tt>uncurry</tt> <a>encodeFloat</a> (<a>decodeFloat</a> x) =
--   x</tt>. <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: () => IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <a>fail</a> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: () => (a -> c) -> (b -> c) -> Either a b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: () => Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: () => [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: () => [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: () => (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: () => (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: () => [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: () => [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: () => Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: () => Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: () => Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: () => [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: () => Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: () => a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: () => (a -> a) -> a -> [a]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: () => (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: () => (b -> a -> b) -> b -> [a] -> [b]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: () => [a] -> [a]

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: () => [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: () => [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: () => [a] -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> (a -> b) -> Maybe a -> b

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: () => (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: () => ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: () => a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: () => (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: () => (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: () => (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: () => a -> b -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: () => a -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: () => [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: HasCallStack => [Char] -> a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a
leftBiasedZip :: [a] -> [b] -> [(a, Maybe b)]
findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
ifM :: Monad m => m Bool -> m a -> m a -> m a

module LLVM.IRBuilder.Internal.SnocList
newtype SnocList a
SnocList :: [a] -> SnocList a
[unSnocList] :: SnocList a -> [a]
snoc :: SnocList a -> a -> SnocList a
getSnocList :: SnocList a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (LLVM.IRBuilder.Internal.SnocList.SnocList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LLVM.IRBuilder.Internal.SnocList.SnocList a)
instance GHC.Base.Semigroup (LLVM.IRBuilder.Internal.SnocList.SnocList a)
instance GHC.Base.Monoid (LLVM.IRBuilder.Internal.SnocList.SnocList a)


-- | Module to allow importing <a>Visibility</a> distinctly qualified.
module LLVM.AST.Visibility

-- | <a>http://llvm.org/docs/LangRef.html#visibility</a>
data Visibility
Default :: Visibility
Hidden :: Visibility
Protected :: Visibility
instance GHC.Generics.Generic LLVM.AST.Visibility.Visibility
instance Data.Data.Data LLVM.AST.Visibility.Visibility
instance GHC.Show.Show LLVM.AST.Visibility.Visibility
instance GHC.Read.Read LLVM.AST.Visibility.Visibility
instance GHC.Classes.Eq LLVM.AST.Visibility.Visibility


-- | Module to allow importing <a>Model</a> distinctly qualified.
module LLVM.AST.ThreadLocalStorage

-- | <a>http://llvm.org/docs/LangRef.html#thread-local-storage-models</a>
data Model
GeneralDynamic :: Model
LocalDynamic :: Model
InitialExec :: Model
LocalExec :: Model
instance GHC.Generics.Generic LLVM.AST.ThreadLocalStorage.Model
instance Data.Data.Data LLVM.AST.ThreadLocalStorage.Model
instance GHC.Show.Show LLVM.AST.ThreadLocalStorage.Model
instance GHC.Read.Read LLVM.AST.ThreadLocalStorage.Model
instance GHC.Classes.Ord LLVM.AST.ThreadLocalStorage.Model
instance GHC.Classes.Eq LLVM.AST.ThreadLocalStorage.Model


-- | Operations for the <a>AtomicRMW</a> instruction
module LLVM.AST.RMWOperation

-- | <a>http://llvm.org/docs/LangRef.html#atomicrmw-instruction</a>
data RMWOperation
Xchg :: RMWOperation
Add :: RMWOperation
Sub :: RMWOperation
And :: RMWOperation
Nand :: RMWOperation
Or :: RMWOperation
Xor :: RMWOperation
Max :: RMWOperation
Min :: RMWOperation
UMax :: RMWOperation
UMin :: RMWOperation
instance GHC.Generics.Generic LLVM.AST.RMWOperation.RMWOperation
instance Data.Data.Data LLVM.AST.RMWOperation.RMWOperation
instance GHC.Show.Show LLVM.AST.RMWOperation.RMWOperation
instance GHC.Read.Read LLVM.AST.RMWOperation.RMWOperation
instance GHC.Classes.Ord LLVM.AST.RMWOperation.RMWOperation
instance GHC.Classes.Eq LLVM.AST.RMWOperation.RMWOperation


-- | Module to allow importing <a>ParameterAttribute</a> distinctly
--   qualified.
module LLVM.AST.ParameterAttribute

-- | <a>http://llvm.org/docs/LangRef.html#parameter-attributes</a>
data ParameterAttribute
ZeroExt :: ParameterAttribute
SignExt :: ParameterAttribute
InReg :: ParameterAttribute
SRet :: ParameterAttribute
Alignment :: Word64 -> ParameterAttribute
NoAlias :: ParameterAttribute
ByVal :: ParameterAttribute
NoCapture :: ParameterAttribute
Nest :: ParameterAttribute
ReadNone :: ParameterAttribute
ReadOnly :: ParameterAttribute
WriteOnly :: ParameterAttribute
InAlloca :: ParameterAttribute
NonNull :: ParameterAttribute
Dereferenceable :: Word64 -> ParameterAttribute
DereferenceableOrNull :: Word64 -> ParameterAttribute
Returned :: ParameterAttribute
SwiftSelf :: ParameterAttribute
SwiftError :: ParameterAttribute
StringAttribute :: ShortByteString -> ShortByteString -> ParameterAttribute
[stringAttributeKind] :: ParameterAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: ParameterAttribute -> ShortByteString
instance GHC.Generics.Generic LLVM.AST.ParameterAttribute.ParameterAttribute
instance Data.Data.Data LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Show.Show LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Read.Read LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Classes.Ord LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Classes.Eq LLVM.AST.ParameterAttribute.ParameterAttribute


-- | Names as used in LLVM IR
module LLVM.AST.Name

-- | Objects of various sorts in LLVM IR are identified by address in the
--   LLVM C++ API, and may be given a string name. When printed to (resp.
--   read from) human-readable LLVM assembly, objects without string names
--   are numbered sequentially (resp. must be numbered sequentially).
--   String names may be quoted, and are quoted when printed if they would
--   otherwise be misread - e.g. when containing special characters.
--   
--   <pre>
--   7
--   </pre>
--   
--   means the seventh unnamed object, while
--   
--   <pre>
--   "7"
--   </pre>
--   
--   means the object named with the string "7".
--   
--   This libraries handling of <a>UnName</a>s during translation of the
--   AST down into C++ IR is somewhat more forgiving than the LLVM assembly
--   parser: it does not require that unnamed values be numbered
--   sequentially; however, the numbers of <a>UnName</a>s passed into C++
--   cannot be preserved in the C++ objects. If the C++ IR is printed as
--   assembly or translated into a Haskell AST, unnamed nodes will be
--   renumbered sequentially. Thus unnamed node numbers should be thought
--   of as having any scope limited to the <a>Module</a> in which they are
--   used.
data Name

-- | a string name
Name :: ShortByteString -> Name

-- | a number for a nameless thing
UnName :: Word -> Name

-- | Create a <a>Name</a> based on an ASCII <a>String</a>. Non-ASCII
--   strings will throw an error.
mkName :: String -> Name
instance GHC.Generics.Generic LLVM.AST.Name.Name
instance Data.Data.Data LLVM.AST.Name.Name
instance GHC.Show.Show LLVM.AST.Name.Name
instance GHC.Read.Read LLVM.AST.Name.Name
instance GHC.Classes.Ord LLVM.AST.Name.Name
instance GHC.Classes.Eq LLVM.AST.Name.Name
instance Data.String.IsString LLVM.AST.Name.Name


-- | Module to allow importing <a>Linkage</a> distinctly qualified.
module LLVM.AST.Linkage

-- | <a>http://llvm.org/docs/LangRef.html#linkage</a>
data Linkage
Private :: Linkage
Internal :: Linkage
AvailableExternally :: Linkage
LinkOnce :: Linkage
Weak :: Linkage
Common :: Linkage
Appending :: Linkage
ExternWeak :: Linkage
LinkOnceODR :: Linkage
WeakODR :: Linkage
External :: Linkage
instance GHC.Generics.Generic LLVM.AST.Linkage.Linkage
instance Data.Data.Data LLVM.AST.Linkage.Linkage
instance GHC.Show.Show LLVM.AST.Linkage.Linkage
instance GHC.Read.Read LLVM.AST.Linkage.Linkage
instance GHC.Classes.Eq LLVM.AST.Linkage.Linkage


-- | Predicates for the <a>ICmp</a> instruction
module LLVM.AST.IntegerPredicate

-- | <a>http://llvm.org/docs/LangRef.html#icmp-instruction</a>
data IntegerPredicate
EQ :: IntegerPredicate
NE :: IntegerPredicate
UGT :: IntegerPredicate
UGE :: IntegerPredicate
ULT :: IntegerPredicate
ULE :: IntegerPredicate
SGT :: IntegerPredicate
SGE :: IntegerPredicate
SLT :: IntegerPredicate
SLE :: IntegerPredicate
instance GHC.Generics.Generic LLVM.AST.IntegerPredicate.IntegerPredicate
instance Data.Data.Data LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Show.Show LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Read.Read LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Classes.Ord LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Classes.Eq LLVM.AST.IntegerPredicate.IntegerPredicate


-- | Module to allow importing <a>FunctionAttribute</a> distinctly
--   qualified.
module LLVM.AST.FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#function-attributes</a>
data FunctionAttribute
NoReturn :: FunctionAttribute
NoUnwind :: FunctionAttribute
ReadNone :: FunctionAttribute
ReadOnly :: FunctionAttribute
NoInline :: FunctionAttribute
NoRecurse :: FunctionAttribute
AlwaysInline :: FunctionAttribute
MinimizeSize :: FunctionAttribute
OptimizeForSize :: FunctionAttribute
OptimizeNone :: FunctionAttribute
StackProtect :: FunctionAttribute
StackProtectReq :: FunctionAttribute
StackProtectStrong :: FunctionAttribute
StrictFP :: FunctionAttribute
NoRedZone :: FunctionAttribute
NoImplicitFloat :: FunctionAttribute
Naked :: FunctionAttribute
InlineHint :: FunctionAttribute
StackAlignment :: Word64 -> FunctionAttribute
ReturnsTwice :: FunctionAttribute
UWTable :: FunctionAttribute
NonLazyBind :: FunctionAttribute
Builtin :: FunctionAttribute
NoBuiltin :: FunctionAttribute
Cold :: FunctionAttribute
JumpTable :: FunctionAttribute
NoDuplicate :: FunctionAttribute
SanitizeAddress :: FunctionAttribute
SanitizeHWAddress :: FunctionAttribute
SanitizeThread :: FunctionAttribute
SanitizeMemory :: FunctionAttribute
Speculatable :: FunctionAttribute
StringAttribute :: ShortByteString -> ShortByteString -> FunctionAttribute
[stringAttributeKind] :: FunctionAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: FunctionAttribute -> ShortByteString

-- | AllocSize 0 (Just 0) is invalid
AllocSize :: Word32 -> Maybe Word32 -> FunctionAttribute
WriteOnly :: FunctionAttribute
ArgMemOnly :: FunctionAttribute
Convergent :: FunctionAttribute
InaccessibleMemOnly :: FunctionAttribute
InaccessibleMemOrArgMemOnly :: FunctionAttribute
SafeStack :: FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#attribute-groups</a>
newtype GroupID
GroupID :: Word -> GroupID
instance GHC.Generics.Generic LLVM.AST.FunctionAttribute.GroupID
instance Data.Data.Data LLVM.AST.FunctionAttribute.GroupID
instance GHC.Show.Show LLVM.AST.FunctionAttribute.GroupID
instance GHC.Read.Read LLVM.AST.FunctionAttribute.GroupID
instance GHC.Classes.Ord LLVM.AST.FunctionAttribute.GroupID
instance GHC.Classes.Eq LLVM.AST.FunctionAttribute.GroupID
instance GHC.Generics.Generic LLVM.AST.FunctionAttribute.FunctionAttribute
instance Data.Data.Data LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Show.Show LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Read.Read LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Classes.Ord LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Classes.Eq LLVM.AST.FunctionAttribute.FunctionAttribute


-- | Module to allow importing <tt>Attribute</tt> distinctly qualified.
--   Before LLVM 3.5, the attributes which could be used on functions and
--   those which could be used on parameters were disjoint. In LLVM 3.5,
--   two attributes (readonly and readnone) can be used in both contexts.
--   Because their interpretation is different in the two contexts and only
--   those two attributes can be used in both contexts, I've opted to keep
--   the Haskell types for parameter and function attributes distinct, but
--   move the two types into separate modules so they can have contructors
--   with the same names.
module LLVM.AST.Attribute

-- | <a>http://llvm.org/docs/LangRef.html#parameter-attributes</a>
data ParameterAttribute
ZeroExt :: ParameterAttribute
SignExt :: ParameterAttribute
InReg :: ParameterAttribute
SRet :: ParameterAttribute
Alignment :: Word64 -> ParameterAttribute
NoAlias :: ParameterAttribute
ByVal :: ParameterAttribute
NoCapture :: ParameterAttribute
Nest :: ParameterAttribute
InAlloca :: ParameterAttribute
NonNull :: ParameterAttribute
Dereferenceable :: Word64 -> ParameterAttribute
DereferenceableOrNull :: Word64 -> ParameterAttribute
Returned :: ParameterAttribute
SwiftSelf :: ParameterAttribute
SwiftError :: ParameterAttribute

-- | <a>http://llvm.org/docs/LangRef.html#function-attributes</a>
data FunctionAttribute
NoReturn :: FunctionAttribute
NoUnwind :: FunctionAttribute
ReadNone :: FunctionAttribute
ReadOnly :: FunctionAttribute
NoInline :: FunctionAttribute
NoRecurse :: FunctionAttribute
AlwaysInline :: FunctionAttribute
MinimizeSize :: FunctionAttribute
OptimizeForSize :: FunctionAttribute
OptimizeNone :: FunctionAttribute
StackProtect :: FunctionAttribute
StackProtectReq :: FunctionAttribute
StackProtectStrong :: FunctionAttribute
StrictFP :: FunctionAttribute
NoRedZone :: FunctionAttribute
NoImplicitFloat :: FunctionAttribute
Naked :: FunctionAttribute
InlineHint :: FunctionAttribute
StackAlignment :: Word64 -> FunctionAttribute
ReturnsTwice :: FunctionAttribute
UWTable :: FunctionAttribute
NonLazyBind :: FunctionAttribute
Builtin :: FunctionAttribute
NoBuiltin :: FunctionAttribute
Cold :: FunctionAttribute
JumpTable :: FunctionAttribute
NoDuplicate :: FunctionAttribute
SanitizeAddress :: FunctionAttribute
SanitizeHWAddress :: FunctionAttribute
SanitizeThread :: FunctionAttribute
SanitizeMemory :: FunctionAttribute
Speculatable :: FunctionAttribute
StringAttribute :: ShortByteString -> ShortByteString -> FunctionAttribute
[stringAttributeKind] :: FunctionAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: FunctionAttribute -> ShortByteString

-- | AllocSize 0 (Just 0) is invalid
AllocSize :: Word32 -> Maybe Word32 -> FunctionAttribute
WriteOnly :: FunctionAttribute
ArgMemOnly :: FunctionAttribute
Convergent :: FunctionAttribute
InaccessibleMemOnly :: FunctionAttribute
InaccessibleMemOrArgMemOnly :: FunctionAttribute
SafeStack :: FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#attribute-groups</a>
newtype GroupID
GroupID :: Word -> GroupID


-- | Predicates for the <a>FCmp</a> instruction
module LLVM.AST.FloatingPointPredicate

-- | <a>http://llvm.org/docs/LangRef.html#fcmp-instruction</a>
data FloatingPointPredicate
False :: FloatingPointPredicate
OEQ :: FloatingPointPredicate
OGT :: FloatingPointPredicate
OGE :: FloatingPointPredicate
OLT :: FloatingPointPredicate
OLE :: FloatingPointPredicate
ONE :: FloatingPointPredicate
ORD :: FloatingPointPredicate
UNO :: FloatingPointPredicate
UEQ :: FloatingPointPredicate
UGT :: FloatingPointPredicate
UGE :: FloatingPointPredicate
ULT :: FloatingPointPredicate
ULE :: FloatingPointPredicate
UNE :: FloatingPointPredicate
True :: FloatingPointPredicate
instance GHC.Generics.Generic LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance Data.Data.Data LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Show.Show LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Read.Read LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Classes.Ord LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Classes.Eq LLVM.AST.FloatingPointPredicate.FloatingPointPredicate


-- | This module provides a sub-namespace for a type to support the various
--   sizes of floating point numbers LLVM supports. It is most definitely
--   intended to be imported qualified.
module LLVM.AST.Float

-- | A type summing up the various float types. N.B. Note that in the
--   constructors with multiple fields, the lower significance bits are on
--   the right - e.g. Quadruple highbits lowbits
data SomeFloat
Half :: Word16 -> SomeFloat
Single :: Float -> SomeFloat
Double :: Double -> SomeFloat
Quadruple :: Word64 -> Word64 -> SomeFloat
X86_FP80 :: Word16 -> Word64 -> SomeFloat
PPC_FP128 :: Word64 -> Word64 -> SomeFloat
instance GHC.Generics.Generic LLVM.AST.Float.SomeFloat
instance Data.Data.Data LLVM.AST.Float.SomeFloat
instance GHC.Show.Show LLVM.AST.Float.SomeFloat
instance GHC.Read.Read LLVM.AST.Float.SomeFloat
instance GHC.Classes.Ord LLVM.AST.Float.SomeFloat
instance GHC.Classes.Eq LLVM.AST.Float.SomeFloat


-- | Module to allow importing <a>StorageClass</a> distinctly qualified.
module LLVM.AST.DLL

-- | <a>http://llvm.org/docs/LangRef.html#dll-storage-classes</a>
data StorageClass
Import :: StorageClass
Export :: StorageClass
instance GHC.Generics.Generic LLVM.AST.DLL.StorageClass
instance Data.Data.Data LLVM.AST.DLL.StorageClass
instance GHC.Show.Show LLVM.AST.DLL.StorageClass
instance GHC.Read.Read LLVM.AST.DLL.StorageClass
instance GHC.Classes.Eq LLVM.AST.DLL.StorageClass


-- | Module to allow importing <a>CallingConvention</a> distinctly
--   qualified.
module LLVM.AST.CallingConvention

-- | <a>http://llvm.org/docs/LangRef.html#callingconv</a>
data CallingConvention
C :: CallingConvention
Fast :: CallingConvention
Cold :: CallingConvention
GHC :: CallingConvention
HiPE :: CallingConvention
WebKit_JS :: CallingConvention
AnyReg :: CallingConvention
PreserveMost :: CallingConvention
PreserveAll :: CallingConvention
Swift :: CallingConvention
CXX_FastTLS :: CallingConvention
X86_StdCall :: CallingConvention
X86_FastCall :: CallingConvention
ARM_APCS :: CallingConvention
ARM_AAPCS :: CallingConvention
ARM_AAPCS_VFP :: CallingConvention
MSP430_INTR :: CallingConvention
X86_ThisCall :: CallingConvention
PTX_Kernel :: CallingConvention
PTX_Device :: CallingConvention
SPIR_FUNC :: CallingConvention
SPIR_KERNEL :: CallingConvention
Intel_OCL_BI :: CallingConvention
X86_64_SysV :: CallingConvention
Win64 :: CallingConvention
X86_VectorCall :: CallingConvention
HHVM :: CallingConvention
HHVM_C :: CallingConvention
X86_Intr :: CallingConvention
AVR_Intr :: CallingConvention
AVR_Signal :: CallingConvention
AVR_Builtin :: CallingConvention
AMDGPU_VS :: CallingConvention
AMDGPU_HS :: CallingConvention
AMDGPU_GS :: CallingConvention
AMDGPU_PS :: CallingConvention
AMDGPU_CS :: CallingConvention
AMDGPU_Kernel :: CallingConvention
X86_RegCall :: CallingConvention
MSP430_Builtin :: CallingConvention
Numbered :: Word32 -> CallingConvention
instance GHC.Generics.Generic LLVM.AST.CallingConvention.CallingConvention
instance Data.Data.Data LLVM.AST.CallingConvention.CallingConvention
instance GHC.Show.Show LLVM.AST.CallingConvention.CallingConvention
instance GHC.Read.Read LLVM.AST.CallingConvention.CallingConvention
instance GHC.Classes.Eq LLVM.AST.CallingConvention.CallingConvention


-- | Module to allow importing <a>SelectionKind</a> distinctly qualified.
module LLVM.AST.COMDAT

-- | <a>http://llvm.org/docs/LangRef.html#comdats</a>
data SelectionKind
Any :: SelectionKind
ExactMatch :: SelectionKind
Largest :: SelectionKind
NoDuplicates :: SelectionKind
SameSize :: SelectionKind
instance GHC.Generics.Generic LLVM.AST.COMDAT.SelectionKind
instance Data.Data.Data LLVM.AST.COMDAT.SelectionKind
instance GHC.Show.Show LLVM.AST.COMDAT.SelectionKind
instance GHC.Read.Read LLVM.AST.COMDAT.SelectionKind
instance GHC.Classes.Eq LLVM.AST.COMDAT.SelectionKind


-- | Pointers exist in Address Spaces
module LLVM.AST.AddrSpace

-- | See <a>http://llvm.org/docs/LangRef.html#pointer-type</a>
data AddrSpace
AddrSpace :: Word32 -> AddrSpace
instance GHC.Generics.Generic LLVM.AST.AddrSpace.AddrSpace
instance Data.Data.Data LLVM.AST.AddrSpace.AddrSpace
instance GHC.Show.Show LLVM.AST.AddrSpace.AddrSpace
instance GHC.Read.Read LLVM.AST.AddrSpace.AddrSpace
instance GHC.Classes.Ord LLVM.AST.AddrSpace.AddrSpace
instance GHC.Classes.Eq LLVM.AST.AddrSpace.AddrSpace


-- | A representation of an LLVM type
module LLVM.AST.Type

-- | LLVM supports some special formats floating point format. This type is
--   to distinguish those format. Also see
--   <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
data FloatingPointType

-- | 16-bit floating point value
HalfFP :: FloatingPointType

-- | 32-bit floating point value
FloatFP :: FloatingPointType

-- | 64-bit floating point value
DoubleFP :: FloatingPointType

-- | 128-bit floating point value (112-bit mantissa)
FP128FP :: FloatingPointType

-- | 80-bit floating point value (X87)
X86_FP80FP :: FloatingPointType

-- | 128-bit floating point value (two 64-bits)
PPC_FP128FP :: FloatingPointType

-- | <a>http://llvm.org/docs/LangRef.html#type-system</a>
data Type

-- | <a>http://llvm.org/docs/LangRef.html#void-type</a>
VoidType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#integer-type</a>
IntegerType :: Word32 -> Type
[typeBits] :: Type -> Word32

-- | <a>http://llvm.org/docs/LangRef.html#pointer-type</a>
PointerType :: Type -> AddrSpace -> Type
[pointerReferent] :: Type -> Type
[pointerAddrSpace] :: Type -> AddrSpace

-- | <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
FloatingPointType :: FloatingPointType -> Type
[floatingPointType] :: Type -> FloatingPointType

-- | <a>http://llvm.org/docs/LangRef.html#function-type</a>
FunctionType :: Type -> [Type] -> Bool -> Type
[resultType] :: Type -> Type
[argumentTypes] :: Type -> [Type]
[isVarArg] :: Type -> Bool

-- | <a>http://llvm.org/docs/LangRef.html#vector-type</a>
VectorType :: Word32 -> Type -> Type
[nVectorElements] :: Type -> Word32
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#structure-type</a>
StructureType :: Bool -> [Type] -> Type
[isPacked] :: Type -> Bool
[elementTypes] :: Type -> [Type]

-- | <a>http://llvm.org/docs/LangRef.html#array-type</a>
ArrayType :: Word64 -> Type -> Type
[nArrayElements] :: Type -> Word64
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#opaque-structure-types</a>
NamedTypeReference :: Name -> Type

-- | <a>http://llvm.org/docs/LangRef.html#metadata-type</a>
MetadataType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#label-type</a>
LabelType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#token-type</a>
TokenType :: Type

-- | An abbreviation for <a>VoidType</a>
void :: Type

-- | An abbreviation for <a>IntegerType</a> 1
i1 :: Type

-- | An abbreviation for <a>IntegerType</a> 8
i8 :: Type

-- | An abbreviation for <a>IntegerType</a> 16
i16 :: Type

-- | An abbreviation for <a>IntegerType</a> 32
i32 :: Type

-- | An abbreviation for <a>IntegerType</a> 64
i64 :: Type

-- | An abbreviation for <a>IntegerType</a> 128
i128 :: Type

-- | An abbreviation for <a>PointerType</a> t (<a>AddrSpace</a> 0)
ptr :: Type -> Type

-- | An abbreviation for <a>FloatingPointType</a> <a>HalfFP</a>
half :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>FloatFP</a>
float :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>DoubleFP</a>
double :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>FP128FP</a>
fp128 :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>X86_FP80FP</a>
x86_fp80 :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>PPC_FP128FP</a>
ppc_fp128 :: Type
instance GHC.Generics.Generic LLVM.AST.Type.Type
instance Data.Data.Data LLVM.AST.Type.Type
instance GHC.Show.Show LLVM.AST.Type.Type
instance GHC.Read.Read LLVM.AST.Type.Type
instance GHC.Classes.Ord LLVM.AST.Type.Type
instance GHC.Classes.Eq LLVM.AST.Type.Type
instance GHC.Generics.Generic LLVM.AST.Type.FloatingPointType
instance Data.Data.Data LLVM.AST.Type.FloatingPointType
instance GHC.Show.Show LLVM.AST.Type.FloatingPointType
instance GHC.Read.Read LLVM.AST.Type.FloatingPointType
instance GHC.Classes.Ord LLVM.AST.Type.FloatingPointType
instance GHC.Classes.Eq LLVM.AST.Type.FloatingPointType


-- | A representation of an LLVM inline assembly
module LLVM.AST.InlineAssembly

-- | the dialect of assembly used in an inline assembly string
--   <a>http://en.wikipedia.org/wiki/X86_assembly_language#Syntax</a>
data Dialect
ATTDialect :: Dialect
IntelDialect :: Dialect

-- | <a>http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a>
--   to be used through <a>CallableOperand</a> with a <a>Call</a>
--   instruction
data InlineAssembly
InlineAssembly :: Type -> ByteString -> ShortByteString -> Bool -> Bool -> Dialect -> InlineAssembly
[type'] :: InlineAssembly -> Type
[assembly] :: InlineAssembly -> ByteString
[constraints] :: InlineAssembly -> ShortByteString
[hasSideEffects] :: InlineAssembly -> Bool
[alignStack] :: InlineAssembly -> Bool
[dialect] :: InlineAssembly -> Dialect
instance GHC.Generics.Generic LLVM.AST.InlineAssembly.InlineAssembly
instance Data.Data.Data LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Show.Show LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Read.Read LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Classes.Eq LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Generics.Generic LLVM.AST.InlineAssembly.Dialect
instance Data.Data.Data LLVM.AST.InlineAssembly.Dialect
instance GHC.Show.Show LLVM.AST.InlineAssembly.Dialect
instance GHC.Read.Read LLVM.AST.InlineAssembly.Dialect
instance GHC.Classes.Eq LLVM.AST.InlineAssembly.Dialect


-- | A representation of LLVM constants
module LLVM.AST.Constant

-- | <a>http://llvm.org/docs/LangRef.html#constants</a>
--   
--   N.B. - <a>http://llvm.org/docs/LangRef.html#constant-expressions</a>
--   
--   Although constant expressions and instructions have many similarites,
--   there are important differences - so they're represented using
--   different types in this AST. At the cost of making it harder to move
--   an code back and forth between being constant and not, this approach
--   embeds more of the rules of what IR is legal into the Haskell types.
data Constant
Int :: Word32 -> Integer -> Constant
[integerBits] :: Constant -> Word32
[integerValue] :: Constant -> Integer
Float :: SomeFloat -> Constant
[floatValue] :: Constant -> SomeFloat
Null :: Type -> Constant
[constantType] :: Constant -> Type
AggregateZero :: Type -> Constant
[constantType] :: Constant -> Type
Struct :: Maybe Name -> Bool -> [Constant] -> Constant
[structName] :: Constant -> Maybe Name
[isPacked] :: Constant -> Bool
[memberValues] :: Constant -> [Constant]
Array :: Type -> [Constant] -> Constant
[memberType] :: Constant -> Type
[memberValues] :: Constant -> [Constant]
Vector :: [Constant] -> Constant
[memberValues] :: Constant -> [Constant]
Undef :: Type -> Constant
[constantType] :: Constant -> Type
BlockAddress :: Name -> Name -> Constant
[blockAddressFunction] :: Constant -> Name
[blockAddressBlock] :: Constant -> Name
GlobalReference :: Type -> Name -> Constant
TokenNone :: Constant
Add :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FAdd :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Sub :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FSub :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Mul :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FMul :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
UDiv :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
SDiv :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FDiv :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
URem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
SRem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FRem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Shl :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
LShr :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
AShr :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
And :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Or :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Xor :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
GetElementPtr :: Bool -> Constant -> [Constant] -> Constant
[inBounds] :: Constant -> Bool
[address] :: Constant -> Constant
[indices] :: Constant -> [Constant]
Trunc :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
ZExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
SExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPToUI :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPToSI :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
UIToFP :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
SIToFP :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPTrunc :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
PtrToInt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
IntToPtr :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
BitCast :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
AddrSpaceCast :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
ICmp :: IntegerPredicate -> Constant -> Constant -> Constant
[iPredicate] :: Constant -> IntegerPredicate
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FCmp :: FloatingPointPredicate -> Constant -> Constant -> Constant
[fpPredicate] :: Constant -> FloatingPointPredicate
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Select :: Constant -> Constant -> Constant -> Constant
[condition'] :: Constant -> Constant
[trueValue] :: Constant -> Constant
[falseValue] :: Constant -> Constant
ExtractElement :: Constant -> Constant -> Constant
[vector] :: Constant -> Constant
[index] :: Constant -> Constant
InsertElement :: Constant -> Constant -> Constant -> Constant
[vector] :: Constant -> Constant
[element] :: Constant -> Constant
[index] :: Constant -> Constant
ShuffleVector :: Constant -> Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
[mask] :: Constant -> Constant
ExtractValue :: Constant -> [Word32] -> Constant
[aggregate] :: Constant -> Constant
[indices'] :: Constant -> [Word32]
InsertValue :: Constant -> Constant -> [Word32] -> Constant
[aggregate] :: Constant -> Constant
[element] :: Constant -> Constant
[indices'] :: Constant -> [Word32]

-- | Since LLVM types don't include signedness, there's ambiguity in
--   interpreting an constant as an Integer. The LLVM assembly printer
--   prints integers as signed, but cheats for 1-bit integers and prints
--   them as <tt>true</tt> or <tt>false</tt>. That way it circuments the
--   otherwise awkward fact that a twos complement 1-bit number only has
--   the values -1 and 0.
signedIntegerValue :: Constant -> Integer

-- | This library's conversion from LLVM C++ objects will always produce
--   integer constants as unsigned, so this function in many cases is not
--   necessary. However, nothing's to keep stop direct construction of an
--   <a>Constant</a> with a negative <a>integerValue</a>. There's nothing
--   in principle wrong with such a value - it has perfectly good low order
--   bits like any integer, and will be used as such, likely producing the
--   intended result if lowered to C++. If, however one wishes to interpret
--   an <a>Constant</a> of unknown provenance as unsigned, then this
--   function will serve.
unsignedIntegerValue :: Constant -> Integer
instance GHC.Generics.Generic LLVM.AST.Constant.Constant
instance Data.Data.Data LLVM.AST.Constant.Constant
instance GHC.Show.Show LLVM.AST.Constant.Constant
instance GHC.Read.Read LLVM.AST.Constant.Constant
instance GHC.Classes.Ord LLVM.AST.Constant.Constant
instance GHC.Classes.Eq LLVM.AST.Constant.Constant


-- | A type to represent operands to LLVM <a>Instruction</a>s
module LLVM.AST.Operand

-- | <a>https://llvm.org/docs/LangRef.html#dilocalvariable</a>
data DILocalVariable
LocalVariable :: ShortByteString -> MDRef DIScope -> Maybe (MDRef DIFile) -> Word32 -> Maybe (MDRef DIType) -> [DIFlag] -> Word16 -> Word32 -> DILocalVariable
[$sel:name:LocalVariable] :: DILocalVariable -> ShortByteString
[$sel:scope:LocalVariable] :: DILocalVariable -> MDRef DIScope
[$sel:file:LocalVariable] :: DILocalVariable -> Maybe (MDRef DIFile)
[$sel:line:LocalVariable] :: DILocalVariable -> Word32
[$sel:type':LocalVariable] :: DILocalVariable -> Maybe (MDRef DIType)
[$sel:flags:LocalVariable] :: DILocalVariable -> [DIFlag]
[$sel:arg:LocalVariable] :: DILocalVariable -> Word16
[$sel:alignInBits:LocalVariable] :: DILocalVariable -> Word32

-- | <a>https://llvm.org/docs/LangRef.html#diglobalvariable</a>
data DIGlobalVariable
GlobalVariable :: ShortByteString -> Maybe (MDRef DIScope) -> Maybe (MDRef DIFile) -> Word32 -> Maybe (MDRef DIType) -> ShortByteString -> Bool -> Bool -> Maybe (MDRef DIDerivedType) -> [MDRef DITemplateParameter] -> Word32 -> DIGlobalVariable
[$sel:name:GlobalVariable] :: DIGlobalVariable -> ShortByteString
[$sel:scope:GlobalVariable] :: DIGlobalVariable -> Maybe (MDRef DIScope)
[$sel:file:GlobalVariable] :: DIGlobalVariable -> Maybe (MDRef DIFile)
[$sel:line:GlobalVariable] :: DIGlobalVariable -> Word32
[$sel:type':GlobalVariable] :: DIGlobalVariable -> Maybe (MDRef DIType)
[$sel:linkageName:GlobalVariable] :: DIGlobalVariable -> ShortByteString
[$sel:local:GlobalVariable] :: DIGlobalVariable -> Bool
[$sel:definition:GlobalVariable] :: DIGlobalVariable -> Bool
[$sel:staticDataMemberDeclaration:GlobalVariable] :: DIGlobalVariable -> Maybe (MDRef DIDerivedType)
[$sel:templateParams:GlobalVariable] :: DIGlobalVariable -> [MDRef DITemplateParameter]
[$sel:alignInBits:GlobalVariable] :: DIGlobalVariable -> Word32

-- | <a>https://llvm.org/doxygen/classllvm_1_1DIVariable.html</a>
data DIVariable
DIGlobalVariable :: DIGlobalVariable -> DIVariable
DILocalVariable :: DILocalVariable -> DIVariable

-- | <a>https://llvm.org/doxygen/classllvm_1_1DILexicalBlockBase.html</a>
data DILexicalBlockBase

-- | <a>https://llvm.org/docs/LangRef.html#dilexicalblock</a>
DILexicalBlock :: MDRef DILocalScope -> Maybe (MDRef DIFile) -> Word32 -> Word16 -> DILexicalBlockBase
[$sel:scope:DILexicalBlock] :: DILexicalBlockBase -> MDRef DILocalScope
[$sel:file:DILexicalBlock] :: DILexicalBlockBase -> Maybe (MDRef DIFile)
[$sel:line:DILexicalBlock] :: DILexicalBlockBase -> Word32
[$sel:column:DILexicalBlock] :: DILexicalBlockBase -> Word16

-- | <a>https://llvm.org/docs/LangRef.html#dilexicalblockfile</a>
DILexicalBlockFile :: MDRef DILocalScope -> Maybe (MDRef DIFile) -> Word32 -> DILexicalBlockBase
[$sel:scope:DILexicalBlock] :: DILexicalBlockBase -> MDRef DILocalScope
[$sel:file:DILexicalBlock] :: DILexicalBlockBase -> Maybe (MDRef DIFile)
[$sel:discriminator:DILexicalBlock] :: DILexicalBlockBase -> Word32

-- | <a>https://llvm.org/doxygen/classllvm_1_1DITemplateParameter.html</a>
data DITemplateParameter

-- | <a>https://llvm.org/docs/LangRef.html#ditemplatetypeparameter</a>
DITemplateTypeParameter :: ShortByteString -> Maybe (MDRef DIType) -> DITemplateParameter
[$sel:name:DITemplateTypeParameter] :: DITemplateParameter -> ShortByteString

-- | For DITemplateTypeParameter this field is required, for
--   DITemplateValueParameter it is optional.
[$sel:type':DITemplateTypeParameter] :: DITemplateParameter -> Maybe (MDRef DIType)

-- | <a>https://llvm.org/docs/LangRef.html#ditemplatevalueparameter</a>
DITemplateValueParameter :: ShortByteString -> Maybe (MDRef DIType) -> Maybe Metadata -> TemplateValueParameterTag -> DITemplateParameter
[$sel:name:DITemplateTypeParameter] :: DITemplateParameter -> ShortByteString

-- | For DITemplateTypeParameter this field is required, for
--   DITemplateValueParameter it is optional.
[$sel:type':DITemplateTypeParameter] :: DITemplateParameter -> Maybe (MDRef DIType)
[$sel:value:DITemplateTypeParameter] :: DITemplateParameter -> Maybe Metadata
[$sel:tag:DITemplateTypeParameter] :: DITemplateParameter -> TemplateValueParameterTag
data TemplateValueParameterTag
TemplateValueParameter :: TemplateValueParameterTag
GNUTemplateTemplateParam :: TemplateValueParameterTag
GNUTemplateParameterPack :: TemplateValueParameterTag
data Encoding
AddressEncoding :: Encoding
BooleanEncoding :: Encoding
FloatEncoding :: Encoding
SignedEncoding :: Encoding
SignedCharEncoding :: Encoding
UnsignedEncoding :: Encoding
UnsignedCharEncoding :: Encoding
UTFEncoding :: Encoding

-- | <a>https://llvm.org/docs/LangRef.html#dicompositetype</a>
data DICompositeType
DIArrayType :: [DISubrange] -> Maybe (MDRef DIType) -> Word64 -> Word32 -> [DIFlag] -> DICompositeType
[$sel:subscripts:DIArrayType] :: DICompositeType -> [DISubrange]
[$sel:elementTy:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)
[$sel:sizeInBits:DIArrayType] :: DICompositeType -> Word64
[$sel:alignInBits:DIArrayType] :: DICompositeType -> Word32
[$sel:flags:DIArrayType] :: DICompositeType -> [DIFlag]
DIClassType :: Maybe (MDRef DIScope) -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> [DIFlag] -> Maybe (MDRef DIType) -> [MDRef (Either DIDerivedType DISubprogram)] -> Maybe (MDRef DIType) -> [DITemplateParameter] -> ShortByteString -> Word64 -> Word32 -> DICompositeType
[$sel:scope:DIArrayType] :: DICompositeType -> Maybe (MDRef DIScope)
[$sel:name:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:file:DIArrayType] :: DICompositeType -> Maybe (MDRef DIFile)
[$sel:line:DIArrayType] :: DICompositeType -> Word32
[$sel:flags:DIArrayType] :: DICompositeType -> [DIFlag]
[$sel:derivedFrom:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)

-- | <a>DIType</a> with tag set to one of <a>Member</a>,
--   <a>Inheritance</a>, <a>Friend</a> or <a>DILocalScope</a> with
--   <a>DISubprogram</a> set to <a>True</a>.
[$sel:elements:DIArrayType] :: DICompositeType -> [MDRef (Either DIDerivedType DISubprogram)]
[$sel:vtableHolder:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)
[$sel:templateParams:DIArrayType] :: DICompositeType -> [DITemplateParameter]
[$sel:identifier:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:sizeInBits:DIArrayType] :: DICompositeType -> Word64
[$sel:alignInBits:DIArrayType] :: DICompositeType -> Word32
DIEnumerationType :: Maybe (MDRef DIScope) -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> [DIEnumerator] -> Maybe (MDRef DIType) -> ShortByteString -> Word64 -> Word32 -> DICompositeType
[$sel:scope:DIArrayType] :: DICompositeType -> Maybe (MDRef DIScope)
[$sel:name:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:file:DIArrayType] :: DICompositeType -> Maybe (MDRef DIFile)
[$sel:line:DIArrayType] :: DICompositeType -> Word32
[$sel:values:DIArrayType] :: DICompositeType -> [DIEnumerator]
[$sel:baseType:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)
[$sel:identifier:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:sizeInBits:DIArrayType] :: DICompositeType -> Word64
[$sel:alignInBits:DIArrayType] :: DICompositeType -> Word32
DIStructureType :: Maybe (MDRef DIScope) -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> [DIFlag] -> Maybe (MDRef DIType) -> [MDRef (Either DIDerivedType DISubprogram)] -> Word16 -> Maybe (MDRef DIType) -> ShortByteString -> Word64 -> Word32 -> DICompositeType
[$sel:scope:DIArrayType] :: DICompositeType -> Maybe (MDRef DIScope)
[$sel:name:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:file:DIArrayType] :: DICompositeType -> Maybe (MDRef DIFile)
[$sel:line:DIArrayType] :: DICompositeType -> Word32
[$sel:flags:DIArrayType] :: DICompositeType -> [DIFlag]
[$sel:derivedFrom:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)

-- | <a>DIType</a> with tag set to one of <a>Member</a>,
--   <a>Inheritance</a>, <a>Friend</a> or <a>DILocalScope</a> with
--   <a>DISubprogram</a> set to <a>True</a>.
[$sel:elements:DIArrayType] :: DICompositeType -> [MDRef (Either DIDerivedType DISubprogram)]
[$sel:runtimeLang:DIArrayType] :: DICompositeType -> Word16
[$sel:vtableHolder:DIArrayType] :: DICompositeType -> Maybe (MDRef DIType)
[$sel:identifier:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:sizeInBits:DIArrayType] :: DICompositeType -> Word64
[$sel:alignInBits:DIArrayType] :: DICompositeType -> Word32
DIUnionType :: Maybe (MDRef DIScope) -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> [DIFlag] -> [MDRef (Either DIDerivedType DISubprogram)] -> Word16 -> ShortByteString -> Word64 -> Word32 -> DICompositeType
[$sel:scope:DIArrayType] :: DICompositeType -> Maybe (MDRef DIScope)
[$sel:name:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:file:DIArrayType] :: DICompositeType -> Maybe (MDRef DIFile)
[$sel:line:DIArrayType] :: DICompositeType -> Word32
[$sel:flags:DIArrayType] :: DICompositeType -> [DIFlag]

-- | <a>DIType</a> with tag set to one of <a>Member</a>,
--   <a>Inheritance</a>, <a>Friend</a> or <a>DILocalScope</a> with
--   <a>DISubprogram</a> set to <a>True</a>.
[$sel:elements:DIArrayType] :: DICompositeType -> [MDRef (Either DIDerivedType DISubprogram)]
[$sel:runtimeLang:DIArrayType] :: DICompositeType -> Word16
[$sel:identifier:DIArrayType] :: DICompositeType -> ShortByteString
[$sel:sizeInBits:DIArrayType] :: DICompositeType -> Word64
[$sel:alignInBits:DIArrayType] :: DICompositeType -> Word32

-- | <a>https://llvm.org/docs/LangRef.html#diderivedtype</a>
data DIDerivedType
DerivedType :: DerivedTypeTag -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> Maybe (MDRef DIScope) -> Maybe (MDRef DIType) -> Word64 -> Word32 -> Word64 -> Maybe Word32 -> [DIFlag] -> DIDerivedType
[$sel:tag:DerivedType] :: DIDerivedType -> DerivedTypeTag
[$sel:name:DerivedType] :: DIDerivedType -> ShortByteString
[$sel:file:DerivedType] :: DIDerivedType -> Maybe (MDRef DIFile)
[$sel:line:DerivedType] :: DIDerivedType -> Word32
[$sel:scope:DerivedType] :: DIDerivedType -> Maybe (MDRef DIScope)

-- | This can be <a>Nothing</a> to represent <tt>void *</tt>
[$sel:baseType:DerivedType] :: DIDerivedType -> Maybe (MDRef DIType)
[$sel:sizeInBits:DerivedType] :: DIDerivedType -> Word64
[$sel:alignInBits:DerivedType] :: DIDerivedType -> Word32
[$sel:offsetInBits:DerivedType] :: DIDerivedType -> Word64
[$sel:addressSpace:DerivedType] :: DIDerivedType -> Maybe Word32
[$sel:flags:DerivedType] :: DIDerivedType -> [DIFlag]
data DerivedTypeTag
Typedef :: DerivedTypeTag
PointerType :: DerivedTypeTag
PtrToMemberType :: DerivedTypeTag
ReferenceType :: DerivedTypeTag
RValueReferenceType :: DerivedTypeTag
ConstType :: DerivedTypeTag
VolatileType :: DerivedTypeTag
RestrictType :: DerivedTypeTag
AtomicType :: DerivedTypeTag
Member :: DerivedTypeTag
Inheritance :: DerivedTypeTag
Friend :: DerivedTypeTag

-- | <a>https://llvm.org/docs/LangRef.html#disubroutinetype</a>
data DISubroutineType
SubroutineType :: [DIFlag] -> Word8 -> [Maybe (MDRef DIType)] -> DISubroutineType
[$sel:flags:SubroutineType] :: DISubroutineType -> [DIFlag]
[$sel:cc:SubroutineType] :: DISubroutineType -> Word8

-- | The first element is the return type, the following are the operand
--   types. <a>Nothing</a> corresponds to <tt>void</tt>.
[$sel:typeArray:SubroutineType] :: DISubroutineType -> [Maybe (MDRef DIType)]

-- | <a>https://llvm.org/docs/LangRef.html#dibasictype</a>
data DIBasicType
BasicType :: ShortByteString -> Word64 -> Word32 -> Maybe Encoding -> BasicTypeTag -> [DIFlag] -> DIBasicType
[$sel:name:BasicType] :: DIBasicType -> ShortByteString
[$sel:sizeInBits:BasicType] :: DIBasicType -> Word64
[$sel:alignInBits:BasicType] :: DIBasicType -> Word32
[$sel:encoding:BasicType] :: DIBasicType -> Maybe Encoding
[$sel:tag:BasicType] :: DIBasicType -> BasicTypeTag
[$sel:flags:BasicType] :: DIBasicType -> [DIFlag]
data DIType
DIBasicType :: DIBasicType -> DIType
DICompositeType :: DICompositeType -> DIType
DIDerivedType :: DIDerivedType -> DIType
DISubroutineType :: DISubroutineType -> DIType
data BasicTypeTag
BaseType :: BasicTypeTag
UnspecifiedType :: BasicTypeTag
data Virtuality
NoVirtuality :: Virtuality
Virtual :: Virtuality
PureVirtual :: Virtuality

-- | <a>https://llvm.org/docs/LangRef.html#disubprogram</a>
data DISubprogram
Subprogram :: Maybe (MDRef DIScope) -> ShortByteString -> ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> Maybe (MDRef DISubroutineType) -> Bool -> Bool -> Word32 -> Maybe (MDRef DIType) -> Virtuality -> Word32 -> Int32 -> [DIFlag] -> Bool -> Maybe (MDRef DICompileUnit) -> [MDRef DITemplateParameter] -> Maybe (MDRef DISubprogram) -> [MDRef DILocalVariable] -> [MDRef DIType] -> DISubprogram
[$sel:scope:Subprogram] :: DISubprogram -> Maybe (MDRef DIScope)
[$sel:name:Subprogram] :: DISubprogram -> ShortByteString
[$sel:linkageName:Subprogram] :: DISubprogram -> ShortByteString
[$sel:file:Subprogram] :: DISubprogram -> Maybe (MDRef DIFile)
[$sel:line:Subprogram] :: DISubprogram -> Word32
[$sel:type':Subprogram] :: DISubprogram -> Maybe (MDRef DISubroutineType)
[$sel:localToUnit:Subprogram] :: DISubprogram -> Bool
[$sel:definition:Subprogram] :: DISubprogram -> Bool
[$sel:scopeLine:Subprogram] :: DISubprogram -> Word32
[$sel:containingType:Subprogram] :: DISubprogram -> Maybe (MDRef DIType)
[$sel:virtuality:Subprogram] :: DISubprogram -> Virtuality
[$sel:virtualityIndex:Subprogram] :: DISubprogram -> Word32
[$sel:thisAdjustment:Subprogram] :: DISubprogram -> Int32
[$sel:flags:Subprogram] :: DISubprogram -> [DIFlag]
[$sel:optimized:Subprogram] :: DISubprogram -> Bool
[$sel:unit:Subprogram] :: DISubprogram -> Maybe (MDRef DICompileUnit)
[$sel:templateParams:Subprogram] :: DISubprogram -> [MDRef DITemplateParameter]
[$sel:declaration:Subprogram] :: DISubprogram -> Maybe (MDRef DISubprogram)
[$sel:retainedNodes:Subprogram] :: DISubprogram -> [MDRef DILocalVariable]
[$sel:thrownTypes:Subprogram] :: DISubprogram -> [MDRef DIType]

-- | <a>https://llvm.org/doxygen/classllvm_1_1DILocalScope.html</a>
data DILocalScope
DILexicalBlockBase :: DILexicalBlockBase -> DILocalScope
DISubprogram :: DISubprogram -> DILocalScope
data ChecksumKind
MD5 :: ChecksumKind
SHA1 :: ChecksumKind
data ChecksumInfo
ChecksumInfo :: ChecksumKind -> ShortByteString -> ChecksumInfo
[$sel:checksumKind:ChecksumInfo] :: ChecksumInfo -> ChecksumKind
[$sel:checksumValue:ChecksumInfo] :: ChecksumInfo -> ShortByteString

-- | <a>https://llvm.org/docs/LangRef.html#difile</a>
data DIFile
File :: ShortByteString -> ShortByteString -> Maybe ChecksumInfo -> DIFile
[$sel:filename:File] :: DIFile -> ShortByteString
[$sel:directory:File] :: DIFile -> ShortByteString
[$sel:checksum:File] :: DIFile -> Maybe ChecksumInfo

-- | <a>https://llvm.org/docs/LangRef.html#dicompileunit</a>
data DICompileUnit
CompileUnit :: Word32 -> MDRef DIFile -> ShortByteString -> Bool -> ShortByteString -> Word32 -> ShortByteString -> DebugEmissionKind -> [MDRef DICompositeType] -> [MDRef (Either DIType DISubprogram)] -> [MDRef DIGlobalVariableExpression] -> [MDRef DIImportedEntity] -> [MDRef DIMacroNode] -> Word64 -> Bool -> Bool -> DebugNameTableKind -> Bool -> DICompileUnit
[$sel:language:CompileUnit] :: DICompileUnit -> Word32
[$sel:file:CompileUnit] :: DICompileUnit -> MDRef DIFile
[$sel:producer:CompileUnit] :: DICompileUnit -> ShortByteString
[$sel:optimized:CompileUnit] :: DICompileUnit -> Bool
[$sel:flags:CompileUnit] :: DICompileUnit -> ShortByteString
[$sel:runtimeVersion:CompileUnit] :: DICompileUnit -> Word32
[$sel:splitDebugFileName:CompileUnit] :: DICompileUnit -> ShortByteString
[$sel:emissionKind:CompileUnit] :: DICompileUnit -> DebugEmissionKind

-- | Only enum types are allowed here
[$sel:enums:CompileUnit] :: DICompileUnit -> [MDRef DICompositeType]
[$sel:retainedTypes:CompileUnit] :: DICompileUnit -> [MDRef (Either DIType DISubprogram)]
[$sel:globals:CompileUnit] :: DICompileUnit -> [MDRef DIGlobalVariableExpression]
[$sel:imports:CompileUnit] :: DICompileUnit -> [MDRef DIImportedEntity]
[$sel:macros:CompileUnit] :: DICompileUnit -> [MDRef DIMacroNode]
[$sel:dWOId:CompileUnit] :: DICompileUnit -> Word64
[$sel:splitDebugInlining:CompileUnit] :: DICompileUnit -> Bool
[$sel:debugInfoForProfiling:CompileUnit] :: DICompileUnit -> Bool
[$sel:nameTableKind:CompileUnit] :: DICompileUnit -> DebugNameTableKind
[$sel:debugBaseAddress:CompileUnit] :: DICompileUnit -> Bool
data DebugNameTableKind
NameTableKindDefault :: DebugNameTableKind
NameTableKindGNU :: DebugNameTableKind
NameTableKindNone :: DebugNameTableKind
data DebugEmissionKind
NoDebug :: DebugEmissionKind
FullDebug :: DebugEmissionKind
LineTablesOnly :: DebugEmissionKind
data DINamespace
Namespace :: ShortByteString -> Maybe (MDRef DIScope) -> Bool -> DINamespace
[$sel:name:Namespace] :: DINamespace -> ShortByteString
[$sel:scope:Namespace] :: DINamespace -> Maybe (MDRef DIScope)
[$sel:exportSymbols:Namespace] :: DINamespace -> Bool
data DIModule
Module :: Maybe (MDRef DIScope) -> ShortByteString -> ShortByteString -> ShortByteString -> ShortByteString -> DIModule
[$sel:scope:Module] :: DIModule -> Maybe (MDRef DIScope)
[$sel:name:Module] :: DIModule -> ShortByteString
[$sel:configurationMacros:Module] :: DIModule -> ShortByteString
[$sel:includePath:Module] :: DIModule -> ShortByteString
[$sel:isysRoot:Module] :: DIModule -> ShortByteString

-- | <a>https://llvm.org/doxygen/classllvm_1_1DIScope.html</a>
data DIScope
DICompileUnit :: DICompileUnit -> DIScope
DIFile :: DIFile -> DIScope
DILocalScope :: DILocalScope -> DIScope
DIModule :: DIModule -> DIScope
DINamespace :: DINamespace -> DIScope
DIType :: DIType -> DIScope
data DICount
DICountConstant :: Int64 -> DICount
DICountVariable :: MDRef DIVariable -> DICount

-- | <a>https://llvm.org/docs/LangRef.html#disubrange</a>
data DISubrange
Subrange :: DICount -> Int64 -> DISubrange
[$sel:count:Subrange] :: DISubrange -> DICount
[$sel:lowerBound:Subrange] :: DISubrange -> Int64

-- | <a>https://llvm.org/docs/LangRef.html#dienumerator</a>
data DIEnumerator
Enumerator :: Int64 -> Bool -> ShortByteString -> DIEnumerator
[$sel:value:Enumerator] :: DIEnumerator -> Int64
[$sel:isUnsigned:Enumerator] :: DIEnumerator -> Bool
[$sel:name:Enumerator] :: DIEnumerator -> ShortByteString

-- | <a>https://llvm.org/doxygen/classllvm_1_1DIImportedEntity.html</a>
data DIImportedEntity
ImportedEntity :: ImportedEntityTag -> ShortByteString -> MDRef DIScope -> Maybe (MDRef DINode) -> Maybe (MDRef DIFile) -> Word32 -> DIImportedEntity
[$sel:tag:ImportedEntity] :: DIImportedEntity -> ImportedEntityTag
[$sel:name:ImportedEntity] :: DIImportedEntity -> ShortByteString
[$sel:scope:ImportedEntity] :: DIImportedEntity -> MDRef DIScope
[$sel:entity:ImportedEntity] :: DIImportedEntity -> Maybe (MDRef DINode)
[$sel:file:ImportedEntity] :: DIImportedEntity -> Maybe (MDRef DIFile)
[$sel:line:ImportedEntity] :: DIImportedEntity -> Word32
data ImportedEntityTag
ImportedModule :: ImportedEntityTag
ImportedDeclaration :: ImportedEntityTag

-- | <a>https://llvm.org/doxygen/classllvm_1_1DIObjCProperty.html</a>
data DIObjCProperty
ObjCProperty :: ShortByteString -> Maybe (MDRef DIFile) -> Word32 -> ShortByteString -> ShortByteString -> Word32 -> Maybe (MDRef DIType) -> DIObjCProperty
[$sel:name:ObjCProperty] :: DIObjCProperty -> ShortByteString
[$sel:file:ObjCProperty] :: DIObjCProperty -> Maybe (MDRef DIFile)
[$sel:line:ObjCProperty] :: DIObjCProperty -> Word32
[$sel:getterName:ObjCProperty] :: DIObjCProperty -> ShortByteString
[$sel:setterName:ObjCProperty] :: DIObjCProperty -> ShortByteString
[$sel:attributes:ObjCProperty] :: DIObjCProperty -> Word32
[$sel:type':ObjCProperty] :: DIObjCProperty -> Maybe (MDRef DIType)

-- | <a>https://llvm.org/doxygen/classllvm_1_1DINode.html</a>
data DINode
DIEnumerator :: DIEnumerator -> DINode
DIImportedEntity :: DIImportedEntity -> DINode
DIObjCProperty :: DIObjCProperty -> DINode
DIScope :: DIScope -> DINode
DISubrange :: DISubrange -> DINode
DITemplateParameter :: DITemplateParameter -> DINode
DIVariable :: DIVariable -> DINode

-- | <a>https://llvm.org/doxygen/classllvm_1_1DIMacroNode.html</a>
data DIMacroNode

-- | <a>https://llvm.org/docs/LangRef.html#dimacro</a>
DIMacro :: DIMacroInfo -> Word32 -> ShortByteString -> ShortByteString -> DIMacroNode
[$sel:info:DIMacro] :: DIMacroNode -> DIMacroInfo
[$sel:line:DIMacro] :: DIMacroNode -> Word32
[$sel:name:DIMacro] :: DIMacroNode -> ShortByteString
[$sel:value:DIMacro] :: DIMacroNode -> ShortByteString

-- | <a>https://llvm.org/docs/LangRef.html#dimacrofile</a>
DIMacroFile :: Word32 -> MDRef DIFile -> [MDRef DIMacroNode] -> DIMacroNode
[$sel:line:DIMacro] :: DIMacroNode -> Word32
[$sel:file:DIMacro] :: DIMacroNode -> MDRef DIFile
[$sel:elements:DIMacro] :: DIMacroNode -> [MDRef DIMacroNode]
data DIMacroInfo
Define :: DIMacroInfo
Undef :: DIMacroInfo
data DIFlag
Accessibility :: DIAccessibility -> DIFlag
FwdDecl :: DIFlag
AppleBlock :: DIFlag
BlockByrefStruct :: DIFlag
VirtualFlag :: DIFlag
Artificial :: DIFlag
Explicit :: DIFlag
Prototyped :: DIFlag
ObjcClassComplete :: DIFlag
ObjectPointer :: DIFlag
Vector :: DIFlag
StaticMember :: DIFlag
LValueReference :: DIFlag
RValueReference :: DIFlag
InheritanceFlag :: DIInheritance -> DIFlag
IntroducedVirtual :: DIFlag
BitField :: DIFlag
NoReturn :: DIFlag
MainSubprogram :: DIFlag

-- | Inheritance flag
data DIInheritance
SingleInheritance :: DIInheritance
MultipleInheritance :: DIInheritance
VirtualInheritance :: DIInheritance

-- | Accessiblity flag
data DIAccessibility
Private :: DIAccessibility
Protected :: DIAccessibility
Public :: DIAccessibility

-- | A pair of a <a>DIVariable</a> and a <a>MDNode</a>.
--   
--   This is used in the <tt>cuGlobals</tt> fields of <a>DIScope</a>.
data DIGlobalVariableExpression
GlobalVariableExpression :: MDRef DIGlobalVariable -> MDRef DIExpression -> DIGlobalVariableExpression
[$sel:var:GlobalVariableExpression] :: DIGlobalVariableExpression -> MDRef DIGlobalVariable
[$sel:expr:GlobalVariableExpression] :: DIGlobalVariableExpression -> MDRef DIExpression

-- | <a>https://llvm.org/docs/LangRef.html#diexpression</a>
data DIExpression
Expression :: [DWOp] -> DIExpression
[$sel:operands:Expression] :: DIExpression -> [DWOp]
data DILocation
Location :: Word32 -> Word16 -> MDRef DILocalScope -> DILocation
[$sel:line:Location] :: DILocation -> Word32
[$sel:column:Location] :: DILocation -> Word16
[$sel:scope:Location] :: DILocation -> MDRef DILocalScope

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data MDNode

-- | Nothing represents <a>null</a>
MDTuple :: [Maybe Metadata] -> MDNode
DIExpression :: DIExpression -> MDNode
DIGlobalVariableExpression :: DIGlobalVariableExpression -> MDNode
DILocation :: DILocation -> MDNode
DIMacroNode :: DIMacroNode -> MDNode
DINode :: DINode -> MDNode

-- | <a>https://llvm.org/docs/LangRef.html#diexpression</a>
data DWOp

-- | Must appear at the end
DwOpFragment :: DWOpFragment -> DWOp

-- | Must be the last one or followed by a DW_OP_LLVM_Fragment
DW_OP_StackValue :: DWOp
DW_OP_Swap :: DWOp
DW_OP_ConstU :: Word64 -> DWOp
DW_OP_Lit0 :: DWOp
DW_OP_PlusUConst :: Word64 -> DWOp
DW_OP_Plus :: DWOp
DW_OP_Minus :: DWOp
DW_OP_Mul :: DWOp
DW_OP_Div :: DWOp
DW_OP_Mod :: DWOp
DW_OP_Not :: DWOp
DW_OP_Or :: DWOp
DW_OP_Xor :: DWOp
DW_OP_And :: DWOp
DW_OP_Shr :: DWOp
DW_OP_Shra :: DWOp
DW_OP_Shl :: DWOp
DW_OP_Dup :: DWOp
DW_OP_Deref :: DWOp
DW_OP_XDeref :: DWOp
data DWOpFragment
DW_OP_LLVM_Fragment :: Word64 -> Word64 -> DWOpFragment
[$sel:offset:DW_OP_LLVM_Fragment] :: DWOpFragment -> Word64
[$sel:size:DW_OP_LLVM_Fragment] :: DWOpFragment -> Word64

-- | <a>MDRef</a> can either represent a reference to some piece of
--   metadata or the metadata itself.
--   
--   This is mainly useful for encoding cyclic metadata. Note that LLVM
--   represents inline and non-inline nodes identically, so roundtripping
--   the Haskell AST does not preserve whether a node was inline or not.
data MDRef a
MDRef :: MetadataNodeID -> MDRef a
MDInline :: a -> MDRef a

-- | A <a>MetadataNodeID</a> is a number for identifying a metadata node.
--   Note this is different from "named metadata", which are represented
--   with <a>NamedMetadataDefinition</a>.
newtype MetadataNodeID
MetadataNodeID :: Word -> MetadataNodeID

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDString :: ShortByteString -> Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDNode :: MDRef MDNode -> Metadata

-- | 
--   <a>http://llvm.org/docs/doxygen/html/classllvm_1_1ValueAsMetadata.html</a>
MDValue :: Operand -> Metadata

-- | The <a>Call</a> instruction is special: the callee can be inline
--   assembly
type CallableOperand = Either InlineAssembly Operand

-- | An <a>Operand</a> is roughly that which is an argument to an
--   <a>Instruction</a>
data Operand

-- | %foo
LocalReference :: Type -> Name -> Operand

-- | <a>Constant</a>s include <a>GlobalReference</a>, for @foo
ConstantOperand :: Constant -> Operand
MetadataOperand :: Metadata -> Operand
instance GHC.Generics.Generic LLVM.AST.Operand.Operand
instance Data.Data.Data LLVM.AST.Operand.Operand
instance GHC.Show.Show LLVM.AST.Operand.Operand
instance GHC.Read.Read LLVM.AST.Operand.Operand
instance GHC.Classes.Ord LLVM.AST.Operand.Operand
instance GHC.Classes.Eq LLVM.AST.Operand.Operand
instance GHC.Generics.Generic LLVM.AST.Operand.DILocation
instance Data.Data.Data LLVM.AST.Operand.DILocation
instance GHC.Show.Show LLVM.AST.Operand.DILocation
instance GHC.Read.Read LLVM.AST.Operand.DILocation
instance GHC.Classes.Ord LLVM.AST.Operand.DILocation
instance GHC.Classes.Eq LLVM.AST.Operand.DILocation
instance GHC.Generics.Generic LLVM.AST.Operand.DIObjCProperty
instance Data.Data.Data LLVM.AST.Operand.DIObjCProperty
instance GHC.Show.Show LLVM.AST.Operand.DIObjCProperty
instance GHC.Read.Read LLVM.AST.Operand.DIObjCProperty
instance GHC.Classes.Ord LLVM.AST.Operand.DIObjCProperty
instance GHC.Classes.Eq LLVM.AST.Operand.DIObjCProperty
instance GHC.Generics.Generic LLVM.AST.Operand.DICount
instance Data.Data.Data LLVM.AST.Operand.DICount
instance GHC.Show.Show LLVM.AST.Operand.DICount
instance GHC.Read.Read LLVM.AST.Operand.DICount
instance GHC.Classes.Ord LLVM.AST.Operand.DICount
instance GHC.Classes.Eq LLVM.AST.Operand.DICount
instance GHC.Generics.Generic LLVM.AST.Operand.DISubrange
instance Data.Data.Data LLVM.AST.Operand.DISubrange
instance GHC.Show.Show LLVM.AST.Operand.DISubrange
instance GHC.Read.Read LLVM.AST.Operand.DISubrange
instance GHC.Classes.Ord LLVM.AST.Operand.DISubrange
instance GHC.Classes.Eq LLVM.AST.Operand.DISubrange
instance GHC.Generics.Generic LLVM.AST.Operand.DIModule
instance Data.Data.Data LLVM.AST.Operand.DIModule
instance GHC.Show.Show LLVM.AST.Operand.DIModule
instance GHC.Read.Read LLVM.AST.Operand.DIModule
instance GHC.Classes.Ord LLVM.AST.Operand.DIModule
instance GHC.Classes.Eq LLVM.AST.Operand.DIModule
instance GHC.Generics.Generic LLVM.AST.Operand.DINamespace
instance Data.Data.Data LLVM.AST.Operand.DINamespace
instance GHC.Show.Show LLVM.AST.Operand.DINamespace
instance GHC.Read.Read LLVM.AST.Operand.DINamespace
instance GHC.Classes.Ord LLVM.AST.Operand.DINamespace
instance GHC.Classes.Eq LLVM.AST.Operand.DINamespace
instance GHC.Generics.Generic LLVM.AST.Operand.DIGlobalVariableExpression
instance Data.Data.Data LLVM.AST.Operand.DIGlobalVariableExpression
instance GHC.Show.Show LLVM.AST.Operand.DIGlobalVariableExpression
instance GHC.Read.Read LLVM.AST.Operand.DIGlobalVariableExpression
instance GHC.Classes.Ord LLVM.AST.Operand.DIGlobalVariableExpression
instance GHC.Classes.Eq LLVM.AST.Operand.DIGlobalVariableExpression
instance GHC.Generics.Generic LLVM.AST.Operand.DIImportedEntity
instance Data.Data.Data LLVM.AST.Operand.DIImportedEntity
instance GHC.Show.Show LLVM.AST.Operand.DIImportedEntity
instance GHC.Read.Read LLVM.AST.Operand.DIImportedEntity
instance GHC.Classes.Ord LLVM.AST.Operand.DIImportedEntity
instance GHC.Classes.Eq LLVM.AST.Operand.DIImportedEntity
instance GHC.Generics.Generic LLVM.AST.Operand.DICompileUnit
instance Data.Data.Data LLVM.AST.Operand.DICompileUnit
instance GHC.Show.Show LLVM.AST.Operand.DICompileUnit
instance GHC.Read.Read LLVM.AST.Operand.DICompileUnit
instance GHC.Classes.Ord LLVM.AST.Operand.DICompileUnit
instance GHC.Classes.Eq LLVM.AST.Operand.DICompileUnit
instance GHC.Generics.Generic LLVM.AST.Operand.DISubroutineType
instance Data.Data.Data LLVM.AST.Operand.DISubroutineType
instance GHC.Show.Show LLVM.AST.Operand.DISubroutineType
instance GHC.Read.Read LLVM.AST.Operand.DISubroutineType
instance GHC.Classes.Ord LLVM.AST.Operand.DISubroutineType
instance GHC.Classes.Eq LLVM.AST.Operand.DISubroutineType
instance GHC.Generics.Generic LLVM.AST.Operand.DISubprogram
instance Data.Data.Data LLVM.AST.Operand.DISubprogram
instance GHC.Show.Show LLVM.AST.Operand.DISubprogram
instance GHC.Read.Read LLVM.AST.Operand.DISubprogram
instance GHC.Classes.Ord LLVM.AST.Operand.DISubprogram
instance GHC.Classes.Eq LLVM.AST.Operand.DISubprogram
instance GHC.Generics.Generic LLVM.AST.Operand.DILexicalBlockBase
instance Data.Data.Data LLVM.AST.Operand.DILexicalBlockBase
instance GHC.Show.Show LLVM.AST.Operand.DILexicalBlockBase
instance GHC.Read.Read LLVM.AST.Operand.DILexicalBlockBase
instance GHC.Classes.Ord LLVM.AST.Operand.DILexicalBlockBase
instance GHC.Classes.Eq LLVM.AST.Operand.DILexicalBlockBase
instance GHC.Generics.Generic LLVM.AST.Operand.DILocalScope
instance Data.Data.Data LLVM.AST.Operand.DILocalScope
instance GHC.Show.Show LLVM.AST.Operand.DILocalScope
instance GHC.Read.Read LLVM.AST.Operand.DILocalScope
instance GHC.Classes.Ord LLVM.AST.Operand.DILocalScope
instance GHC.Classes.Eq LLVM.AST.Operand.DILocalScope
instance GHC.Generics.Generic LLVM.AST.Operand.DIScope
instance Data.Data.Data LLVM.AST.Operand.DIScope
instance GHC.Show.Show LLVM.AST.Operand.DIScope
instance GHC.Read.Read LLVM.AST.Operand.DIScope
instance GHC.Classes.Ord LLVM.AST.Operand.DIScope
instance GHC.Classes.Eq LLVM.AST.Operand.DIScope
instance GHC.Generics.Generic LLVM.AST.Operand.DIDerivedType
instance Data.Data.Data LLVM.AST.Operand.DIDerivedType
instance GHC.Show.Show LLVM.AST.Operand.DIDerivedType
instance GHC.Read.Read LLVM.AST.Operand.DIDerivedType
instance GHC.Classes.Ord LLVM.AST.Operand.DIDerivedType
instance GHC.Classes.Eq LLVM.AST.Operand.DIDerivedType
instance GHC.Generics.Generic LLVM.AST.Operand.DIGlobalVariable
instance Data.Data.Data LLVM.AST.Operand.DIGlobalVariable
instance GHC.Show.Show LLVM.AST.Operand.DIGlobalVariable
instance GHC.Read.Read LLVM.AST.Operand.DIGlobalVariable
instance GHC.Classes.Ord LLVM.AST.Operand.DIGlobalVariable
instance GHC.Classes.Eq LLVM.AST.Operand.DIGlobalVariable
instance GHC.Generics.Generic LLVM.AST.Operand.DIVariable
instance Data.Data.Data LLVM.AST.Operand.DIVariable
instance GHC.Show.Show LLVM.AST.Operand.DIVariable
instance GHC.Read.Read LLVM.AST.Operand.DIVariable
instance GHC.Classes.Ord LLVM.AST.Operand.DIVariable
instance GHC.Classes.Eq LLVM.AST.Operand.DIVariable
instance GHC.Generics.Generic LLVM.AST.Operand.DINode
instance Data.Data.Data LLVM.AST.Operand.DINode
instance GHC.Show.Show LLVM.AST.Operand.DINode
instance GHC.Read.Read LLVM.AST.Operand.DINode
instance GHC.Classes.Ord LLVM.AST.Operand.DINode
instance GHC.Classes.Eq LLVM.AST.Operand.DINode
instance GHC.Generics.Generic LLVM.AST.Operand.MDNode
instance Data.Data.Data LLVM.AST.Operand.MDNode
instance GHC.Show.Show LLVM.AST.Operand.MDNode
instance GHC.Read.Read LLVM.AST.Operand.MDNode
instance GHC.Classes.Ord LLVM.AST.Operand.MDNode
instance GHC.Classes.Eq LLVM.AST.Operand.MDNode
instance GHC.Generics.Generic LLVM.AST.Operand.Metadata
instance Data.Data.Data LLVM.AST.Operand.Metadata
instance GHC.Show.Show LLVM.AST.Operand.Metadata
instance GHC.Read.Read LLVM.AST.Operand.Metadata
instance GHC.Classes.Ord LLVM.AST.Operand.Metadata
instance GHC.Classes.Eq LLVM.AST.Operand.Metadata
instance GHC.Generics.Generic LLVM.AST.Operand.DITemplateParameter
instance Data.Data.Data LLVM.AST.Operand.DITemplateParameter
instance GHC.Show.Show LLVM.AST.Operand.DITemplateParameter
instance GHC.Read.Read LLVM.AST.Operand.DITemplateParameter
instance GHC.Classes.Ord LLVM.AST.Operand.DITemplateParameter
instance GHC.Classes.Eq LLVM.AST.Operand.DITemplateParameter
instance GHC.Generics.Generic LLVM.AST.Operand.DICompositeType
instance Data.Data.Data LLVM.AST.Operand.DICompositeType
instance GHC.Show.Show LLVM.AST.Operand.DICompositeType
instance GHC.Read.Read LLVM.AST.Operand.DICompositeType
instance GHC.Classes.Ord LLVM.AST.Operand.DICompositeType
instance GHC.Classes.Eq LLVM.AST.Operand.DICompositeType
instance GHC.Generics.Generic LLVM.AST.Operand.DIType
instance Data.Data.Data LLVM.AST.Operand.DIType
instance GHC.Show.Show LLVM.AST.Operand.DIType
instance GHC.Read.Read LLVM.AST.Operand.DIType
instance GHC.Classes.Ord LLVM.AST.Operand.DIType
instance GHC.Classes.Eq LLVM.AST.Operand.DIType
instance GHC.Generics.Generic LLVM.AST.Operand.DILocalVariable
instance Data.Data.Data LLVM.AST.Operand.DILocalVariable
instance GHC.Show.Show LLVM.AST.Operand.DILocalVariable
instance GHC.Read.Read LLVM.AST.Operand.DILocalVariable
instance GHC.Classes.Ord LLVM.AST.Operand.DILocalVariable
instance GHC.Classes.Eq LLVM.AST.Operand.DILocalVariable
instance GHC.Generics.Generic LLVM.AST.Operand.TemplateValueParameterTag
instance Data.Data.Data LLVM.AST.Operand.TemplateValueParameterTag
instance GHC.Show.Show LLVM.AST.Operand.TemplateValueParameterTag
instance GHC.Read.Read LLVM.AST.Operand.TemplateValueParameterTag
instance GHC.Classes.Ord LLVM.AST.Operand.TemplateValueParameterTag
instance GHC.Classes.Eq LLVM.AST.Operand.TemplateValueParameterTag
instance GHC.Generics.Generic LLVM.AST.Operand.DIBasicType
instance Data.Data.Data LLVM.AST.Operand.DIBasicType
instance GHC.Show.Show LLVM.AST.Operand.DIBasicType
instance GHC.Read.Read LLVM.AST.Operand.DIBasicType
instance GHC.Classes.Ord LLVM.AST.Operand.DIBasicType
instance GHC.Classes.Eq LLVM.AST.Operand.DIBasicType
instance GHC.Generics.Generic LLVM.AST.Operand.Encoding
instance Data.Data.Data LLVM.AST.Operand.Encoding
instance GHC.Show.Show LLVM.AST.Operand.Encoding
instance GHC.Read.Read LLVM.AST.Operand.Encoding
instance GHC.Classes.Ord LLVM.AST.Operand.Encoding
instance GHC.Classes.Eq LLVM.AST.Operand.Encoding
instance GHC.Generics.Generic LLVM.AST.Operand.DerivedTypeTag
instance Data.Data.Data LLVM.AST.Operand.DerivedTypeTag
instance GHC.Show.Show LLVM.AST.Operand.DerivedTypeTag
instance GHC.Read.Read LLVM.AST.Operand.DerivedTypeTag
instance GHC.Classes.Ord LLVM.AST.Operand.DerivedTypeTag
instance GHC.Classes.Eq LLVM.AST.Operand.DerivedTypeTag
instance GHC.Generics.Generic LLVM.AST.Operand.BasicTypeTag
instance Data.Data.Data LLVM.AST.Operand.BasicTypeTag
instance GHC.Show.Show LLVM.AST.Operand.BasicTypeTag
instance GHC.Read.Read LLVM.AST.Operand.BasicTypeTag
instance GHC.Classes.Ord LLVM.AST.Operand.BasicTypeTag
instance GHC.Classes.Eq LLVM.AST.Operand.BasicTypeTag
instance GHC.Generics.Generic LLVM.AST.Operand.Virtuality
instance Data.Data.Data LLVM.AST.Operand.Virtuality
instance GHC.Show.Show LLVM.AST.Operand.Virtuality
instance GHC.Read.Read LLVM.AST.Operand.Virtuality
instance GHC.Classes.Ord LLVM.AST.Operand.Virtuality
instance GHC.Classes.Eq LLVM.AST.Operand.Virtuality
instance GHC.Generics.Generic LLVM.AST.Operand.DIMacroNode
instance Data.Data.Data LLVM.AST.Operand.DIMacroNode
instance GHC.Show.Show LLVM.AST.Operand.DIMacroNode
instance GHC.Read.Read LLVM.AST.Operand.DIMacroNode
instance GHC.Classes.Ord LLVM.AST.Operand.DIMacroNode
instance GHC.Classes.Eq LLVM.AST.Operand.DIMacroNode
instance GHC.Generics.Generic LLVM.AST.Operand.DIFile
instance Data.Data.Data LLVM.AST.Operand.DIFile
instance GHC.Show.Show LLVM.AST.Operand.DIFile
instance GHC.Read.Read LLVM.AST.Operand.DIFile
instance GHC.Classes.Ord LLVM.AST.Operand.DIFile
instance GHC.Classes.Eq LLVM.AST.Operand.DIFile
instance GHC.Generics.Generic LLVM.AST.Operand.ChecksumInfo
instance Data.Data.Data LLVM.AST.Operand.ChecksumInfo
instance GHC.Show.Show LLVM.AST.Operand.ChecksumInfo
instance GHC.Read.Read LLVM.AST.Operand.ChecksumInfo
instance GHC.Classes.Ord LLVM.AST.Operand.ChecksumInfo
instance GHC.Classes.Eq LLVM.AST.Operand.ChecksumInfo
instance GHC.Generics.Generic LLVM.AST.Operand.ChecksumKind
instance Data.Data.Data LLVM.AST.Operand.ChecksumKind
instance GHC.Show.Show LLVM.AST.Operand.ChecksumKind
instance GHC.Read.Read LLVM.AST.Operand.ChecksumKind
instance GHC.Classes.Ord LLVM.AST.Operand.ChecksumKind
instance GHC.Classes.Eq LLVM.AST.Operand.ChecksumKind
instance GHC.Generics.Generic LLVM.AST.Operand.DebugNameTableKind
instance Data.Data.Data LLVM.AST.Operand.DebugNameTableKind
instance GHC.Show.Show LLVM.AST.Operand.DebugNameTableKind
instance GHC.Read.Read LLVM.AST.Operand.DebugNameTableKind
instance GHC.Classes.Ord LLVM.AST.Operand.DebugNameTableKind
instance GHC.Classes.Eq LLVM.AST.Operand.DebugNameTableKind
instance GHC.Generics.Generic LLVM.AST.Operand.DebugEmissionKind
instance Data.Data.Data LLVM.AST.Operand.DebugEmissionKind
instance GHC.Show.Show LLVM.AST.Operand.DebugEmissionKind
instance GHC.Read.Read LLVM.AST.Operand.DebugEmissionKind
instance GHC.Classes.Ord LLVM.AST.Operand.DebugEmissionKind
instance GHC.Classes.Eq LLVM.AST.Operand.DebugEmissionKind
instance GHC.Generics.Generic LLVM.AST.Operand.DIEnumerator
instance Data.Data.Data LLVM.AST.Operand.DIEnumerator
instance GHC.Show.Show LLVM.AST.Operand.DIEnumerator
instance GHC.Read.Read LLVM.AST.Operand.DIEnumerator
instance GHC.Classes.Ord LLVM.AST.Operand.DIEnumerator
instance GHC.Classes.Eq LLVM.AST.Operand.DIEnumerator
instance GHC.Generics.Generic LLVM.AST.Operand.ImportedEntityTag
instance Data.Data.Data LLVM.AST.Operand.ImportedEntityTag
instance GHC.Show.Show LLVM.AST.Operand.ImportedEntityTag
instance GHC.Read.Read LLVM.AST.Operand.ImportedEntityTag
instance GHC.Classes.Ord LLVM.AST.Operand.ImportedEntityTag
instance GHC.Classes.Eq LLVM.AST.Operand.ImportedEntityTag
instance GHC.Generics.Generic LLVM.AST.Operand.DIMacroInfo
instance Data.Data.Data LLVM.AST.Operand.DIMacroInfo
instance GHC.Show.Show LLVM.AST.Operand.DIMacroInfo
instance GHC.Read.Read LLVM.AST.Operand.DIMacroInfo
instance GHC.Classes.Ord LLVM.AST.Operand.DIMacroInfo
instance GHC.Classes.Eq LLVM.AST.Operand.DIMacroInfo
instance GHC.Generics.Generic LLVM.AST.Operand.DIFlag
instance Data.Data.Data LLVM.AST.Operand.DIFlag
instance GHC.Show.Show LLVM.AST.Operand.DIFlag
instance GHC.Read.Read LLVM.AST.Operand.DIFlag
instance GHC.Classes.Ord LLVM.AST.Operand.DIFlag
instance GHC.Classes.Eq LLVM.AST.Operand.DIFlag
instance GHC.Generics.Generic LLVM.AST.Operand.DIInheritance
instance Data.Data.Data LLVM.AST.Operand.DIInheritance
instance GHC.Show.Show LLVM.AST.Operand.DIInheritance
instance GHC.Read.Read LLVM.AST.Operand.DIInheritance
instance GHC.Classes.Ord LLVM.AST.Operand.DIInheritance
instance GHC.Classes.Eq LLVM.AST.Operand.DIInheritance
instance GHC.Generics.Generic LLVM.AST.Operand.DIAccessibility
instance Data.Data.Data LLVM.AST.Operand.DIAccessibility
instance GHC.Show.Show LLVM.AST.Operand.DIAccessibility
instance GHC.Read.Read LLVM.AST.Operand.DIAccessibility
instance GHC.Classes.Ord LLVM.AST.Operand.DIAccessibility
instance GHC.Classes.Eq LLVM.AST.Operand.DIAccessibility
instance GHC.Generics.Generic LLVM.AST.Operand.DIExpression
instance Data.Data.Data LLVM.AST.Operand.DIExpression
instance GHC.Show.Show LLVM.AST.Operand.DIExpression
instance GHC.Read.Read LLVM.AST.Operand.DIExpression
instance GHC.Classes.Ord LLVM.AST.Operand.DIExpression
instance GHC.Classes.Eq LLVM.AST.Operand.DIExpression
instance GHC.Generics.Generic LLVM.AST.Operand.DWOp
instance Data.Data.Data LLVM.AST.Operand.DWOp
instance GHC.Show.Show LLVM.AST.Operand.DWOp
instance GHC.Read.Read LLVM.AST.Operand.DWOp
instance GHC.Classes.Ord LLVM.AST.Operand.DWOp
instance GHC.Classes.Eq LLVM.AST.Operand.DWOp
instance GHC.Generics.Generic LLVM.AST.Operand.DWOpFragment
instance Data.Data.Data LLVM.AST.Operand.DWOpFragment
instance GHC.Show.Show LLVM.AST.Operand.DWOpFragment
instance GHC.Read.Read LLVM.AST.Operand.DWOpFragment
instance GHC.Classes.Ord LLVM.AST.Operand.DWOpFragment
instance GHC.Classes.Eq LLVM.AST.Operand.DWOpFragment
instance GHC.Generics.Generic (LLVM.AST.Operand.MDRef a)
instance Data.Data.Data a => Data.Data.Data (LLVM.AST.Operand.MDRef a)
instance GHC.Show.Show a => GHC.Show.Show (LLVM.AST.Operand.MDRef a)
instance GHC.Read.Read a => GHC.Read.Read (LLVM.AST.Operand.MDRef a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (LLVM.AST.Operand.MDRef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LLVM.AST.Operand.MDRef a)
instance GHC.Generics.Generic LLVM.AST.Operand.MetadataNodeID
instance Data.Data.Data LLVM.AST.Operand.MetadataNodeID
instance GHC.Show.Show LLVM.AST.Operand.MetadataNodeID
instance GHC.Read.Read LLVM.AST.Operand.MetadataNodeID
instance GHC.Classes.Ord LLVM.AST.Operand.MetadataNodeID
instance GHC.Classes.Eq LLVM.AST.Operand.MetadataNodeID
instance GHC.Base.Functor LLVM.AST.Operand.MDRef


-- | LLVM instructions
--   <a>http://llvm.org/docs/LangRef.html#instruction-reference</a>
module LLVM.AST.Instruction

-- | 
--   <a>http://llvm.org/docs/LangRef.html#metadata-nodes-and-metadata-strings</a>
--   Metadata can be attached to an instruction
type InstructionMetadata = [(ShortByteString, MDRef MDNode)]

-- | <a>http://llvm.org/docs/LangRef.html#terminators</a>
data Terminator
Ret :: Maybe Operand -> InstructionMetadata -> Terminator
[returnOperand] :: Terminator -> Maybe Operand
[metadata'] :: Terminator -> InstructionMetadata
CondBr :: Operand -> Name -> Name -> InstructionMetadata -> Terminator
[condition] :: Terminator -> Operand
[trueDest] :: Terminator -> Name
[falseDest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Br :: Name -> InstructionMetadata -> Terminator
[dest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Switch :: Operand -> Name -> [(Constant, Name)] -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[defaultDest] :: Terminator -> Name
[dests] :: Terminator -> [(Constant, Name)]
[metadata'] :: Terminator -> InstructionMetadata
IndirectBr :: Operand -> [Name] -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[possibleDests] :: Terminator -> [Name]
[metadata'] :: Terminator -> InstructionMetadata
Invoke :: CallingConvention -> [ParameterAttribute] -> CallableOperand -> [(Operand, [ParameterAttribute])] -> [Either GroupID FunctionAttribute] -> Name -> Name -> InstructionMetadata -> Terminator
[callingConvention'] :: Terminator -> CallingConvention
[returnAttributes'] :: Terminator -> [ParameterAttribute]
[function'] :: Terminator -> CallableOperand
[arguments'] :: Terminator -> [(Operand, [ParameterAttribute])]
[functionAttributes'] :: Terminator -> [Either GroupID FunctionAttribute]
[returnDest] :: Terminator -> Name
[exceptionDest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Resume :: Operand -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[metadata'] :: Terminator -> InstructionMetadata
Unreachable :: InstructionMetadata -> Terminator
[metadata'] :: Terminator -> InstructionMetadata
CleanupRet :: Operand -> Maybe Name -> InstructionMetadata -> Terminator
[cleanupPad] :: Terminator -> Operand
[unwindDest] :: Terminator -> Maybe Name
[metadata'] :: Terminator -> InstructionMetadata
CatchRet :: Operand -> Name -> InstructionMetadata -> Terminator
[catchPad] :: Terminator -> Operand
[successor] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
CatchSwitch :: Operand -> NonEmpty Name -> Maybe Name -> InstructionMetadata -> Terminator
[parentPad'] :: Terminator -> Operand
[catchHandlers] :: Terminator -> NonEmpty Name
[defaultUnwindDest] :: Terminator -> Maybe Name
[metadata'] :: Terminator -> InstructionMetadata

-- | <a>http://llvm.org/docs/LangRef.html#fast-math-flags</a>
data FastMathFlags
FastMathFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> FastMathFlags
[allowReassoc] :: FastMathFlags -> Bool
[noNaNs] :: FastMathFlags -> Bool
[noInfs] :: FastMathFlags -> Bool
[noSignedZeros] :: FastMathFlags -> Bool
[allowReciprocal] :: FastMathFlags -> Bool
[allowContract] :: FastMathFlags -> Bool
[approxFunc] :: FastMathFlags -> Bool
noFastMathFlags :: FastMathFlags

-- | 
--   <a>http://llvm.org/docs/LangRef.html#atomic-memory-ordering-constraints</a>
--   <a>http://llvm.org/docs/Atomics.html</a>
data MemoryOrdering
Unordered :: MemoryOrdering
Monotonic :: MemoryOrdering
Acquire :: MemoryOrdering
Release :: MemoryOrdering
AcquireRelease :: MemoryOrdering
SequentiallyConsistent :: MemoryOrdering

-- | <a>http://llvm.org/docs/LangRef.html#singlethread</a>
data SynchronizationScope
SingleThread :: SynchronizationScope
System :: SynchronizationScope

-- | An <a>Atomicity</a> describes constraints on the visibility of effects
--   of an atomic instruction
type Atomicity = (SynchronizationScope, MemoryOrdering)

-- | For the redoubtably complex <a>LandingPad</a> instruction
data LandingPadClause
Catch :: Constant -> LandingPadClause
Filter :: Constant -> LandingPadClause

-- | For the call instruction
--   <a>http://llvm.org/docs/LangRef.html#call-instruction</a>
data TailCallKind
Tail :: TailCallKind
MustTail :: TailCallKind
NoTail :: TailCallKind

-- | non-terminator instructions:
--   <a>http://llvm.org/docs/LangRef.html#binaryops</a>
--   <a>http://llvm.org/docs/LangRef.html#bitwiseops</a>
--   <a>http://llvm.org/docs/LangRef.html#memoryops</a>
--   <a>http://llvm.org/docs/LangRef.html#otherops</a>
data Instruction
Add :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FAdd :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Sub :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FSub :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Mul :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FMul :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
UDiv :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
SDiv :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FDiv :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
URem :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
SRem :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FRem :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Shl :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
LShr :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
AShr :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
And :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Or :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Xor :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Alloca :: Type -> Maybe Operand -> Word32 -> InstructionMetadata -> Instruction
[allocatedType] :: Instruction -> Type
[numElements] :: Instruction -> Maybe Operand
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
Load :: Bool -> Operand -> Maybe Atomicity -> Word32 -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[maybeAtomicity] :: Instruction -> Maybe Atomicity
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
Store :: Bool -> Operand -> Operand -> Maybe Atomicity -> Word32 -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[value] :: Instruction -> Operand
[maybeAtomicity] :: Instruction -> Maybe Atomicity
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
GetElementPtr :: Bool -> Operand -> [Operand] -> InstructionMetadata -> Instruction
[inBounds] :: Instruction -> Bool
[address] :: Instruction -> Operand
[indices] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata
Fence :: Atomicity -> InstructionMetadata -> Instruction
[atomicity] :: Instruction -> Atomicity
[metadata] :: Instruction -> InstructionMetadata
CmpXchg :: Bool -> Operand -> Operand -> Operand -> Atomicity -> MemoryOrdering -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[expected] :: Instruction -> Operand
[replacement] :: Instruction -> Operand
[atomicity] :: Instruction -> Atomicity
[failureMemoryOrdering] :: Instruction -> MemoryOrdering
[metadata] :: Instruction -> InstructionMetadata
AtomicRMW :: Bool -> RMWOperation -> Operand -> Operand -> Atomicity -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[rmwOperation] :: Instruction -> RMWOperation
[address] :: Instruction -> Operand
[value] :: Instruction -> Operand
[atomicity] :: Instruction -> Atomicity
[metadata] :: Instruction -> InstructionMetadata
Trunc :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ZExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
SExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPToUI :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPToSI :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
UIToFP :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
SIToFP :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPTrunc :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
PtrToInt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
IntToPtr :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
BitCast :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
AddrSpaceCast :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ICmp :: IntegerPredicate -> Operand -> Operand -> InstructionMetadata -> Instruction
[iPredicate] :: Instruction -> IntegerPredicate
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FCmp :: FloatingPointPredicate -> Operand -> Operand -> InstructionMetadata -> Instruction
[fpPredicate] :: Instruction -> FloatingPointPredicate
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Phi :: Type -> [(Operand, Name)] -> InstructionMetadata -> Instruction
[type'] :: Instruction -> Type
[incomingValues] :: Instruction -> [(Operand, Name)]
[metadata] :: Instruction -> InstructionMetadata
Call :: Maybe TailCallKind -> CallingConvention -> [ParameterAttribute] -> CallableOperand -> [(Operand, [ParameterAttribute])] -> [Either GroupID FunctionAttribute] -> InstructionMetadata -> Instruction
[tailCallKind] :: Instruction -> Maybe TailCallKind
[callingConvention] :: Instruction -> CallingConvention
[returnAttributes] :: Instruction -> [ParameterAttribute]
[function] :: Instruction -> CallableOperand
[arguments] :: Instruction -> [(Operand, [ParameterAttribute])]
[functionAttributes] :: Instruction -> [Either GroupID FunctionAttribute]
[metadata] :: Instruction -> InstructionMetadata
Select :: Operand -> Operand -> Operand -> InstructionMetadata -> Instruction
[condition'] :: Instruction -> Operand
[trueValue] :: Instruction -> Operand
[falseValue] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
VAArg :: Operand -> Type -> InstructionMetadata -> Instruction
[argList] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ExtractElement :: Operand -> Operand -> InstructionMetadata -> Instruction
[vector] :: Instruction -> Operand
[index] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
InsertElement :: Operand -> Operand -> Operand -> InstructionMetadata -> Instruction
[vector] :: Instruction -> Operand
[element] :: Instruction -> Operand
[index] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
ShuffleVector :: Operand -> Operand -> Constant -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[mask] :: Instruction -> Constant
[metadata] :: Instruction -> InstructionMetadata
ExtractValue :: Operand -> [Word32] -> InstructionMetadata -> Instruction
[aggregate] :: Instruction -> Operand
[indices'] :: Instruction -> [Word32]
[metadata] :: Instruction -> InstructionMetadata
InsertValue :: Operand -> Operand -> [Word32] -> InstructionMetadata -> Instruction
[aggregate] :: Instruction -> Operand
[element] :: Instruction -> Operand
[indices'] :: Instruction -> [Word32]
[metadata] :: Instruction -> InstructionMetadata
LandingPad :: Type -> Bool -> [LandingPadClause] -> InstructionMetadata -> Instruction
[type'] :: Instruction -> Type
[cleanup] :: Instruction -> Bool
[clauses] :: Instruction -> [LandingPadClause]
[metadata] :: Instruction -> InstructionMetadata
CatchPad :: Operand -> [Operand] -> InstructionMetadata -> Instruction
[catchSwitch] :: Instruction -> Operand
[args] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata
CleanupPad :: Operand -> [Operand] -> InstructionMetadata -> Instruction
[parentPad] :: Instruction -> Operand
[args] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata

-- | Instances of instructions may be given a name, allowing their results
--   to be referenced as <a>Operand</a>s. Sometimes instructions - e.g. a
--   call to a function returning void - don't need names.
data Named a
(:=) :: Name -> a -> Named a
Do :: a -> Named a
instance GHC.Generics.Generic (LLVM.AST.Instruction.Named a)
instance Data.Data.Data a => Data.Data.Data (LLVM.AST.Instruction.Named a)
instance GHC.Show.Show a => GHC.Show.Show (LLVM.AST.Instruction.Named a)
instance GHC.Read.Read a => GHC.Read.Read (LLVM.AST.Instruction.Named a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LLVM.AST.Instruction.Named a)
instance GHC.Generics.Generic LLVM.AST.Instruction.Instruction
instance Data.Data.Data LLVM.AST.Instruction.Instruction
instance GHC.Show.Show LLVM.AST.Instruction.Instruction
instance GHC.Read.Read LLVM.AST.Instruction.Instruction
instance GHC.Classes.Eq LLVM.AST.Instruction.Instruction
instance GHC.Generics.Generic LLVM.AST.Instruction.TailCallKind
instance Data.Data.Data LLVM.AST.Instruction.TailCallKind
instance GHC.Show.Show LLVM.AST.Instruction.TailCallKind
instance GHC.Read.Read LLVM.AST.Instruction.TailCallKind
instance GHC.Classes.Ord LLVM.AST.Instruction.TailCallKind
instance GHC.Classes.Eq LLVM.AST.Instruction.TailCallKind
instance GHC.Generics.Generic LLVM.AST.Instruction.LandingPadClause
instance Data.Data.Data LLVM.AST.Instruction.LandingPadClause
instance GHC.Show.Show LLVM.AST.Instruction.LandingPadClause
instance GHC.Read.Read LLVM.AST.Instruction.LandingPadClause
instance GHC.Classes.Ord LLVM.AST.Instruction.LandingPadClause
instance GHC.Classes.Eq LLVM.AST.Instruction.LandingPadClause
instance GHC.Generics.Generic LLVM.AST.Instruction.SynchronizationScope
instance Data.Data.Data LLVM.AST.Instruction.SynchronizationScope
instance GHC.Show.Show LLVM.AST.Instruction.SynchronizationScope
instance GHC.Read.Read LLVM.AST.Instruction.SynchronizationScope
instance GHC.Classes.Ord LLVM.AST.Instruction.SynchronizationScope
instance GHC.Classes.Eq LLVM.AST.Instruction.SynchronizationScope
instance GHC.Generics.Generic LLVM.AST.Instruction.MemoryOrdering
instance Data.Data.Data LLVM.AST.Instruction.MemoryOrdering
instance GHC.Show.Show LLVM.AST.Instruction.MemoryOrdering
instance GHC.Read.Read LLVM.AST.Instruction.MemoryOrdering
instance GHC.Classes.Ord LLVM.AST.Instruction.MemoryOrdering
instance GHC.Classes.Eq LLVM.AST.Instruction.MemoryOrdering
instance GHC.Generics.Generic LLVM.AST.Instruction.FastMathFlags
instance Data.Data.Data LLVM.AST.Instruction.FastMathFlags
instance GHC.Show.Show LLVM.AST.Instruction.FastMathFlags
instance GHC.Read.Read LLVM.AST.Instruction.FastMathFlags
instance GHC.Classes.Ord LLVM.AST.Instruction.FastMathFlags
instance GHC.Classes.Eq LLVM.AST.Instruction.FastMathFlags
instance GHC.Generics.Generic LLVM.AST.Instruction.Terminator
instance Data.Data.Data LLVM.AST.Instruction.Terminator
instance GHC.Show.Show LLVM.AST.Instruction.Terminator
instance GHC.Read.Read LLVM.AST.Instruction.Terminator
instance GHC.Classes.Eq LLVM.AST.Instruction.Terminator


-- | <a>Global</a>s - top-level values in <tt>Module</tt>s - and supporting
--   structures.
module LLVM.AST.Global

-- | <a>http://llvm.org/doxygen/classllvm_1_1GlobalValue.html</a>
data Global

-- | <a>http://llvm.org/docs/LangRef.html#global-variables</a>
GlobalVariable :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Bool -> Type -> AddrSpace -> Maybe Constant -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> [(ShortByteString, MDRef MDNode)] -> Global
[name] :: Global -> Name
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[threadLocalMode] :: Global -> Maybe Model
[unnamedAddr] :: Global -> Maybe UnnamedAddr
[isConstant] :: Global -> Bool
[type'] :: Global -> Type
[addrSpace] :: Global -> AddrSpace
[initializer] :: Global -> Maybe Constant
[section] :: Global -> Maybe ShortByteString
[comdat] :: Global -> Maybe ShortByteString
[alignment] :: Global -> Word32
[metadata] :: Global -> [(ShortByteString, MDRef MDNode)]

-- | <a>http://llvm.org/docs/LangRef.html#aliases</a>
GlobalAlias :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Type -> AddrSpace -> Constant -> Global
[name] :: Global -> Name
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[threadLocalMode] :: Global -> Maybe Model
[unnamedAddr] :: Global -> Maybe UnnamedAddr
[type'] :: Global -> Type
[addrSpace] :: Global -> AddrSpace
[aliasee] :: Global -> Constant

-- | <a>http://llvm.org/docs/LangRef.html#functions</a>
Function :: Linkage -> Visibility -> Maybe StorageClass -> CallingConvention -> [ParameterAttribute] -> Type -> Name -> ([Parameter], Bool) -> [Either GroupID FunctionAttribute] -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Maybe ShortByteString -> Maybe Constant -> [BasicBlock] -> Maybe Constant -> [(ShortByteString, MDRef MDNode)] -> Global
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[callingConvention] :: Global -> CallingConvention
[returnAttributes] :: Global -> [ParameterAttribute]
[returnType] :: Global -> Type
[name] :: Global -> Name

-- | snd indicates varargs
[parameters] :: Global -> ([Parameter], Bool)
[functionAttributes] :: Global -> [Either GroupID FunctionAttribute]
[section] :: Global -> Maybe ShortByteString
[comdat] :: Global -> Maybe ShortByteString
[alignment] :: Global -> Word32
[garbageCollectorName] :: Global -> Maybe ShortByteString
[prefix] :: Global -> Maybe Constant
[basicBlocks] :: Global -> [BasicBlock]
[personalityFunction] :: Global -> Maybe Constant
[metadata] :: Global -> [(ShortByteString, MDRef MDNode)]

-- | <a>Parameter</a>s for <a>Function</a>s
data Parameter
Parameter :: Type -> Name -> [ParameterAttribute] -> Parameter

-- | <a>http://llvm.org/doxygen/classllvm_1_1BasicBlock.html</a> LLVM code
--   in a function is a sequence of <a>BasicBlock</a>s each with a label,
--   some instructions, and a terminator.
data BasicBlock
BasicBlock :: Name -> [Named Instruction] -> Named Terminator -> BasicBlock
data UnnamedAddr
LocalAddr :: UnnamedAddr
GlobalAddr :: UnnamedAddr

-- | helper for making <a>GlobalVariable</a>s
globalVariableDefaults :: Global

-- | helper for making <a>GlobalAlias</a>s
globalAliasDefaults :: Global

-- | helper for making <a>Function</a>s
functionDefaults :: Global
instance GHC.Generics.Generic LLVM.AST.Global.Global
instance Data.Data.Data LLVM.AST.Global.Global
instance GHC.Show.Show LLVM.AST.Global.Global
instance GHC.Read.Read LLVM.AST.Global.Global
instance GHC.Classes.Eq LLVM.AST.Global.Global
instance GHC.Generics.Generic LLVM.AST.Global.UnnamedAddr
instance Data.Data.Data LLVM.AST.Global.UnnamedAddr
instance GHC.Show.Show LLVM.AST.Global.UnnamedAddr
instance GHC.Read.Read LLVM.AST.Global.UnnamedAddr
instance GHC.Classes.Eq LLVM.AST.Global.UnnamedAddr
instance GHC.Generics.Generic LLVM.AST.Global.BasicBlock
instance Data.Data.Data LLVM.AST.Global.BasicBlock
instance GHC.Show.Show LLVM.AST.Global.BasicBlock
instance GHC.Read.Read LLVM.AST.Global.BasicBlock
instance GHC.Classes.Eq LLVM.AST.Global.BasicBlock
instance GHC.Generics.Generic LLVM.AST.Global.Parameter
instance Data.Data.Data LLVM.AST.Global.Parameter
instance GHC.Show.Show LLVM.AST.Global.Parameter
instance GHC.Read.Read LLVM.AST.Global.Parameter
instance GHC.Classes.Eq LLVM.AST.Global.Parameter


-- | <a>http://llvm.org/docs/LangRef.html#data-layout</a>
module LLVM.AST.DataLayout

-- | Little Endian is the one true way :-). Sadly, we must support the
--   infidels.
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness

-- | An AlignmentInfo describes how a given type must and would best be
--   aligned
data AlignmentInfo
AlignmentInfo :: Word32 -> Word32 -> AlignmentInfo
[abiAlignment] :: AlignmentInfo -> Word32
[preferredAlignment] :: AlignmentInfo -> Word32

-- | A type of type for which <a>AlignmentInfo</a> may be specified
data AlignType
IntegerAlign :: AlignType
VectorAlign :: AlignType
FloatAlign :: AlignType

-- | A style of name mangling
data Mangling
ELFMangling :: Mangling
MIPSMangling :: Mangling
MachOMangling :: Mangling
WindowsCOFFMangling :: Mangling

-- | a description of the various data layout properties which may be used
--   during optimization
data DataLayout
DataLayout :: Endianness -> Maybe Mangling -> Maybe Word32 -> Map AddrSpace (Word32, AlignmentInfo) -> Map (AlignType, Word32) AlignmentInfo -> AlignmentInfo -> Maybe (Set Word32) -> DataLayout
[endianness] :: DataLayout -> Endianness
[mangling] :: DataLayout -> Maybe Mangling
[stackAlignment] :: DataLayout -> Maybe Word32
[pointerLayouts] :: DataLayout -> Map AddrSpace (Word32, AlignmentInfo)
[typeLayouts] :: DataLayout -> Map (AlignType, Word32) AlignmentInfo
[aggregateLayout] :: DataLayout -> AlignmentInfo
[nativeSizes] :: DataLayout -> Maybe (Set Word32)

-- | a default <a>DataLayout</a>
defaultDataLayout :: Endianness -> DataLayout
instance GHC.Generics.Generic LLVM.AST.DataLayout.DataLayout
instance Data.Data.Data LLVM.AST.DataLayout.DataLayout
instance GHC.Show.Show LLVM.AST.DataLayout.DataLayout
instance GHC.Read.Read LLVM.AST.DataLayout.DataLayout
instance GHC.Classes.Ord LLVM.AST.DataLayout.DataLayout
instance GHC.Classes.Eq LLVM.AST.DataLayout.DataLayout
instance GHC.Generics.Generic LLVM.AST.DataLayout.Mangling
instance Data.Data.Data LLVM.AST.DataLayout.Mangling
instance GHC.Show.Show LLVM.AST.DataLayout.Mangling
instance GHC.Read.Read LLVM.AST.DataLayout.Mangling
instance GHC.Classes.Ord LLVM.AST.DataLayout.Mangling
instance GHC.Classes.Eq LLVM.AST.DataLayout.Mangling
instance GHC.Generics.Generic LLVM.AST.DataLayout.AlignType
instance Data.Data.Data LLVM.AST.DataLayout.AlignType
instance GHC.Show.Show LLVM.AST.DataLayout.AlignType
instance GHC.Read.Read LLVM.AST.DataLayout.AlignType
instance GHC.Classes.Ord LLVM.AST.DataLayout.AlignType
instance GHC.Classes.Eq LLVM.AST.DataLayout.AlignType
instance GHC.Generics.Generic LLVM.AST.DataLayout.AlignmentInfo
instance Data.Data.Data LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Show.Show LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Read.Read LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Classes.Ord LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Classes.Eq LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Generics.Generic LLVM.AST.DataLayout.Endianness
instance Data.Data.Data LLVM.AST.DataLayout.Endianness
instance GHC.Show.Show LLVM.AST.DataLayout.Endianness
instance GHC.Read.Read LLVM.AST.DataLayout.Endianness
instance GHC.Classes.Ord LLVM.AST.DataLayout.Endianness
instance GHC.Classes.Eq LLVM.AST.DataLayout.Endianness

module LLVM.DataLayout
dataLayoutToString :: DataLayout -> ByteString

-- | Parse a <a>DataLayout</a>, given a default Endianness should one not
--   be specified in the string to be parsed. LLVM itself uses BigEndian as
--   the default: thus pass BigEndian to be conformant or LittleEndian to
--   be righteously defiant.
parseDataLayout :: Endianness -> ByteString -> Except String (Maybe DataLayout)


-- | This module and descendants define AST data types to represent LLVM
--   code. Note that these types are designed for fidelity rather than
--   convenience - if the truth of what LLVM supports is less than pretty,
--   so be it.
module LLVM.AST

-- | <a>http://llvm.org/docs/LangRef.html#module-structure</a>
data Module
Module :: ShortByteString -> ShortByteString -> Maybe DataLayout -> Maybe ShortByteString -> [Definition] -> Module
[moduleName] :: Module -> ShortByteString
[moduleSourceFileName] :: Module -> ShortByteString

-- | a <a>DataLayout</a>, if specified, must match that of the eventual
--   code generator
[moduleDataLayout] :: Module -> Maybe DataLayout
[moduleTargetTriple] :: Module -> Maybe ShortByteString
[moduleDefinitions] :: Module -> [Definition]

-- | helper for making <a>Module</a>s
defaultModule :: Module

-- | Any thing which can be at the top level of a <a>Module</a>
data Definition
GlobalDefinition :: Global -> Definition
TypeDefinition :: Name -> Maybe Type -> Definition
MetadataNodeDefinition :: MetadataNodeID -> MDNode -> Definition
NamedMetadataDefinition :: ShortByteString -> [MetadataNodeID] -> Definition
ModuleInlineAssembly :: ByteString -> Definition
FunctionAttributes :: GroupID -> [FunctionAttribute] -> Definition
COMDAT :: ShortByteString -> SelectionKind -> Definition

-- | <a>http://llvm.org/doxygen/classllvm_1_1GlobalValue.html</a>
data Global

-- | <a>http://llvm.org/docs/LangRef.html#global-variables</a>
GlobalVariable :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Bool -> Type -> AddrSpace -> Maybe Constant -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> [(ShortByteString, MDRef MDNode)] -> Global

-- | <a>http://llvm.org/docs/LangRef.html#aliases</a>
GlobalAlias :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Type -> AddrSpace -> Constant -> Global

-- | <a>http://llvm.org/docs/LangRef.html#functions</a>
Function :: Linkage -> Visibility -> Maybe StorageClass -> CallingConvention -> [ParameterAttribute] -> Type -> Name -> ([Parameter], Bool) -> [Either GroupID FunctionAttribute] -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Maybe ShortByteString -> Maybe Constant -> [BasicBlock] -> Maybe Constant -> [(ShortByteString, MDRef MDNode)] -> Global

-- | helper for making <a>GlobalVariable</a>s
globalVariableDefaults :: Global

-- | helper for making <a>GlobalAlias</a>s
globalAliasDefaults :: Global

-- | helper for making <a>Function</a>s
functionDefaults :: Global
data UnnamedAddr
LocalAddr :: UnnamedAddr
GlobalAddr :: UnnamedAddr

-- | <a>Parameter</a>s for <a>Function</a>s
data Parameter
Parameter :: Type -> Name -> [ParameterAttribute] -> Parameter

-- | <a>http://llvm.org/doxygen/classllvm_1_1BasicBlock.html</a> LLVM code
--   in a function is a sequence of <a>BasicBlock</a>s each with a label,
--   some instructions, and a terminator.
data BasicBlock
BasicBlock :: Name -> [Named Instruction] -> Named Terminator -> BasicBlock

-- | An <a>Operand</a> is roughly that which is an argument to an
--   <a>Instruction</a>
data Operand

-- | %foo
LocalReference :: Type -> Name -> Operand

-- | <a>Constant</a>s include <a>GlobalReference</a>, for @foo
ConstantOperand :: Constant -> Operand
MetadataOperand :: Metadata -> Operand

-- | The <a>Call</a> instruction is special: the callee can be inline
--   assembly
type CallableOperand = Either InlineAssembly Operand

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDString :: ShortByteString -> Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDNode :: MDRef MDNode -> Metadata

-- | 
--   <a>http://llvm.org/docs/doxygen/html/classllvm_1_1ValueAsMetadata.html</a>
MDValue :: Operand -> Metadata

-- | A <a>MetadataNodeID</a> is a number for identifying a metadata node.
--   Note this is different from "named metadata", which are represented
--   with <a>NamedMetadataDefinition</a>.
newtype MetadataNodeID
MetadataNodeID :: Word -> MetadataNodeID

-- | <a>MDRef</a> can either represent a reference to some piece of
--   metadata or the metadata itself.
--   
--   This is mainly useful for encoding cyclic metadata. Note that LLVM
--   represents inline and non-inline nodes identically, so roundtripping
--   the Haskell AST does not preserve whether a node was inline or not.
data MDRef a
MDRef :: MetadataNodeID -> MDRef a
MDInline :: a -> MDRef a

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data MDNode

-- | Nothing represents <a>null</a>
MDTuple :: [Maybe Metadata] -> MDNode
DIExpression :: DIExpression -> MDNode
DIGlobalVariableExpression :: DIGlobalVariableExpression -> MDNode
DILocation :: DILocation -> MDNode
DIMacroNode :: DIMacroNode -> MDNode
DINode :: DINode -> MDNode

-- | <a>http://llvm.org/docs/LangRef.html#type-system</a>
data Type

-- | <a>http://llvm.org/docs/LangRef.html#void-type</a>
VoidType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#integer-type</a>
IntegerType :: Word32 -> Type
[typeBits] :: Type -> Word32

-- | <a>http://llvm.org/docs/LangRef.html#pointer-type</a>
PointerType :: Type -> AddrSpace -> Type
[pointerReferent] :: Type -> Type
[pointerAddrSpace] :: Type -> AddrSpace

-- | <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
FloatingPointType :: FloatingPointType -> Type
[floatingPointType] :: Type -> FloatingPointType

-- | <a>http://llvm.org/docs/LangRef.html#function-type</a>
FunctionType :: Type -> [Type] -> Bool -> Type
[resultType] :: Type -> Type
[argumentTypes] :: Type -> [Type]
[isVarArg] :: Type -> Bool

-- | <a>http://llvm.org/docs/LangRef.html#vector-type</a>
VectorType :: Word32 -> Type -> Type
[nVectorElements] :: Type -> Word32
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#structure-type</a>
StructureType :: Bool -> [Type] -> Type
[isPacked] :: Type -> Bool
[elementTypes] :: Type -> [Type]

-- | <a>http://llvm.org/docs/LangRef.html#array-type</a>
ArrayType :: Word64 -> Type -> Type
[nArrayElements] :: Type -> Word64
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#opaque-structure-types</a>
NamedTypeReference :: Name -> Type

-- | <a>http://llvm.org/docs/LangRef.html#metadata-type</a>
MetadataType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#label-type</a>
LabelType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#token-type</a>
TokenType :: Type

-- | LLVM supports some special formats floating point format. This type is
--   to distinguish those format. Also see
--   <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
data FloatingPointType

-- | 16-bit floating point value
HalfFP :: FloatingPointType

-- | 32-bit floating point value
FloatFP :: FloatingPointType

-- | 64-bit floating point value
DoubleFP :: FloatingPointType

-- | 128-bit floating point value (112-bit mantissa)
FP128FP :: FloatingPointType

-- | 80-bit floating point value (X87)
X86_FP80FP :: FloatingPointType

-- | 128-bit floating point value (two 64-bits)
PPC_FP128FP :: FloatingPointType
instance GHC.Generics.Generic LLVM.AST.Module
instance Data.Data.Data LLVM.AST.Module
instance GHC.Show.Show LLVM.AST.Module
instance GHC.Read.Read LLVM.AST.Module
instance GHC.Classes.Eq LLVM.AST.Module
instance GHC.Generics.Generic LLVM.AST.Definition
instance Data.Data.Data LLVM.AST.Definition
instance GHC.Show.Show LLVM.AST.Definition
instance GHC.Read.Read LLVM.AST.Definition
instance GHC.Classes.Eq LLVM.AST.Definition

module LLVM.IRBuilder.Monad

-- | This provides a uniform API for creating instructions and inserting
--   them into a basic block: either at the end of a BasicBlock, or at a
--   specific location in a block.
newtype IRBuilderT m a
IRBuilderT :: StateT IRBuilderState m a -> IRBuilderT m a
[unIRBuilderT] :: IRBuilderT m a -> StateT IRBuilderState m a
type IRBuilder = IRBuilderT Identity
class Monad m => MonadIRBuilder m
liftIRState :: MonadIRBuilder m => State IRBuilderState a -> m a
liftIRState :: (MonadIRBuilder m, MonadTrans t, MonadIRBuilder m1, m ~ t m1) => State IRBuilderState a -> m a

-- | A partially constructed block as a sequence of instructions
data PartialBlock
PartialBlock :: !Name -> SnocList (Named Instruction) -> Maybe (Named Terminator) -> PartialBlock
[partialBlockName] :: PartialBlock -> !Name
[partialBlockInstrs] :: PartialBlock -> SnocList (Named Instruction)
[partialBlockTerm] :: PartialBlock -> Maybe (Named Terminator)
emptyPartialBlock :: Name -> PartialBlock

-- | Builder monad state
data IRBuilderState
IRBuilderState :: !Word -> !HashSet ShortByteString -> !Maybe ShortByteString -> SnocList BasicBlock -> !Maybe PartialBlock -> IRBuilderState
[builderSupply] :: IRBuilderState -> !Word
[builderUsedNames] :: IRBuilderState -> !HashSet ShortByteString
[builderNameSuggestion] :: IRBuilderState -> !Maybe ShortByteString
[builderBlocks] :: IRBuilderState -> SnocList BasicBlock
[builderBlock] :: IRBuilderState -> !Maybe PartialBlock
emptyIRBuilder :: IRBuilderState

-- | Evaluate IRBuilder to a result and a list of basic blocks
runIRBuilder :: IRBuilderState -> IRBuilder a -> (a, [BasicBlock])

-- | Evaluate IRBuilderT to a result and a list of basic blocks
runIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m (a, [BasicBlock])

-- | Evaluate IRBuilder to a list of basic blocks
execIRBuilder :: IRBuilderState -> IRBuilder a -> [BasicBlock]

-- | Evaluate IRBuilderT to a list of basic blocks
execIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m [BasicBlock]

-- | If no partial block exists, create a new block with a fresh label.
--   
--   This is useful if you want to ensure that the label for the block is
--   assigned before another label which is not possible with
--   <a>modifyBlock</a>.
ensureBlock :: MonadIRBuilder m => m ()
modifyBlock :: MonadIRBuilder m => (PartialBlock -> PartialBlock) -> m ()

-- | Generate a fresh name. The resulting name is numbered or based on the
--   name suggested with <a>named</a> if that's used.
fresh :: MonadIRBuilder m => m Name

-- | Generate a fresh name from a name suggestion
freshName :: MonadIRBuilder m => ShortByteString -> m Name

-- | Generate a fresh numbered name
freshUnName :: MonadIRBuilder m => m Name

-- | Emit instruction
emitInstr :: MonadIRBuilder m => Type -> Instruction -> m Operand

-- | Emit instruction that returns void
emitInstrVoid :: MonadIRBuilder m => Instruction -> m ()

-- | Emit terminator
emitTerm :: MonadIRBuilder m => Terminator -> m ()

-- | Starts a new block labelled using the given name and ends the previous
--   one. The name is assumed to be fresh.
emitBlockStart :: MonadIRBuilder m => Name -> m ()

-- | Starts a new block and ends the previous one
block :: MonadIRBuilder m => m Name

-- | <tt>ir <a>named</a> name</tt> executes the <a>IRBuilder</a>
--   <tt>ir</tt> using <tt>name</tt> as the base name whenever a fresh
--   local name is generated. Collisions are avoided by appending numbers
--   (first <tt>"name"</tt>, then <tt>"name1"</tt>, <tt>"name2"</tt>, and
--   so on).
named :: MonadIRBuilder m => m r -> ShortByteString -> m r

-- | Get the name of the currently active block.
--   
--   This function will throw an error if there is no active block. The
--   only situation in which this can occur is if it is called before any
--   call to <a>block</a> and before emitting any instructions.
currentBlock :: MonadIRBuilder m => m Name

-- | Find out if the currently active block has a terminator.
--   
--   This function will fail under the same condition as
--   <tt>currentBlock</tt>
hasTerminator :: MonadIRBuilder m => m Bool
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Trans.Class.MonadTrans LLVM.IRBuilder.Monad.IRBuilderT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Monad (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Functor m => GHC.Base.Functor (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => LLVM.IRBuilder.Monad.MonadIRBuilder (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (LLVM.IRBuilder.Monad.IRBuilderT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Cont.ContT r m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Except.ExceptT e m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Identity.IdentityT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.List.ListT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Maybe.MaybeT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Reader.ReaderT r m)
instance (LLVM.IRBuilder.Monad.MonadIRBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (LLVM.IRBuilder.Monad.MonadIRBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.State.Strict.StateT s m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Monad.MonadIRBuilder m) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Monad.MonadIRBuilder m) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Writer.Lazy.WriterT w m)

module LLVM.IRBuilder.Module
newtype ModuleBuilderT m a
ModuleBuilderT :: StateT ModuleBuilderState m a -> ModuleBuilderT m a
[unModuleBuilderT] :: ModuleBuilderT m a -> StateT ModuleBuilderState m a
data ModuleBuilderState
ModuleBuilderState :: SnocList Definition -> Map Name Type -> ModuleBuilderState
[builderDefs] :: ModuleBuilderState -> SnocList Definition
[builderTypeDefs] :: ModuleBuilderState -> Map Name Type
emptyModuleBuilder :: ModuleBuilderState
type ModuleBuilder = ModuleBuilderT Identity
class Monad m => MonadModuleBuilder m
liftModuleState :: MonadModuleBuilder m => State ModuleBuilderState a -> m a
liftModuleState :: (MonadModuleBuilder m, MonadTrans t, MonadModuleBuilder m1, m ~ t m1) => State ModuleBuilderState a -> m a

-- | Evaluate <a>ModuleBuilder</a> to a result and a list of definitions
runModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> (a, [Definition])

-- | Evaluate <a>ModuleBuilderT</a> to a result and a list of definitions
runModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m (a, [Definition])

-- | Evaluate <a>ModuleBuilder</a> to a list of definitions
execModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> [Definition]

-- | Evaluate <a>ModuleBuilderT</a> to a list of definitions
execModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m [Definition]
emitDefn :: MonadModuleBuilder m => Definition -> m ()

-- | A parameter name suggestion
data ParameterName
NoParameterName :: ParameterName
ParameterName :: ShortByteString -> ParameterName

-- | Define and emit a (non-variadic) function definition
function :: MonadModuleBuilder m => Name -> [(Type, ParameterName)] -> Type -> ([Operand] -> IRBuilderT m ()) -> m Operand

-- | An external function definition
extern :: MonadModuleBuilder m => Name -> [Type] -> Type -> m Operand

-- | An external variadic argument function definition
externVarArgs :: MonadModuleBuilder m => Name -> [Type] -> Type -> m Operand

-- | A global variable definition
global :: MonadModuleBuilder m => Name -> Type -> Constant -> m Operand

-- | A named type definition
typedef :: MonadModuleBuilder m => Name -> Maybe Type -> m Type

-- | Convenience function for module construction
buildModule :: ShortByteString -> ModuleBuilder a -> Module

-- | Convenience function for module construction (transformer version)
buildModuleT :: Monad m => ShortByteString -> ModuleBuilderT m a -> m Module
instance GHC.Generics.Generic LLVM.IRBuilder.Module.ParameterName
instance Data.Data.Data LLVM.IRBuilder.Module.ParameterName
instance GHC.Show.Show LLVM.IRBuilder.Module.ParameterName
instance GHC.Read.Read LLVM.IRBuilder.Module.ParameterName
instance GHC.Classes.Ord LLVM.IRBuilder.Module.ParameterName
instance GHC.Classes.Eq LLVM.IRBuilder.Module.ParameterName
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Trans.Class.MonadTrans LLVM.IRBuilder.Module.ModuleBuilderT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Monad (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Functor m => GHC.Base.Functor (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Data.String.IsString LLVM.IRBuilder.Module.ParameterName
instance GHC.Base.Monad m => LLVM.IRBuilder.Module.MonadModuleBuilder (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Cont.ContT r m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Except.ExceptT e m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Identity.IdentityT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.List.ListT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Maybe.MaybeT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Reader.ReaderT r m)
instance (LLVM.IRBuilder.Module.MonadModuleBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (LLVM.IRBuilder.Module.MonadModuleBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.State.Lazy.StateT s m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Module.MonadModuleBuilder m) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (LLVM.IRBuilder.Module.ModuleBuilderT m)


-- | Querying the type of LLVM expressions
module LLVM.AST.Typed
class Typed a
typeOf :: Typed a => a -> Type
getElementType :: Type -> Type
getElementPtrType :: Type -> [Constant] -> Type
extractValueType :: [Word32] -> Type -> Type
instance LLVM.AST.Typed.Typed LLVM.AST.Operand.Operand
instance LLVM.AST.Typed.Typed LLVM.AST.Operand.CallableOperand
instance LLVM.AST.Typed.Typed LLVM.AST.Constant.Constant
instance LLVM.AST.Typed.Typed LLVM.AST.Float.SomeFloat
instance LLVM.AST.Typed.Typed LLVM.AST.Global.Global
instance LLVM.AST.Typed.Typed LLVM.AST.Global.Parameter

module LLVM.IRBuilder.Instruction

-- | See <a>reference</a>.
fadd :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fmul :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fsub :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fdiv :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
frem :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
add :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
mul :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
sub :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
udiv :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
sdiv :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
urem :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
srem :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
shl :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
lshr :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
ashr :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
and :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
or :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
xor :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
alloca :: MonadIRBuilder m => Type -> Maybe Operand -> Word32 -> m Operand

-- | See <a>reference</a>.
load :: MonadIRBuilder m => Operand -> Word32 -> m Operand

-- | See <a>reference</a>.
store :: MonadIRBuilder m => Operand -> Word32 -> Operand -> m ()

-- | Emit the <tt>getelementptr</tt> instruction. See <a>reference</a>.
gep :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> [Operand] -> m Operand

-- | Emit the <tt>trunc ... to</tt> instruction. See <a>reference</a>.
trunc :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptrunc ... to</tt> instruction. See <a>reference</a>.
fptrunc :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>zext ... to</tt> instruction. See <a>reference</a>.
zext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>sext ... to</tt> instruction. See <a>reference</a>.
sext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptoui ... to</tt> instruction. See <a>reference</a>.
fptoui :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptosi ... to</tt> instruction. See <a>reference</a>.
fptosi :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fpext ... to</tt> instruction. See <a>reference</a>.
fpext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>uitofp ... to</tt> instruction. See <a>reference</a>.
uitofp :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>sitofp ... to</tt> instruction. See <a>reference</a>.
sitofp :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>ptrtoint ... to</tt> instruction. See <a>reference</a>.
ptrtoint :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>inttoptr ... to</tt> instruction. See <a>reference</a>.
inttoptr :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>bitcast ... to</tt> instruction. See <a>reference</a>.
bitcast :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | See <a>reference</a>.
extractElement :: MonadIRBuilder m => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
insertElement :: MonadIRBuilder m => Operand -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
shuffleVector :: MonadIRBuilder m => Operand -> Operand -> Constant -> m Operand

-- | See <a>reference</a>.
extractValue :: MonadIRBuilder m => Operand -> [Word32] -> m Operand

-- | See <a>reference</a>.
insertValue :: MonadIRBuilder m => Operand -> Operand -> [Word32] -> m Operand

-- | See <a>reference</a>.
icmp :: MonadIRBuilder m => IntegerPredicate -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fcmp :: MonadIRBuilder m => FloatingPointPredicate -> Operand -> Operand -> m Operand

-- | Unconditional branch. Emit a <tt>br label <a>dest</a></tt> instruction
--   See <a>reference</a>.
br :: MonadIRBuilder m => Name -> m ()

-- | See <a>reference</a>.
phi :: MonadIRBuilder m => [(Operand, Name)] -> m Operand

-- | Emit a <tt>ret void</tt> instruction. See <a>reference</a>.
retVoid :: MonadIRBuilder m => m ()

-- | See <a>reference</a>.
call :: MonadIRBuilder m => Operand -> [(Operand, [ParameterAttribute])] -> m Operand

-- | See <a>reference</a>.
ret :: MonadIRBuilder m => Operand -> m ()

-- | See <a>reference</a>.
switch :: MonadIRBuilder m => Operand -> Name -> [(Constant, Name)] -> m ()

-- | See <a>reference</a>.
select :: MonadIRBuilder m => Operand -> Operand -> Operand -> m Operand

-- | Conditional branch (see <a>br</a> for unconditional instructions). See
--   <a>reference</a>.
condBr :: MonadIRBuilder m => Operand -> Name -> Name -> m ()

-- | See <a>reference</a>.
unreachable :: MonadIRBuilder m => m ()

-- | Creates a series of instructions to generate a pointer to a string
--   constant. Useful for making format strings to pass to <tt>printf</tt>,
--   for example
globalStringPtr :: (MonadModuleBuilder m, MonadIRBuilder m) => String -> Name -> m Operand

module LLVM.IRBuilder.Constant
int64 :: Applicative f => Integer -> f Operand
int32 :: Applicative f => Integer -> f Operand
int8 :: Applicative f => Integer -> f Operand
bit :: Applicative f => Integer -> f Operand
double :: Applicative f => Double -> f Operand
single :: Applicative f => Float -> f Operand
half :: Applicative f => Word16 -> f Operand
struct :: Applicative f => Maybe Name -> Bool -> [Constant] -> f Operand
array :: Applicative f => [Constant] -> f Operand

module LLVM.IRBuilder
