-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lifting linear vector spaces into Accelerate
--   
--   Lifting linear vector spaces into Accelerate
@package linear-accelerate
@version 0.4


module Data.Array.Accelerate.Linear.Type
type Box f a = (Unlift Exp (f (Exp a)), Plain (f (Exp a)) ~ f a)
type Box2 f g a = (Box f (g a), Box g a, Lift Exp (f (g (Exp a))), Plain (f (g (Exp a))) ~ f (g a))


-- | Operations on free vector spaces
module Data.Array.Accelerate.Linear.Vector

-- | A vector is an additive group with additional structure.
--   
--   TODO: Support both <a>Exp</a> and <a>Acc</a>
class Additive f => Additive f where zero = constant (zero) (^+^) = lift2 ((^+^) :: f (Exp a) -> f (Exp a) -> f (Exp a)) (^-^) = lift2 ((^-^) :: f (Exp a) -> f (Exp a) -> f (Exp a)) lerp = lift3 (lerp :: Exp a -> f (Exp a) -> f (Exp a) -> f (Exp a))

-- | The zero vector
zero :: (Additive f, Elt (f a), Num a) => Exp (f a)

-- | Compute the sum of two vectors
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^+^ lift (V2 3 4 :: V2 Int)
--   (4,6)
--   </pre>
(^+^) :: forall a. (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)

-- | Compute the difference between two vectors
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 4 5 :: V2 Int) ^-^ lift (V2 3 1 :: V2 Int)
--   (1,4)
--   </pre>
(^-^) :: forall a. (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)

-- | Linearly interpolate between two vectors
lerp :: forall a. (Additive f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a) -> Exp (f a)
type IsAdditive f a = (Additive f, Box f a)

-- | Basis element
newtype E t
E :: (forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)) -> E t
[el] :: E t -> forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | Compute the negation of a vector
--   
--   <pre>
--   &gt;&gt;&gt; negated (lift (V2 2 4 :: V2 Int))
--   (-2,-4)
--   </pre>
negated :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp (f a)

-- | Compute the left scalar product
--   
--   <pre>
--   &gt;&gt;&gt; 2 *^ lift (V2 3 4 :: V2 Int)
--   (6,8)
--   </pre>
(*^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 7 *^

-- | Compute the right scalar product
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 3 4 :: V2 Int) ^* 2
--   (6,8)
--   </pre>
(^*) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 7 ^*

-- | Compute division by a scalar on the right
--   
--   lift (V2 4 6 :: V2 Double) ^/ 2 V2 2 3
(^/) :: forall f a. (Functor f, Fractional a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 7 ^/

-- | Compute division of a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 4 /^ lift (V2 2 4 :: V2 Double)
--   (2.0,1.0)
--   </pre>
(/^) :: forall f a. (Functor f, Fractional a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 7 /^

-- | Addition with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 2 +^ lift (V2 3 4 :: V2 Int)
--   (5,6)
--   </pre>
(+^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 6 +^

-- | Addition with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^+ 3
--   (4,5)
--   </pre>
(^+) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 6 ^+

-- | Subtraction with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 2 -^ lift (V2 3 4 :: V2 Int)
--   (-1,-2)
--   </pre>
(-^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 6 -^

-- | Subtraction with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^- 3
--   (-2,-1)
--   </pre>
(^-) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 6 ^-


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Epsilon

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Exp Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Exp Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Exp Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Exp Float)
--   True
--   </pre>
class Num a => Epsilon a

-- | Determine if a quantity is near zero.
nearZero :: Epsilon a => Exp a -> Exp Bool

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-6
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-12
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-6
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-12
--   </pre>
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon GHC.Types.Float
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon GHC.Types.Double
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon Foreign.C.Types.CFloat
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon Foreign.C.Types.CDouble


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Metric

-- | Free and sparse inner product/metric spaces.
class Metric f => Metric f where dot = lift2 (dot :: f (Exp a) -> f (Exp a) -> Exp a) quadrance = lift1 (quadrance :: f (Exp a) -> Exp a) qd = lift2 (qd :: f (Exp a) -> f (Exp a) -> Exp a) distance = lift2 (distance :: f (Exp a) -> f (Exp a) -> Exp a) norm = lift1 (norm :: f (Exp a) -> Exp a) signorm = lift1 (signorm :: f (Exp a) -> f (Exp a))

-- | Compute the inner product of two vectors or (equivalently) convert a
--   vector <tt>f a</tt> into a covector <tt>f a -&gt; a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) `dot` lift (V2 3 4 :: V2 Int)
--   11
--   </pre>
dot :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the squared norm. The name quadrance arises from Norman J.
--   Wildberger's rational trigonometry.
quadrance :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp a

-- | Compute the <a>quadrance</a> of the difference
qd :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the distance between two vectors in a metric space
distance :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the norm of a vector in a metric space
norm :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp a

-- | Convert a non-zero vector to unit vector.
signorm :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a)
type IsMetric f a = (Metric f, Box f a)

-- | Normalize a <a>Metric</a> functor to have unit <a>norm</a>. This
--   function does not change the functor if its <a>norm</a> is 0 or 1.
normalize :: (Elt (f a), Floating a, IsMetric f a, Epsilon a) => Exp (f a) -> Exp (f a)

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: forall f a. (Floating a, IsMetric f a) => Exp (f a) -> Exp (f a) -> Exp (f a)


-- | 0-D Vectors
module Data.Array.Accelerate.Linear.V0
data V0 a :: * -> *
V0 :: V0 a
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V0.V0
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V0.V0
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V0.V0 a)
instance Data.Array.Accelerate.Product.IsProduct cst (Linear.V0.V0 a)
instance Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)
instance Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | 1-D Vectors
module Data.Array.Accelerate.Linear.V1
newtype V1 a :: * -> *
V1 :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))

-- | <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   (3)
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
ex :: R1 t => E t
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V1.V1
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V1.V1
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V1.V1
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V1.V1 a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.V1.V1 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | 2-D Vectors
module Data.Array.Accelerate.Linear.V2
data V2 a :: * -> *
V2 :: ~a -> ~a -> V2 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))

-- | <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   (3)
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   (1,3)
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^. _yx
--   (2,1)
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
ex :: R1 t => E t
ey :: R2 t => E t

-- | the counter-clockwise perpendicular vector
--   
--   <pre>
--   &gt;&gt;&gt; perp $ lift (V2 10 20 :: V2 Int)
--   (-20,10)
--   </pre>
perp :: forall a. Num a => Exp (V2 a) -> Exp (V2 a)

-- | Unit vector with given phase angle (modulo 2*<a>pi</a>)
angle :: Floating a => Exp a -> Exp (V2 a)
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V2.V2
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V2.V2
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V2.V2
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V2.V2
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V2.V2 a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.V2.V2 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | 3-D Vectors
module Data.Array.Accelerate.Linear.V3
data V3 a :: * -> *
V3 :: ~a -> ~a -> ~a -> V3 a

-- | cross product
cross :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a)

-- | scalar triple product
triple :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a) -> Exp a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))

-- | <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   (3)
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   (1,3)
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^. _yx
--   (2,1)
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t where _z = liftLens (_z :: Lens' (t (Exp a)) (Exp a)) _xyz = liftLens (_xyz :: Lens' (t (Exp a)) (V3 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V3 1 2 3 :: V3 Int) ^. _z
--   3
--   </pre>
_z :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V3.V3
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V3.V3
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V3.V3
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V3.V3
instance Data.Array.Accelerate.Linear.V3.R3 Linear.V3.V3
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V3.V3 a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.V3.V3 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | Quaternions
module Data.Array.Accelerate.Linear.Quaternion
data Quaternion a :: * -> *
Quaternion :: ~a -> {-# UNPACK #-} ~(V3 a) -> Quaternion a
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.Quaternion.Quaternion
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.Quaternion.Quaternion
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.Quaternion.Quaternion a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.Quaternion.Quaternion a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a)) (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | 4-D Vectors
module Data.Array.Accelerate.Linear.V4
data V4 a :: * -> *
V4 :: ~a -> ~a -> ~a -> ~a -> V4 a

-- | Convert a 3-dimensional affine vector into a 4-dimensional homogeneous
--   vector.
vector :: forall a. Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert a 3-dimensional affine point into a 4-dimensional homogeneous
--   vector.
point :: forall a. Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert 4-dimensional projective coordinates to a 3-dimensional point.
--   This operation may be denoted, <tt>euclidean [x:y:z:w] = (x/w, y/w,
--   z/w)</tt> where the projective, homogenous, coordinate
--   <tt>[x:y:z:w]</tt> is one of many associated with a single point
--   <tt>(x/w, y/w, z/w)</tt>.
normalizePoint :: forall a. Floating a => Exp (V4 a) -> Exp (V3 a)

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))

-- | <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   (3)
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   (1,3)
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) ^. _yx
--   (2,1)
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t where _z = liftLens (_z :: Lens' (t (Exp a)) (Exp a)) _xyz = liftLens (_xyz :: Lens' (t (Exp a)) (V3 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V3 1 2 3 :: V3 Int) ^. _z
--   3
--   </pre>
_z :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, and <a>_w</a>. (Although it may have more.)
class (R4 t, R3 t) => R4 t where _w = liftLens (_w :: Lens' (t (Exp a)) (Exp a)) _xyzw = liftLens (_xyzw :: Lens' (t (Exp a)) (V4 (Exp a)))

-- | <pre>
--   &gt;&gt;&gt; lift (V4 1 2 3 4 :: V4 Int) ^._w
--   4
--   </pre>
_w :: forall a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyzw :: forall a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xywz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxwz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzwx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zyxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zywx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
ew :: R4 t => E t
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V4.V4
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V4.V4
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V4.V4
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V4.V4
instance Data.Array.Accelerate.Linear.V3.R3 Linear.V4.V4
instance Data.Array.Accelerate.Linear.V4.R4 Linear.V4.V4
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V4.V4 a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.V4.V4 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | Pl端cker coordinates for lines in 3d homogeneous space.
module Data.Array.Accelerate.Linear.Plucker
data Plucker a :: * -> *
Plucker :: ~a -> ~a -> ~a -> ~a -> ~a -> ~a -> Plucker a

-- | Valid Pl端cker coordinates <tt>p</tt> will have <tt><a>squaredError</a>
--   p <a>==</a> 0</tt>
--   
--   That said, floating point makes a mockery of this claim, so you may
--   want to use <tt>nearZero</tt>.
squaredError :: forall a. Num a => Exp (Plucker a) -> Exp a

-- | This isn't the actual metric because this bilinear form gives rise to
--   an isotropic quadratic space
(><) :: forall a. Num a => Exp (Plucker a) -> Exp (Plucker a) -> Exp a
infixl 5 ><

-- | Given a pair of points represented by homogeneous coordinates generate
--   Pl端cker coordinates for the line through them, directed from the
--   second towards the first.
plucker :: forall a. Num a => Exp (V4 a) -> Exp (V4 a) -> Exp (Plucker a)

-- | Given a pair of 3D points, generate Pl端cker coordinates for the line
--   through them, directed from the second towards the first.
plucker3D :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (Plucker a)
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.Plucker.Plucker
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.Plucker.Plucker
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.Plucker.Plucker a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Linear.Plucker.Plucker a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a)) (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)


-- | Simple matrix operations for low-dimensional primitives
module Data.Array.Accelerate.Linear.Matrix
type M22 a = V2 (V2 a)
type M23 a = V2 (V3 a)
type M24 a = V2 (V4 a)
type M32 a = V3 (V2 a)
type M33 a = V3 (V3 a)
type M34 a = V3 (V4 a)
type M42 a = V4 (V2 a)
type M43 a = V4 (V3 a)
type M44 a = V4 (V4 a)

-- | Matrix product. This can compute any combination of sparse and dense
--   multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !*! lift (V3 (V2 1 2) (V2 3 4) (V2 4 5) :: M32 Int)
--   ((19,25),(43,58))
--   </pre>
(!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a, Box2 m t a, Box2 t n a, Box2 m n a) => Exp (m (t a)) -> Exp (t (n a)) -> Exp (m (n a))
infixl 7 !*!

-- | Entry-wise matrix addition.
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !+! lift (V2 (V3 7 8 9) (V3 1 2 3) :: M23 Int)
--   ((8,10,12),(5,7,9))
--   </pre>
(!+!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))
infixl 6 !+!

-- | Entry-wise matrix subtraction.
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !-! lift (V2 (V3 7 8 9) (V3 1 2 3) :: M23 Int)
--   ((-6,-6,-6),(3,3,3))
--   </pre>
(!-!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))
infixl 6 !-!

-- | Matrix * column vector
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !* lift (V3 7 8 9 :: V3 Int)
--   (50,122)
--   </pre>
(!*) :: (Functor m, Foldable r, Additive r, Num a, Box2 m r a, Box m a) => Exp (m (r a)) -> Exp (r a) -> Exp (m a)
infixl 7 !*

-- | Row vector * matrix
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) *! lift (V2 (V3 3 4 5) (V3 6 7 8) :: M23 Int)
--   (15,18,21)
--   </pre>
(*!) :: (Foldable t, Additive f, Additive t, Num a, Box t a, Box f a, Box2 t f a) => Exp (t a) -> Exp (t (f a)) -> Exp (f a)
infixl 7 *!

-- | Matrix-scalar product
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 (V2 1 2) (V2 3 4) :: M22 Int) !!* 5
--   ((5,10),(15,20))
--   </pre>
(!!*) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))
infixl 7 !!*

-- | Scalar-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; 5 *!! lift (V2 (V2 1 2) (V2 3 4) :: M22 Int)
--   ((5,10),(15,20))
--   </pre>
(*!!) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp a -> Exp (m (r a)) -> Exp (m (r a))
infixl 7 *!!

-- | Matrix-scalar division
(!!/) :: (Functor m, Functor r, Floating a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))
infixl 7 !!/

-- | <a>transpose</a> is just an alias for <a>distribute</a>
--   
--   <pre>
--   transpose (V3 (V2 1 2) (V2 3 4) (V2 5 6))
--   </pre>
--   
--   V2 (V3 1 3 5) (V3 2 4 6)
transpose :: (Distributive g, Functor f, Box2 f g a, Box2 g f a) => Exp (f (g a)) -> Exp (g (f a))

-- | The identity matrix for any dimension vector.
--   
--   <pre>
--   &gt;&gt;&gt; identity :: Exp (M44 Int)
--   let x0 = 1 in
--   let x1 = 0
--   in ((x0,x1,x1,x1),(x1,x0,x1,x1),(x1,x1,x0,x1),(x1,x1,x1,x0))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; identity :: Exp (V3 (V3 Int))
--   let x0 = 1 in
--   let x1 = 0
--   in ((x0,x1,x1),(x1,x0,x1),(x1,x1,x0))
--   </pre>
identity :: forall t a. (Traversable t, Applicative t, Num a, Box2 t t a) => Exp (t (t a))
class Trace m => Trace m where trace = lift . trace . unlift' diagonal = lift . diagonal . unlift'

-- | Compute the trace of a matrix
trace :: (Trace m, Num a, Box2 m m a) => Exp (m (m a)) -> Exp a

-- | Compute the diagonal of a matrix
diagonal :: (Trace m, Box2 m m a) => Exp (m (m a)) -> Exp (m a)
instance Data.Array.Accelerate.Linear.Matrix.Trace Data.Complex.Complex
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.V0.V0
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.V1.V1
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.V2.V2
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.V3.V3
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.V4.V4
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.Plucker.Plucker
instance Data.Array.Accelerate.Linear.Matrix.Trace Linear.Quaternion.Quaternion


-- | This module simply re-exports everything from the various modules that
--   make up the linear package, lifted to Accelerate.
module Data.Array.Accelerate.Linear
