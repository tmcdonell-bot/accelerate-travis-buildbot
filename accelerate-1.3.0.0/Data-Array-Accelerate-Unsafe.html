<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Array.Accelerate.Unsafe</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data.Array.Accelerate.Unsafe.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">accelerate-1.3.0.0: An embedded language for accelerated array processing</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>[2009..2019] The Accelerate Team</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Trevor L. McDonell &lt;trevor.mcdonell@gmail.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Array.Accelerate.Unsafe</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Unsafe operations</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Operations which may be unsafe. Use with care.</p><p><em>Since: 1.2.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:undef">undef</a> :: <a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> t =&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> t</li><li class="src short"><a href="#v:coerce">coerce</a> :: (<a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> a, <a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> b) =&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> a -&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> b</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h2>Unsafe operations</h2></a><div class="top"><p class="src"><a id="v:undef" class="def">undef</a> :: <a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> t =&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> t <a href="src/Data.Array.Accelerate.Smart.html#undef" class="link">Source</a> <a href="#v:undef" class="selflink">#</a></p><div class="doc"><p><code><a href="Data-Array-Accelerate-Unsafe.html#v:undef" title="Data.Array.Accelerate.Unsafe">undef</a></code> can be used anywhere a constant is expected, and indicates that the
 consumer of the value can receive an unspecified bit pattern.</p><p>This is useful because a store of an undefined value can be assumed to not
 have any effect; we can assume that the value is overwritten with bits that
 happen to match what was already there. However, a store <em>to</em> an undefined
 location could clobber arbitrary memory, therefore, its use in such a context
 would introduce undefined <em>behaviour</em>.</p><p>There are (at least) two cases where you may want to use this:</p><ol><li>The <code><a href="Data-Array-Accelerate-Language.html#v:permute" title="Data.Array.Accelerate.Language">permute</a></code> function requires an array
      of default values, into which the new values are combined. However, if
      you are sure the default values are not used, and will (eventually) be
      completely overwritten, then <code><a href="Data-Array-Accelerate-Prelude.html#v:fill" title="Data.Array.Accelerate.Prelude">fill</a></code>ing an
      array with this value will give you a new uninitialised array.</li><li>In the definition of sum data types. See for example
      <a href="Data-Array-Accelerate-Data-Maybe.html">Data.Array.Accelerate.Data.Maybe</a> and
      <a href="Data-Array-Accelerate-Data-Either.html">Data.Array.Accelerate.Data.Either</a>.</li></ol><p><em>Since: 1.2.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:coerce" class="def">coerce</a> :: (<a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> a, <a href="Data-Array-Accelerate.html#t:Elt" title="Data.Array.Accelerate">Elt</a> b) =&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> a -&gt; <a href="Data-Array-Accelerate.html#t:Exp" title="Data.Array.Accelerate">Exp</a> b <a href="src/Data.Array.Accelerate.Unsafe.html#coerce" class="link">Source</a> <a href="#v:coerce" class="selflink">#</a></p><div class="doc"><p>The function <code><a href="Data-Array-Accelerate-Unsafe.html#v:coerce" title="Data.Array.Accelerate.Unsafe">coerce</a></code> allows you to convert a value between any two types
 whose underlying representations have the same bit size at each component.</p><p>For example:</p><pre>coerce (x :: Exp Double)         :: Exp Word64
coerce (x :: Exp (Int64,Float))  :: Exp (Complex Float, Word32)</pre><p>Furthermore, as we typically declare newtype wrappers similarly to:</p><pre>type instance EltRepr (Sum a) = ((), EltRepr a)</pre><p>This can be used instead of the newtype constructor, to go from the newtype's
 abstract type to the concrete type by dropping the extra <code>()</code> from the
 representation, and vice-versa.</p><p>You will get a runtime error if it fails to find a coercion between the two
 representations.</p><p><em>Since: 1.2.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>