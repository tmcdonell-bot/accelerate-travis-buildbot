-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate Accelerate arrays filled with high quality pseudorandom numbers
--   
--   Generate <i>Accelerate</i> arrays filled with high-quality
--   pseudorandom numbers.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package mwc-random-accelerate
@version 0.1.0.0


-- | Random number generation backed by MWC.
--   
--   <ul>
--   <li><i><i>Example</i></i></li>
--   </ul>
--   
--   Create a vector of 100 random uniformly distributed floating-point
--   numbers, where the PRNG is seeded with data from the system's source
--   of pseudo-random numbers (see <a>withSystemRandom</a>):
--   
--   <pre>
--   &gt;&gt;&gt; vs &lt;- randomArray uniform (Z :. 100)           :: IO (Vector Float)
--   </pre>
--   
--   To generate uniformly distributed random variables in the range
--   (-1,1]:
--   
--   <pre>
--   &gt;&gt;&gt; vs &lt;- randomArray (uniformR (-1,1)) (Z:.100)   :: IO (Vector Double)
--   </pre>
--   
--   You can also pass the generator state in explicitly, so that it can be
--   reused:
--   
--   <pre>
--   &gt;&gt;&gt; gen &lt;- create                                  :: IO GenIO
--   
--   &gt;&gt;&gt; vs  &lt;- randomArrayWith gen uniform (Z :. 100)  :: IO (Vector Int)
--   </pre>
--   
--   <ul>
--   <li><i><i>Non-uniform distributions</i></i></li>
--   </ul>
--   
--   If you require random numbers following other distributions, you can
--   combine this package with the generators from the <a>random-fu</a>
--   package. For example:
--   
--   <pre>
--   import Data.Random                                    hiding ( uniform )
--   import qualified Data.Random.Distribution.Exponential as R
--   import qualified Data.Random.Distribution.Poisson     as R
--   
--   exponential
--       :: (Distribution StdUniform e, Floating e, Shape sh, Elt e)
--       =&gt; e
--       -&gt; sh :~&gt; e
--   exponential beta _sh gen = sampleFrom gen (R.exponential beta)
--   
--   poisson
--       :: (Distribution (R.Poisson b) a, Shape sh, Elt a)
--       =&gt; b
--       -&gt; sh :~&gt; a
--   poisson lambda _sh gen = sampleFrom gen (R.poisson lambda)
--   </pre>
--   
--   Which can then be used as before:
--   
--   <pre>
--   &gt;&gt;&gt; vs &lt;- randomArray (exponential 5) (Z :. 100)   :: IO (Vector Float)
--   
--   &gt;&gt;&gt; us &lt;- randomArray (poisson 5)     (Z :. 100)   :: IO (Vector Float)
--   </pre>
module Data.Array.Accelerate.System.Random.MWC

-- | A PRNG from indices to variates
type sh :~> e = sh -> GenIO -> IO e

-- | Uniformly distributed random variates.
uniform :: (Shape sh, Elt e, Variate e) => sh :~> e

-- | Uniformly distributed random variates in a given range.
uniformR :: (Shape sh, Elt e, Variate e) => (e, e) -> sh :~> e

-- | Generate an array of random values. The generator for variates is
--   seeded from the system's fast source of pseudo-random numbers (see:
--   <a>createSystemRandom</a>)
randomArray :: (Shape sh, Elt e) => (sh :~> e) -> sh -> IO (Array sh e)

-- | Generate an array of random values using the supplied generator.
randomArrayWith :: (Shape sh, Elt e) => GenIO -> (sh :~> e) -> sh -> IO (Array sh e)

-- | Generate a vector of pseudo-random variates. This is not necessarily
--   faster than invoking <a>uniform</a> repeatedly in a loop, but it may
--   be more convenient to use in some situations.
uniformVector :: (PrimMonad m, Variate a, Vector v a) => Gen (PrimState m) -> Int -> m (v a)

-- | Seed a PRNG with data from the system's fast source of pseudo-random
--   numbers. All the caveats of <a>withSystemRandom</a> apply here as
--   well.
createSystemRandom :: IO GenIO

-- | Seed a PRNG with data from the system's fast source of pseudo-random
--   numbers ("<tt>/dev/urandom</tt>" on Unix-like systems or
--   <tt>RtlGenRandom</tt> on Windows), then run the given action.
--   
--   This is a somewhat expensive function, and is intended to be called
--   only occasionally (e.g. once per thread). You should use the
--   <a>Gen</a> it creates to generate many random numbers.
withSystemRandom :: PrimBase m => (Gen (PrimState m) -> m a) -> IO a

-- | Create a new <a>Gen</a> that mirrors the state of a saved <a>Seed</a>.
restore :: PrimMonad m => Seed -> m (Gen (PrimState m))

-- | Save the state of a <a>Gen</a>, for later use by <a>restore</a>.
save :: PrimMonad m => Gen (PrimState m) -> m Seed

-- | Convert vector to <a>Seed</a>. It acts similarily to <a>initialize</a>
--   and will accept any vector. If you want to pass seed immediately to
--   restore you better call initialize directly since following law holds:
--   
--   <pre>
--   restore (toSeed v) = initialize v
--   </pre>
toSeed :: Vector v Word32 => v Word32 -> Seed

-- | Create a generator for variates using the given seed, of which up to
--   256 elements will be used. For arrays of less than 256 elements, part
--   of the default seed will be used to finish initializing the
--   generator's state.
--   
--   Examples:
--   
--   <pre>
--   initialize (singleton 42)
--   </pre>
--   
--   <pre>
--   initialize (fromList [4, 8, 15, 16, 23, 42])
--   </pre>
--   
--   If a seed contains fewer than 256 elements, it is first used verbatim,
--   then its elements are <a>xor</a>ed against elements of the default
--   seed until 256 elements are reached.
--   
--   If a seed contains exactly 258 elements, then the last two elements
--   are used to set the generator's initial state. This allows for
--   complete generator reproducibility, so that e.g. <tt>gen' == gen</tt>
--   in the following example:
--   
--   <pre>
--   gen' &lt;- <a>initialize</a> . <a>fromSeed</a> =&lt;&lt; <a>save</a>
--   </pre>
--   
--   In the MWC algorithm, the <i>carry</i> value must be strictly smaller
--   than the multiplicator (see
--   <a>https://en.wikipedia.org/wiki/Multiply-with-carry)</a>. Hence, if a
--   seed contains exactly 258 elements, the <i>carry</i> value, which is
--   the last of the 258 values, is moduloed by the multiplicator.
--   
--   Note that if the <i>first</i> carry value is strictly smaller than the
--   multiplicator, all subsequent carry values are also strictly smaller
--   than the multiplicator (a proof of this is in the comments of the code
--   of <a>uniformWord32</a>), hence when restoring a saved state, we have
--   the guarantee that moduloing the saved carry won't modify its value.
initialize :: (PrimMonad m, Vector v Word32) => v Word32 -> m (Gen (PrimState m))

-- | Create a generator for variates using a fixed seed.
create :: PrimMonad m => m (Gen (PrimState m))

-- | Constrain the type of an action to run in the <a>ST</a> monad.
asGenST :: () => (GenST s -> ST s a) -> GenST s -> ST s a

-- | Constrain the type of an action to run in the <a>IO</a> monad.
asGenIO :: () => (GenIO -> IO a) -> GenIO -> IO a

-- | The class of types for which we can generate uniformly distributed
--   random variates.
--   
--   The uniform PRNG uses Marsaglia's MWC256 (also known as MWC8222)
--   multiply-with-carry generator, which has a period of 2^8222 and fares
--   well in tests of randomness. It is also extremely fast, between 2 and
--   3 times faster than the Mersenne Twister.
--   
--   <i>Note</i>: Marsaglia's PRNG is not known to be cryptographically
--   secure, so you should not use it for cryptographic operations.
class Variate a

-- | State of the pseudo-random number generator. It uses mutable state so
--   same generator shouldn't be used from the different threads
--   simultaneously.
data Gen s

-- | A shorter name for PRNG state in the <a>IO</a> monad.
type GenIO = Gen PrimState IO

-- | A shorter name for PRNG state in the <a>ST</a> monad.
type GenST s = Gen PrimState ST s

-- | An immutable snapshot of the state of a <a>Gen</a>.
data Seed
