-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure Haskell LLVM functionality (no FFI).
--   
--   llvm-hs-pure is a set of pure Haskell types and functions for
--   interacting with LLVM <a>http://llvm.org/</a>. It includes an ADT to
--   represent LLVM IR (<a>http://llvm.org/docs/LangRef.html</a>). The
--   llvm-hs package builds on this one with FFI bindings to LLVM, but
--   llvm-hs-pure does not require LLVM to be available.
@package llvm-hs-pure
@version 5.1.1


-- | This module is presents a prelude mostly like the
--   post-Applicative-Monad world of base &gt;= 4.8 / ghc &gt;= 7.10, even
--   on earlier versions. It's intended as an internal library for
--   llvm-hs-pure and llvm-hs; it's exposed only to be shared between the
--   two.
module LLVM.Prelude

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString :: *

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString :: *

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a
leftBiasedZip :: [a] -> [b] -> [(a, Maybe b)]
findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m
infixr 6 <>

module LLVM.IRBuilder.Internal.SnocList
newtype SnocList a
SnocList :: [a] -> SnocList a
[unSnocList] :: SnocList a -> [a]
snoc :: SnocList a -> a -> SnocList a
getSnocList :: SnocList a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (LLVM.IRBuilder.Internal.SnocList.SnocList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LLVM.IRBuilder.Internal.SnocList.SnocList a)
instance GHC.Base.Monoid (LLVM.IRBuilder.Internal.SnocList.SnocList a)


-- | Module to allow importing <a>Visibility</a> distinctly qualified.
module LLVM.AST.Visibility

-- | <a>http://llvm.org/docs/LangRef.html#visibility</a>
data Visibility
Default :: Visibility
Hidden :: Visibility
Protected :: Visibility
instance GHC.Generics.Generic LLVM.AST.Visibility.Visibility
instance Data.Data.Data LLVM.AST.Visibility.Visibility
instance GHC.Show.Show LLVM.AST.Visibility.Visibility
instance GHC.Read.Read LLVM.AST.Visibility.Visibility
instance GHC.Classes.Eq LLVM.AST.Visibility.Visibility


-- | Module to allow importing <a>Model</a> distinctly qualified.
module LLVM.AST.ThreadLocalStorage

-- | <a>http://llvm.org/docs/LangRef.html#thread-local-storage-models</a>
data Model
GeneralDynamic :: Model
LocalDynamic :: Model
InitialExec :: Model
LocalExec :: Model
instance GHC.Generics.Generic LLVM.AST.ThreadLocalStorage.Model
instance Data.Data.Data LLVM.AST.ThreadLocalStorage.Model
instance GHC.Show.Show LLVM.AST.ThreadLocalStorage.Model
instance GHC.Read.Read LLVM.AST.ThreadLocalStorage.Model
instance GHC.Classes.Ord LLVM.AST.ThreadLocalStorage.Model
instance GHC.Classes.Eq LLVM.AST.ThreadLocalStorage.Model


-- | Operations for the <a>AtomicRMW</a> instruction
module LLVM.AST.RMWOperation

-- | <a>http://llvm.org/docs/LangRef.html#atomicrmw-instruction</a>
data RMWOperation
Xchg :: RMWOperation
Add :: RMWOperation
Sub :: RMWOperation
And :: RMWOperation
Nand :: RMWOperation
Or :: RMWOperation
Xor :: RMWOperation
Max :: RMWOperation
Min :: RMWOperation
UMax :: RMWOperation
UMin :: RMWOperation
instance GHC.Generics.Generic LLVM.AST.RMWOperation.RMWOperation
instance Data.Data.Data LLVM.AST.RMWOperation.RMWOperation
instance GHC.Show.Show LLVM.AST.RMWOperation.RMWOperation
instance GHC.Read.Read LLVM.AST.RMWOperation.RMWOperation
instance GHC.Classes.Ord LLVM.AST.RMWOperation.RMWOperation
instance GHC.Classes.Eq LLVM.AST.RMWOperation.RMWOperation


-- | Module to allow importing <a>ParameterAttribute</a> distinctly
--   qualified.
module LLVM.AST.ParameterAttribute

-- | <a>http://llvm.org/docs/LangRef.html#parameter-attributes</a>
data ParameterAttribute
ZeroExt :: ParameterAttribute
SignExt :: ParameterAttribute
InReg :: ParameterAttribute
SRet :: ParameterAttribute
Alignment :: Word64 -> ParameterAttribute
NoAlias :: ParameterAttribute
ByVal :: ParameterAttribute
NoCapture :: ParameterAttribute
Nest :: ParameterAttribute
ReadNone :: ParameterAttribute
ReadOnly :: ParameterAttribute
WriteOnly :: ParameterAttribute
InAlloca :: ParameterAttribute
NonNull :: ParameterAttribute
Dereferenceable :: Word64 -> ParameterAttribute
DereferenceableOrNull :: Word64 -> ParameterAttribute
Returned :: ParameterAttribute
SwiftSelf :: ParameterAttribute
SwiftError :: ParameterAttribute
StringAttribute :: ShortByteString -> ShortByteString -> ParameterAttribute
[stringAttributeKind] :: ParameterAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: ParameterAttribute -> ShortByteString
instance GHC.Generics.Generic LLVM.AST.ParameterAttribute.ParameterAttribute
instance Data.Data.Data LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Show.Show LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Read.Read LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Classes.Ord LLVM.AST.ParameterAttribute.ParameterAttribute
instance GHC.Classes.Eq LLVM.AST.ParameterAttribute.ParameterAttribute


-- | Names as used in LLVM IR
module LLVM.AST.Name

-- | Objects of various sorts in LLVM IR are identified by address in the
--   LLVM C++ API, and may be given a string name. When printed to (resp.
--   read from) human-readable LLVM assembly, objects without string names
--   are numbered sequentially (resp. must be numbered sequentially).
--   String names may be quoted, and are quoted when printed if they would
--   otherwise be misread - e.g. when containing special characters.
--   
--   <pre>
--   7
--   </pre>
--   
--   means the seventh unnamed object, while
--   
--   <pre>
--   "7"
--   </pre>
--   
--   means the object named with the string "7".
--   
--   This libraries handling of <a>UnName</a>s during translation of the
--   AST down into C++ IR is somewhat more forgiving than the LLVM assembly
--   parser: it does not require that unnamed values be numbered
--   sequentially; however, the numbers of <a>UnName</a>s passed into C++
--   cannot be preserved in the C++ objects. If the C++ IR is printed as
--   assembly or translated into a Haskell AST, unnamed nodes will be
--   renumbered sequentially. Thus unnamed node numbers should be thought
--   of as having any scope limited to the <a>Module</a> in which they are
--   used.
data Name

-- | a string name
Name :: ShortByteString -> Name

-- | a number for a nameless thing
UnName :: Word -> Name

-- | Using <a>fromString</a> on non-ASCII strings will throw an error.

-- | Create a <a>Name</a> based on an ASCII <a>String</a>. Non-ASCII
--   strings will throw an error.
mkName :: String -> Name
instance GHC.Generics.Generic LLVM.AST.Name.Name
instance Data.Data.Data LLVM.AST.Name.Name
instance GHC.Show.Show LLVM.AST.Name.Name
instance GHC.Read.Read LLVM.AST.Name.Name
instance GHC.Classes.Ord LLVM.AST.Name.Name
instance GHC.Classes.Eq LLVM.AST.Name.Name
instance Data.String.IsString LLVM.AST.Name.Name


-- | Module to allow importing <a>Linkage</a> distinctly qualified.
module LLVM.AST.Linkage

-- | <a>http://llvm.org/docs/LangRef.html#linkage</a>
data Linkage
Private :: Linkage
Internal :: Linkage
AvailableExternally :: Linkage
LinkOnce :: Linkage
Weak :: Linkage
Common :: Linkage
Appending :: Linkage
ExternWeak :: Linkage
LinkOnceODR :: Linkage
WeakODR :: Linkage
External :: Linkage
instance GHC.Generics.Generic LLVM.AST.Linkage.Linkage
instance Data.Data.Data LLVM.AST.Linkage.Linkage
instance GHC.Show.Show LLVM.AST.Linkage.Linkage
instance GHC.Read.Read LLVM.AST.Linkage.Linkage
instance GHC.Classes.Eq LLVM.AST.Linkage.Linkage


-- | Predicates for the <a>ICmp</a> instruction
module LLVM.AST.IntegerPredicate

-- | <a>http://llvm.org/docs/LangRef.html#icmp-instruction</a>
data IntegerPredicate
EQ :: IntegerPredicate
NE :: IntegerPredicate
UGT :: IntegerPredicate
UGE :: IntegerPredicate
ULT :: IntegerPredicate
ULE :: IntegerPredicate
SGT :: IntegerPredicate
SGE :: IntegerPredicate
SLT :: IntegerPredicate
SLE :: IntegerPredicate
instance GHC.Generics.Generic LLVM.AST.IntegerPredicate.IntegerPredicate
instance Data.Data.Data LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Show.Show LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Read.Read LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Classes.Ord LLVM.AST.IntegerPredicate.IntegerPredicate
instance GHC.Classes.Eq LLVM.AST.IntegerPredicate.IntegerPredicate


-- | Module to allow importing <a>FunctionAttribute</a> distinctly
--   qualified.
module LLVM.AST.FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#function-attributes</a>
data FunctionAttribute
NoReturn :: FunctionAttribute
NoUnwind :: FunctionAttribute
ReadNone :: FunctionAttribute
ReadOnly :: FunctionAttribute
NoInline :: FunctionAttribute
NoRecurse :: FunctionAttribute
AlwaysInline :: FunctionAttribute
MinimizeSize :: FunctionAttribute
OptimizeForSize :: FunctionAttribute
OptimizeNone :: FunctionAttribute
StackProtect :: FunctionAttribute
StackProtectReq :: FunctionAttribute
StackProtectStrong :: FunctionAttribute
NoRedZone :: FunctionAttribute
NoImplicitFloat :: FunctionAttribute
Naked :: FunctionAttribute
InlineHint :: FunctionAttribute
StackAlignment :: Word64 -> FunctionAttribute
ReturnsTwice :: FunctionAttribute
UWTable :: FunctionAttribute
NonLazyBind :: FunctionAttribute
Builtin :: FunctionAttribute
NoBuiltin :: FunctionAttribute
Cold :: FunctionAttribute
JumpTable :: FunctionAttribute
NoDuplicate :: FunctionAttribute
SanitizeAddress :: FunctionAttribute
SanitizeThread :: FunctionAttribute
SanitizeMemory :: FunctionAttribute
Speculatable :: FunctionAttribute
StringAttribute :: ShortByteString -> ShortByteString -> FunctionAttribute
[stringAttributeKind] :: FunctionAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: FunctionAttribute -> ShortByteString

-- | AllocSize 0 (Just 0) is invalid
AllocSize :: Word32 -> (Maybe Word32) -> FunctionAttribute
WriteOnly :: FunctionAttribute
ArgMemOnly :: FunctionAttribute
Convergent :: FunctionAttribute
InaccessibleMemOnly :: FunctionAttribute
InaccessibleMemOrArgMemOnly :: FunctionAttribute
SafeStack :: FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#attribute-groups</a>
newtype GroupID
GroupID :: Word -> GroupID
instance GHC.Generics.Generic LLVM.AST.FunctionAttribute.GroupID
instance Data.Data.Data LLVM.AST.FunctionAttribute.GroupID
instance GHC.Show.Show LLVM.AST.FunctionAttribute.GroupID
instance GHC.Read.Read LLVM.AST.FunctionAttribute.GroupID
instance GHC.Classes.Ord LLVM.AST.FunctionAttribute.GroupID
instance GHC.Classes.Eq LLVM.AST.FunctionAttribute.GroupID
instance GHC.Generics.Generic LLVM.AST.FunctionAttribute.FunctionAttribute
instance Data.Data.Data LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Show.Show LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Read.Read LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Classes.Ord LLVM.AST.FunctionAttribute.FunctionAttribute
instance GHC.Classes.Eq LLVM.AST.FunctionAttribute.FunctionAttribute


-- | Module to allow importing <tt>Attribute</tt> distinctly qualified.
--   Before LLVM 3.5, the attributes which could be used on functions and
--   those which could be used on parameters were disjoint. In LLVM 3.5,
--   two attributes (readonly and readnone) can be used in both contexts.
--   Because their interpretation is different in the two contexts and only
--   those two attributes can be used in both contexts, I've opted to keep
--   the Haskell types for parameter and function attributes distinct, but
--   move the two types into separate modules so they can have contructors
--   with the same names.
module LLVM.AST.Attribute

-- | <a>http://llvm.org/docs/LangRef.html#parameter-attributes</a>
data ParameterAttribute
ZeroExt :: ParameterAttribute
SignExt :: ParameterAttribute
InReg :: ParameterAttribute
SRet :: ParameterAttribute
Alignment :: Word64 -> ParameterAttribute
NoAlias :: ParameterAttribute
ByVal :: ParameterAttribute
NoCapture :: ParameterAttribute
Nest :: ParameterAttribute
InAlloca :: ParameterAttribute
NonNull :: ParameterAttribute
Dereferenceable :: Word64 -> ParameterAttribute
DereferenceableOrNull :: Word64 -> ParameterAttribute
Returned :: ParameterAttribute
SwiftSelf :: ParameterAttribute
SwiftError :: ParameterAttribute

-- | <a>http://llvm.org/docs/LangRef.html#function-attributes</a>
data FunctionAttribute
NoReturn :: FunctionAttribute
NoUnwind :: FunctionAttribute
ReadNone :: FunctionAttribute
ReadOnly :: FunctionAttribute
NoInline :: FunctionAttribute
NoRecurse :: FunctionAttribute
AlwaysInline :: FunctionAttribute
MinimizeSize :: FunctionAttribute
OptimizeForSize :: FunctionAttribute
OptimizeNone :: FunctionAttribute
StackProtect :: FunctionAttribute
StackProtectReq :: FunctionAttribute
StackProtectStrong :: FunctionAttribute
NoRedZone :: FunctionAttribute
NoImplicitFloat :: FunctionAttribute
Naked :: FunctionAttribute
InlineHint :: FunctionAttribute
StackAlignment :: Word64 -> FunctionAttribute
ReturnsTwice :: FunctionAttribute
UWTable :: FunctionAttribute
NonLazyBind :: FunctionAttribute
Builtin :: FunctionAttribute
NoBuiltin :: FunctionAttribute
Cold :: FunctionAttribute
JumpTable :: FunctionAttribute
NoDuplicate :: FunctionAttribute
SanitizeAddress :: FunctionAttribute
SanitizeThread :: FunctionAttribute
SanitizeMemory :: FunctionAttribute
Speculatable :: FunctionAttribute
StringAttribute :: ShortByteString -> ShortByteString -> FunctionAttribute
[stringAttributeKind] :: FunctionAttribute -> ShortByteString

-- | Use "" for no value -- the two are conflated
[stringAttributeValue] :: FunctionAttribute -> ShortByteString

-- | AllocSize 0 (Just 0) is invalid
AllocSize :: Word32 -> (Maybe Word32) -> FunctionAttribute
WriteOnly :: FunctionAttribute
ArgMemOnly :: FunctionAttribute
Convergent :: FunctionAttribute
InaccessibleMemOnly :: FunctionAttribute
InaccessibleMemOrArgMemOnly :: FunctionAttribute
SafeStack :: FunctionAttribute

-- | <a>http://llvm.org/docs/LangRef.html#attribute-groups</a>
newtype GroupID
GroupID :: Word -> GroupID


-- | Predicates for the <a>FCmp</a> instruction
module LLVM.AST.FloatingPointPredicate

-- | <a>http://llvm.org/docs/LangRef.html#fcmp-instruction</a>
data FloatingPointPredicate
False :: FloatingPointPredicate
OEQ :: FloatingPointPredicate
OGT :: FloatingPointPredicate
OGE :: FloatingPointPredicate
OLT :: FloatingPointPredicate
OLE :: FloatingPointPredicate
ONE :: FloatingPointPredicate
ORD :: FloatingPointPredicate
UNO :: FloatingPointPredicate
UEQ :: FloatingPointPredicate
UGT :: FloatingPointPredicate
UGE :: FloatingPointPredicate
ULT :: FloatingPointPredicate
ULE :: FloatingPointPredicate
UNE :: FloatingPointPredicate
True :: FloatingPointPredicate
instance GHC.Generics.Generic LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance Data.Data.Data LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Show.Show LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Read.Read LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Classes.Ord LLVM.AST.FloatingPointPredicate.FloatingPointPredicate
instance GHC.Classes.Eq LLVM.AST.FloatingPointPredicate.FloatingPointPredicate


-- | This module provides a sub-namespace for a type to support the various
--   sizes of floating point numbers LLVM supports. It is most definitely
--   intended to be imported qualified.
module LLVM.AST.Float

-- | A type summing up the various float types. N.B. Note that in the
--   constructors with multiple fields, the lower significance bits are on
--   the right - e.g. Quadruple highbits lowbits
data SomeFloat
Half :: Word16 -> SomeFloat
Single :: Float -> SomeFloat
Double :: Double -> SomeFloat
Quadruple :: Word64 -> Word64 -> SomeFloat
X86_FP80 :: Word16 -> Word64 -> SomeFloat
PPC_FP128 :: Word64 -> Word64 -> SomeFloat
instance GHC.Generics.Generic LLVM.AST.Float.SomeFloat
instance Data.Data.Data LLVM.AST.Float.SomeFloat
instance GHC.Show.Show LLVM.AST.Float.SomeFloat
instance GHC.Read.Read LLVM.AST.Float.SomeFloat
instance GHC.Classes.Ord LLVM.AST.Float.SomeFloat
instance GHC.Classes.Eq LLVM.AST.Float.SomeFloat


-- | Module to allow importing <a>StorageClass</a> distinctly qualified.
module LLVM.AST.DLL

-- | <a>http://llvm.org/docs/LangRef.html#dll-storage-classes</a>
data StorageClass
Import :: StorageClass
Export :: StorageClass
instance GHC.Generics.Generic LLVM.AST.DLL.StorageClass
instance Data.Data.Data LLVM.AST.DLL.StorageClass
instance GHC.Show.Show LLVM.AST.DLL.StorageClass
instance GHC.Read.Read LLVM.AST.DLL.StorageClass
instance GHC.Classes.Eq LLVM.AST.DLL.StorageClass


-- | Module to allow importing <a>CallingConvention</a> distinctly
--   qualified.
module LLVM.AST.CallingConvention

-- | <a>http://llvm.org/docs/LangRef.html#callingconv</a>
data CallingConvention
C :: CallingConvention
Fast :: CallingConvention
Cold :: CallingConvention
GHC :: CallingConvention
HiPE :: CallingConvention
WebKit_JS :: CallingConvention
AnyReg :: CallingConvention
PreserveMost :: CallingConvention
PreserveAll :: CallingConvention
Swift :: CallingConvention
CXX_FastTLS :: CallingConvention
X86_StdCall :: CallingConvention
X86_FastCall :: CallingConvention
ARM_APCS :: CallingConvention
ARM_AAPCS :: CallingConvention
ARM_AAPCS_VFP :: CallingConvention
MSP430_INTR :: CallingConvention
X86_ThisCall :: CallingConvention
PTX_Kernel :: CallingConvention
PTX_Device :: CallingConvention
SPIR_FUNC :: CallingConvention
SPIR_KERNEL :: CallingConvention
Intel_OCL_BI :: CallingConvention
X86_64_SysV :: CallingConvention
Win64 :: CallingConvention
X86_VectorCall :: CallingConvention
HHVM :: CallingConvention
HHVM_C :: CallingConvention
X86_Intr :: CallingConvention
AVR_Intr :: CallingConvention
AVR_Signal :: CallingConvention
AVR_Builtin :: CallingConvention
AMDGPU_VS :: CallingConvention
AMDGPU_HS :: CallingConvention
AMDGPU_GS :: CallingConvention
AMDGPU_PS :: CallingConvention
AMDGPU_CS :: CallingConvention
AMDGPU_Kernel :: CallingConvention
X86_RegCall :: CallingConvention
MSP430_Builtin :: CallingConvention
Numbered :: Word32 -> CallingConvention
instance GHC.Generics.Generic LLVM.AST.CallingConvention.CallingConvention
instance Data.Data.Data LLVM.AST.CallingConvention.CallingConvention
instance GHC.Show.Show LLVM.AST.CallingConvention.CallingConvention
instance GHC.Read.Read LLVM.AST.CallingConvention.CallingConvention
instance GHC.Classes.Eq LLVM.AST.CallingConvention.CallingConvention


-- | Module to allow importing <a>SelectionKind</a> distinctly qualified.
module LLVM.AST.COMDAT

-- | <a>http://llvm.org/docs/LangRef.html#comdats</a>
data SelectionKind
Any :: SelectionKind
ExactMatch :: SelectionKind
Largest :: SelectionKind
NoDuplicates :: SelectionKind
SameSize :: SelectionKind
instance GHC.Generics.Generic LLVM.AST.COMDAT.SelectionKind
instance Data.Data.Data LLVM.AST.COMDAT.SelectionKind
instance GHC.Show.Show LLVM.AST.COMDAT.SelectionKind
instance GHC.Read.Read LLVM.AST.COMDAT.SelectionKind
instance GHC.Classes.Eq LLVM.AST.COMDAT.SelectionKind


-- | Pointers exist in Address Spaces
module LLVM.AST.AddrSpace

-- | See <a>http://llvm.org/docs/LangRef.html#pointer-type</a>
data AddrSpace
AddrSpace :: Word32 -> AddrSpace
instance GHC.Generics.Generic LLVM.AST.AddrSpace.AddrSpace
instance Data.Data.Data LLVM.AST.AddrSpace.AddrSpace
instance GHC.Show.Show LLVM.AST.AddrSpace.AddrSpace
instance GHC.Read.Read LLVM.AST.AddrSpace.AddrSpace
instance GHC.Classes.Ord LLVM.AST.AddrSpace.AddrSpace
instance GHC.Classes.Eq LLVM.AST.AddrSpace.AddrSpace


-- | A representation of an LLVM type
module LLVM.AST.Type

-- | LLVM supports some special formats floating point format. This type is
--   to distinguish those format. Also see
--   <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
data FloatingPointType

-- | 16-bit floating point value
HalfFP :: FloatingPointType

-- | 32-bit floating point value
FloatFP :: FloatingPointType

-- | 64-bit floating point value
DoubleFP :: FloatingPointType

-- | 128-bit floating point value (112-bit mantissa)
FP128FP :: FloatingPointType

-- | 80-bit floating point value (X87)
X86_FP80FP :: FloatingPointType

-- | 128-bit floating point value (two 64-bits)
PPC_FP128FP :: FloatingPointType

-- | <a>http://llvm.org/docs/LangRef.html#type-system</a>
data Type

-- | <a>http://llvm.org/docs/LangRef.html#void-type</a>
VoidType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#integer-type</a>
IntegerType :: Word32 -> Type
[typeBits] :: Type -> Word32

-- | <a>http://llvm.org/docs/LangRef.html#pointer-type</a>
PointerType :: Type -> AddrSpace -> Type
[pointerReferent] :: Type -> Type
[pointerAddrSpace] :: Type -> AddrSpace

-- | <a>http://llvm.org/docs/LangRef.html#floating-point-types</a>
FloatingPointType :: FloatingPointType -> Type
[floatingPointType] :: Type -> FloatingPointType

-- | <a>http://llvm.org/docs/LangRef.html#function-type</a>
FunctionType :: Type -> [Type] -> Bool -> Type
[resultType] :: Type -> Type
[argumentTypes] :: Type -> [Type]
[isVarArg] :: Type -> Bool

-- | <a>http://llvm.org/docs/LangRef.html#vector-type</a>
VectorType :: Word32 -> Type -> Type
[nVectorElements] :: Type -> Word32
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#structure-type</a>
StructureType :: Bool -> [Type] -> Type
[isPacked] :: Type -> Bool
[elementTypes] :: Type -> [Type]

-- | <a>http://llvm.org/docs/LangRef.html#array-type</a>
ArrayType :: Word64 -> Type -> Type
[nArrayElements] :: Type -> Word64
[elementType] :: Type -> Type

-- | <a>http://llvm.org/docs/LangRef.html#opaque-structure-types</a>
NamedTypeReference :: Name -> Type

-- | <a>http://llvm.org/docs/LangRef.html#metadata-type</a>
MetadataType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#token-type</a>
LabelType :: Type

-- | <a>http://llvm.org/docs/LangRef.html#label-type</a>
TokenType :: Type

-- | An abbreviation for <a>VoidType</a>
void :: Type

-- | An abbreviation for <a>IntegerType</a> 1
i1 :: Type

-- | An abbreviation for <a>IntegerType</a> 8
i8 :: Type

-- | An abbreviation for <a>IntegerType</a> 16
i16 :: Type

-- | An abbreviation for <a>IntegerType</a> 32
i32 :: Type

-- | An abbreviation for <a>IntegerType</a> 64
i64 :: Type

-- | An abbreviation for <a>IntegerType</a> 128
i128 :: Type

-- | An abbreviation for <a>PointerType</a> t (<a>AddrSpace</a> 0)
ptr :: Type -> Type

-- | An abbreviation for <a>FloatingPointType</a> <a>HalfFP</a>
half :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>FloatFP</a>
float :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>DoubleFP</a>
double :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>FP128FP</a>
fp128 :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>X86_FP80FP</a>
x86_fp80 :: Type

-- | An abbreviation for <a>FloatingPointType</a> <a>PPC_FP128FP</a>
ppc_fp128 :: Type
instance GHC.Generics.Generic LLVM.AST.Type.Type
instance Data.Data.Data LLVM.AST.Type.Type
instance GHC.Show.Show LLVM.AST.Type.Type
instance GHC.Read.Read LLVM.AST.Type.Type
instance GHC.Classes.Ord LLVM.AST.Type.Type
instance GHC.Classes.Eq LLVM.AST.Type.Type
instance GHC.Generics.Generic LLVM.AST.Type.FloatingPointType
instance Data.Data.Data LLVM.AST.Type.FloatingPointType
instance GHC.Show.Show LLVM.AST.Type.FloatingPointType
instance GHC.Read.Read LLVM.AST.Type.FloatingPointType
instance GHC.Classes.Ord LLVM.AST.Type.FloatingPointType
instance GHC.Classes.Eq LLVM.AST.Type.FloatingPointType


-- | A representation of an LLVM inline assembly
module LLVM.AST.InlineAssembly

-- | the dialect of assembly used in an inline assembly string
--   <a>http://en.wikipedia.org/wiki/X86_assembly_language#Syntax</a>
data Dialect
ATTDialect :: Dialect
IntelDialect :: Dialect

-- | <a>http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a>
--   to be used through <a>CallableOperand</a> with a <a>Call</a>
--   instruction
data InlineAssembly
InlineAssembly :: Type -> ByteString -> ShortByteString -> Bool -> Bool -> Dialect -> InlineAssembly
[type'] :: InlineAssembly -> Type
[assembly] :: InlineAssembly -> ByteString
[constraints] :: InlineAssembly -> ShortByteString
[hasSideEffects] :: InlineAssembly -> Bool
[alignStack] :: InlineAssembly -> Bool
[dialect] :: InlineAssembly -> Dialect
instance GHC.Generics.Generic LLVM.AST.InlineAssembly.InlineAssembly
instance Data.Data.Data LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Show.Show LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Read.Read LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Classes.Eq LLVM.AST.InlineAssembly.InlineAssembly
instance GHC.Generics.Generic LLVM.AST.InlineAssembly.Dialect
instance Data.Data.Data LLVM.AST.InlineAssembly.Dialect
instance GHC.Show.Show LLVM.AST.InlineAssembly.Dialect
instance GHC.Read.Read LLVM.AST.InlineAssembly.Dialect
instance GHC.Classes.Eq LLVM.AST.InlineAssembly.Dialect


-- | A representation of LLVM constants
module LLVM.AST.Constant

-- | <a>http://llvm.org/docs/LangRef.html#constants</a>
--   
--   N.B. - <a>http://llvm.org/docs/LangRef.html#constant-expressions</a>
--   
--   Although constant expressions and instructions have many similarites,
--   there are important differences - so they're represented using
--   different types in this AST. At the cost of making it harder to move
--   an code back and forth between being constant and not, this approach
--   embeds more of the rules of what IR is legal into the Haskell types.
data Constant
Int :: Word32 -> Integer -> Constant
[integerBits] :: Constant -> Word32
[integerValue] :: Constant -> Integer
Float :: SomeFloat -> Constant
[floatValue] :: Constant -> SomeFloat
Null :: Type -> Constant
[constantType] :: Constant -> Type
Struct :: Maybe Name -> Bool -> [Constant] -> Constant
[structName] :: Constant -> Maybe Name
[isPacked] :: Constant -> Bool
[memberValues] :: Constant -> [Constant]
Array :: Type -> [Constant] -> Constant
[memberType] :: Constant -> Type
[memberValues] :: Constant -> [Constant]
Vector :: [Constant] -> Constant
[memberValues] :: Constant -> [Constant]
Undef :: Type -> Constant
[constantType] :: Constant -> Type
BlockAddress :: Name -> Name -> Constant
[blockAddressFunction] :: Constant -> Name
[blockAddressBlock] :: Constant -> Name
GlobalReference :: Type -> Name -> Constant
TokenNone :: Constant
Add :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FAdd :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Sub :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FSub :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Mul :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FMul :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
UDiv :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
SDiv :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FDiv :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
URem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
SRem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FRem :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Shl :: Bool -> Bool -> Constant -> Constant -> Constant
[nsw] :: Constant -> Bool
[nuw] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
LShr :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
AShr :: Bool -> Constant -> Constant -> Constant
[exact] :: Constant -> Bool
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
And :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Or :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Xor :: Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
GetElementPtr :: Bool -> Constant -> [Constant] -> Constant
[inBounds] :: Constant -> Bool
[address] :: Constant -> Constant
[indices] :: Constant -> [Constant]
Trunc :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
ZExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
SExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPToUI :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPToSI :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
UIToFP :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
SIToFP :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPTrunc :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
FPExt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
PtrToInt :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
IntToPtr :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
BitCast :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
AddrSpaceCast :: Constant -> Type -> Constant
[operand0] :: Constant -> Constant
[type'] :: Constant -> Type
ICmp :: IntegerPredicate -> Constant -> Constant -> Constant
[iPredicate] :: Constant -> IntegerPredicate
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
FCmp :: FloatingPointPredicate -> Constant -> Constant -> Constant
[fpPredicate] :: Constant -> FloatingPointPredicate
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
Select :: Constant -> Constant -> Constant -> Constant
[condition'] :: Constant -> Constant
[trueValue] :: Constant -> Constant
[falseValue] :: Constant -> Constant
ExtractElement :: Constant -> Constant -> Constant
[vector] :: Constant -> Constant
[index] :: Constant -> Constant
InsertElement :: Constant -> Constant -> Constant -> Constant
[vector] :: Constant -> Constant
[element] :: Constant -> Constant
[index] :: Constant -> Constant
ShuffleVector :: Constant -> Constant -> Constant -> Constant
[operand0] :: Constant -> Constant
[operand1] :: Constant -> Constant
[mask] :: Constant -> Constant
ExtractValue :: Constant -> [Word32] -> Constant
[aggregate] :: Constant -> Constant
[indices'] :: Constant -> [Word32]
InsertValue :: Constant -> Constant -> [Word32] -> Constant
[aggregate] :: Constant -> Constant
[element] :: Constant -> Constant
[indices'] :: Constant -> [Word32]

-- | Since LLVM types don't include signedness, there's ambiguity in
--   interpreting an constant as an Integer. The LLVM assembly printer
--   prints integers as signed, but cheats for 1-bit integers and prints
--   them as <tt>true</tt> or <tt>false</tt>. That way it circuments the
--   otherwise awkward fact that a twos complement 1-bit number only has
--   the values -1 and 0.
signedIntegerValue :: Constant -> Integer

-- | This library's conversion from LLVM C++ objects will always produce
--   integer constants as unsigned, so this function in many cases is not
--   necessary. However, nothing's to keep stop direct construction of an
--   <a>Int</a> with a negative <a>integerValue</a>. There's nothing in
--   principle wrong with such a value - it has perfectly good low order
--   bits like any integer, and will be used as such, likely producing the
--   intended result if lowered to C++. If, however one wishes to interpret
--   an <a>Int</a> of unknown provenance as unsigned, then this function
--   will serve.
unsignedIntegerValue :: Constant -> Integer
instance GHC.Generics.Generic LLVM.AST.Constant.Constant
instance Data.Data.Data LLVM.AST.Constant.Constant
instance GHC.Show.Show LLVM.AST.Constant.Constant
instance GHC.Read.Read LLVM.AST.Constant.Constant
instance GHC.Classes.Ord LLVM.AST.Constant.Constant
instance GHC.Classes.Eq LLVM.AST.Constant.Constant


-- | A type to represent operands to LLVM <a>Instruction</a>s
module LLVM.AST.Operand

-- | A <a>MetadataNodeID</a> is a number for identifying a metadata node.
--   Note this is different from "named metadata", which are represented
--   with <a>NamedMetadataDefinition</a>.
newtype MetadataNodeID
MetadataNodeID :: Word -> MetadataNodeID

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data MetadataNode
MetadataNode :: [Maybe Metadata] -> MetadataNode
MetadataNodeReference :: MetadataNodeID -> MetadataNode

-- | <a>http://llvm.org/docs/LangRef.html#metadata</a>
data Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDString :: ShortByteString -> Metadata

-- | <a>http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html</a>
MDNode :: MetadataNode -> Metadata

-- | 
--   <a>http://llvm.org/docs/doxygen/html/classllvm_1_1ValueAsMetadata.html</a>
MDValue :: Operand -> Metadata

-- | An <a>Operand</a> is roughly that which is an argument to an
--   <a>Instruction</a>
data Operand

-- | %foo
LocalReference :: Type -> Name -> Operand

-- | <a>Constant</a>s include <a>GlobalReference</a>, for @foo
ConstantOperand :: Constant -> Operand
MetadataOperand :: Metadata -> Operand

-- | The <a>Call</a> instruction is special: the callee can be inline
--   assembly
type CallableOperand = Either InlineAssembly Operand
instance GHC.Generics.Generic LLVM.AST.Operand.MetadataNode
instance Data.Data.Data LLVM.AST.Operand.MetadataNode
instance GHC.Show.Show LLVM.AST.Operand.MetadataNode
instance GHC.Read.Read LLVM.AST.Operand.MetadataNode
instance GHC.Classes.Ord LLVM.AST.Operand.MetadataNode
instance GHC.Classes.Eq LLVM.AST.Operand.MetadataNode
instance GHC.Generics.Generic LLVM.AST.Operand.Metadata
instance Data.Data.Data LLVM.AST.Operand.Metadata
instance GHC.Show.Show LLVM.AST.Operand.Metadata
instance GHC.Read.Read LLVM.AST.Operand.Metadata
instance GHC.Classes.Ord LLVM.AST.Operand.Metadata
instance GHC.Classes.Eq LLVM.AST.Operand.Metadata
instance GHC.Generics.Generic LLVM.AST.Operand.Operand
instance Data.Data.Data LLVM.AST.Operand.Operand
instance GHC.Show.Show LLVM.AST.Operand.Operand
instance GHC.Read.Read LLVM.AST.Operand.Operand
instance GHC.Classes.Ord LLVM.AST.Operand.Operand
instance GHC.Classes.Eq LLVM.AST.Operand.Operand
instance GHC.Generics.Generic LLVM.AST.Operand.MetadataNodeID
instance Data.Data.Data LLVM.AST.Operand.MetadataNodeID
instance GHC.Show.Show LLVM.AST.Operand.MetadataNodeID
instance GHC.Read.Read LLVM.AST.Operand.MetadataNodeID
instance GHC.Classes.Ord LLVM.AST.Operand.MetadataNodeID
instance GHC.Classes.Eq LLVM.AST.Operand.MetadataNodeID


-- | LLVM instructions
--   <a>http://llvm.org/docs/LangRef.html#instruction-reference</a>
module LLVM.AST.Instruction

-- | 
--   <a>http://llvm.org/docs/LangRef.html#metadata-nodes-and-metadata-strings</a>
--   Metadata can be attached to an instruction
type InstructionMetadata = [(ShortByteString, MetadataNode)]

-- | <a>http://llvm.org/docs/LangRef.html#terminators</a>
data Terminator
Ret :: Maybe Operand -> InstructionMetadata -> Terminator
[returnOperand] :: Terminator -> Maybe Operand
[metadata'] :: Terminator -> InstructionMetadata
CondBr :: Operand -> Name -> Name -> InstructionMetadata -> Terminator
[condition] :: Terminator -> Operand
[trueDest] :: Terminator -> Name
[falseDest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Br :: Name -> InstructionMetadata -> Terminator
[dest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Switch :: Operand -> Name -> [(Constant, Name)] -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[defaultDest] :: Terminator -> Name
[dests] :: Terminator -> [(Constant, Name)]
[metadata'] :: Terminator -> InstructionMetadata
IndirectBr :: Operand -> [Name] -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[possibleDests] :: Terminator -> [Name]
[metadata'] :: Terminator -> InstructionMetadata
Invoke :: CallingConvention -> [ParameterAttribute] -> CallableOperand -> [(Operand, [ParameterAttribute])] -> [Either GroupID FunctionAttribute] -> Name -> Name -> InstructionMetadata -> Terminator
[callingConvention'] :: Terminator -> CallingConvention
[returnAttributes'] :: Terminator -> [ParameterAttribute]
[function'] :: Terminator -> CallableOperand
[arguments'] :: Terminator -> [(Operand, [ParameterAttribute])]
[functionAttributes'] :: Terminator -> [Either GroupID FunctionAttribute]
[returnDest] :: Terminator -> Name
[exceptionDest] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
Resume :: Operand -> InstructionMetadata -> Terminator
[operand0'] :: Terminator -> Operand
[metadata'] :: Terminator -> InstructionMetadata
Unreachable :: InstructionMetadata -> Terminator
[metadata'] :: Terminator -> InstructionMetadata
CleanupRet :: Operand -> Maybe Name -> InstructionMetadata -> Terminator
[cleanupPad] :: Terminator -> Operand
[unwindDest] :: Terminator -> Maybe Name
[metadata'] :: Terminator -> InstructionMetadata
CatchRet :: Operand -> Name -> InstructionMetadata -> Terminator
[catchPad] :: Terminator -> Operand
[successor] :: Terminator -> Name
[metadata'] :: Terminator -> InstructionMetadata
CatchSwitch :: Operand -> NonEmpty Name -> Maybe Name -> InstructionMetadata -> Terminator
[parentPad'] :: Terminator -> Operand
[catchHandlers] :: Terminator -> NonEmpty Name
[defaultUnwindDest] :: Terminator -> Maybe Name
[metadata'] :: Terminator -> InstructionMetadata

-- | <a>http://llvm.org/docs/LangRef.html#fast-math-flags</a>
data FastMathFlags
NoFastMathFlags :: FastMathFlags
UnsafeAlgebra :: FastMathFlags
FastMathFlags :: Bool -> Bool -> Bool -> Bool -> FastMathFlags
[noNaNs] :: FastMathFlags -> Bool
[noInfs] :: FastMathFlags -> Bool
[noSignedZeros] :: FastMathFlags -> Bool
[allowReciprocal] :: FastMathFlags -> Bool

-- | 
--   <a>http://llvm.org/docs/LangRef.html#atomic-memory-ordering-constraints</a>
--   <a>http://llvm.org/docs/Atomics.html</a>
data MemoryOrdering
Unordered :: MemoryOrdering
Monotonic :: MemoryOrdering
Acquire :: MemoryOrdering
Release :: MemoryOrdering
AcquireRelease :: MemoryOrdering
SequentiallyConsistent :: MemoryOrdering

-- | <a>http://llvm.org/docs/LangRef.html#singlethread</a>
data SynchronizationScope
SingleThread :: SynchronizationScope
System :: SynchronizationScope

-- | An <a>Atomicity</a> describes constraints on the visibility of effects
--   of an atomic instruction
type Atomicity = (SynchronizationScope, MemoryOrdering)

-- | For the redoubtably complex <a>LandingPad</a> instruction
data LandingPadClause
Catch :: Constant -> LandingPadClause
Filter :: Constant -> LandingPadClause

-- | For the call instruction
--   <a>http://llvm.org/docs/LangRef.html#call-instruction</a>
data TailCallKind
Tail :: TailCallKind
MustTail :: TailCallKind
NoTail :: TailCallKind

-- | non-terminator instructions:
--   <a>http://llvm.org/docs/LangRef.html#binaryops</a>
--   <a>http://llvm.org/docs/LangRef.html#bitwiseops</a>
--   <a>http://llvm.org/docs/LangRef.html#memoryops</a>
--   <a>http://llvm.org/docs/LangRef.html#otherops</a>
data Instruction
Add :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FAdd :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Sub :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FSub :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Mul :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FMul :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
UDiv :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
SDiv :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FDiv :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
URem :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
SRem :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FRem :: FastMathFlags -> Operand -> Operand -> InstructionMetadata -> Instruction
[fastMathFlags] :: Instruction -> FastMathFlags
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Shl :: Bool -> Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[nsw] :: Instruction -> Bool
[nuw] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
LShr :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
AShr :: Bool -> Operand -> Operand -> InstructionMetadata -> Instruction
[exact] :: Instruction -> Bool
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
And :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Or :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Xor :: Operand -> Operand -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Alloca :: Type -> Maybe Operand -> Word32 -> InstructionMetadata -> Instruction
[allocatedType] :: Instruction -> Type
[numElements] :: Instruction -> Maybe Operand
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
Load :: Bool -> Operand -> Maybe Atomicity -> Word32 -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[maybeAtomicity] :: Instruction -> Maybe Atomicity
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
Store :: Bool -> Operand -> Operand -> Maybe Atomicity -> Word32 -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[value] :: Instruction -> Operand
[maybeAtomicity] :: Instruction -> Maybe Atomicity
[alignment] :: Instruction -> Word32
[metadata] :: Instruction -> InstructionMetadata
GetElementPtr :: Bool -> Operand -> [Operand] -> InstructionMetadata -> Instruction
[inBounds] :: Instruction -> Bool
[address] :: Instruction -> Operand
[indices] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata
Fence :: Atomicity -> InstructionMetadata -> Instruction
[atomicity] :: Instruction -> Atomicity
[metadata] :: Instruction -> InstructionMetadata
CmpXchg :: Bool -> Operand -> Operand -> Operand -> Atomicity -> MemoryOrdering -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[address] :: Instruction -> Operand
[expected] :: Instruction -> Operand
[replacement] :: Instruction -> Operand
[atomicity] :: Instruction -> Atomicity
[failureMemoryOrdering] :: Instruction -> MemoryOrdering
[metadata] :: Instruction -> InstructionMetadata
AtomicRMW :: Bool -> RMWOperation -> Operand -> Operand -> Atomicity -> InstructionMetadata -> Instruction
[volatile] :: Instruction -> Bool
[rmwOperation] :: Instruction -> RMWOperation
[address] :: Instruction -> Operand
[value] :: Instruction -> Operand
[atomicity] :: Instruction -> Atomicity
[metadata] :: Instruction -> InstructionMetadata
Trunc :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ZExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
SExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPToUI :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPToSI :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
UIToFP :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
SIToFP :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPTrunc :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
FPExt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
PtrToInt :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
IntToPtr :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
BitCast :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
AddrSpaceCast :: Operand -> Type -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ICmp :: IntegerPredicate -> Operand -> Operand -> InstructionMetadata -> Instruction
[iPredicate] :: Instruction -> IntegerPredicate
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
FCmp :: FloatingPointPredicate -> Operand -> Operand -> InstructionMetadata -> Instruction
[fpPredicate] :: Instruction -> FloatingPointPredicate
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
Phi :: Type -> [(Operand, Name)] -> InstructionMetadata -> Instruction
[type'] :: Instruction -> Type
[incomingValues] :: Instruction -> [(Operand, Name)]
[metadata] :: Instruction -> InstructionMetadata
Call :: Maybe TailCallKind -> CallingConvention -> [ParameterAttribute] -> CallableOperand -> [(Operand, [ParameterAttribute])] -> [Either GroupID FunctionAttribute] -> InstructionMetadata -> Instruction
[tailCallKind] :: Instruction -> Maybe TailCallKind
[callingConvention] :: Instruction -> CallingConvention
[returnAttributes] :: Instruction -> [ParameterAttribute]
[function] :: Instruction -> CallableOperand
[arguments] :: Instruction -> [(Operand, [ParameterAttribute])]
[functionAttributes] :: Instruction -> [Either GroupID FunctionAttribute]
[metadata] :: Instruction -> InstructionMetadata
Select :: Operand -> Operand -> Operand -> InstructionMetadata -> Instruction
[condition'] :: Instruction -> Operand
[trueValue] :: Instruction -> Operand
[falseValue] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
VAArg :: Operand -> Type -> InstructionMetadata -> Instruction
[argList] :: Instruction -> Operand
[type'] :: Instruction -> Type
[metadata] :: Instruction -> InstructionMetadata
ExtractElement :: Operand -> Operand -> InstructionMetadata -> Instruction
[vector] :: Instruction -> Operand
[index] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
InsertElement :: Operand -> Operand -> Operand -> InstructionMetadata -> Instruction
[vector] :: Instruction -> Operand
[element] :: Instruction -> Operand
[index] :: Instruction -> Operand
[metadata] :: Instruction -> InstructionMetadata
ShuffleVector :: Operand -> Operand -> Constant -> InstructionMetadata -> Instruction
[operand0] :: Instruction -> Operand
[operand1] :: Instruction -> Operand
[mask] :: Instruction -> Constant
[metadata] :: Instruction -> InstructionMetadata
ExtractValue :: Operand -> [Word32] -> InstructionMetadata -> Instruction
[aggregate] :: Instruction -> Operand
[indices'] :: Instruction -> [Word32]
[metadata] :: Instruction -> InstructionMetadata
InsertValue :: Operand -> Operand -> [Word32] -> InstructionMetadata -> Instruction
[aggregate] :: Instruction -> Operand
[element] :: Instruction -> Operand
[indices'] :: Instruction -> [Word32]
[metadata] :: Instruction -> InstructionMetadata
LandingPad :: Type -> Bool -> [LandingPadClause] -> InstructionMetadata -> Instruction
[type'] :: Instruction -> Type
[cleanup] :: Instruction -> Bool
[clauses] :: Instruction -> [LandingPadClause]
[metadata] :: Instruction -> InstructionMetadata
CatchPad :: Operand -> [Operand] -> InstructionMetadata -> Instruction
[catchSwitch] :: Instruction -> Operand
[args] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata
CleanupPad :: Operand -> [Operand] -> InstructionMetadata -> Instruction
[parentPad] :: Instruction -> Operand
[args] :: Instruction -> [Operand]
[metadata] :: Instruction -> InstructionMetadata

-- | Instances of instructions may be given a name, allowing their results
--   to be referenced as <a>Operand</a>s. Sometimes instructions - e.g. a
--   call to a function returning void - don't need names.
data Named a
(:=) :: Name -> a -> Named a
Do :: a -> Named a
instance GHC.Generics.Generic (LLVM.AST.Instruction.Named a)
instance Data.Data.Data a => Data.Data.Data (LLVM.AST.Instruction.Named a)
instance GHC.Show.Show a => GHC.Show.Show (LLVM.AST.Instruction.Named a)
instance GHC.Read.Read a => GHC.Read.Read (LLVM.AST.Instruction.Named a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LLVM.AST.Instruction.Named a)
instance GHC.Generics.Generic LLVM.AST.Instruction.Instruction
instance Data.Data.Data LLVM.AST.Instruction.Instruction
instance GHC.Show.Show LLVM.AST.Instruction.Instruction
instance GHC.Read.Read LLVM.AST.Instruction.Instruction
instance GHC.Classes.Eq LLVM.AST.Instruction.Instruction
instance GHC.Generics.Generic LLVM.AST.Instruction.TailCallKind
instance Data.Data.Data LLVM.AST.Instruction.TailCallKind
instance GHC.Show.Show LLVM.AST.Instruction.TailCallKind
instance GHC.Read.Read LLVM.AST.Instruction.TailCallKind
instance GHC.Classes.Ord LLVM.AST.Instruction.TailCallKind
instance GHC.Classes.Eq LLVM.AST.Instruction.TailCallKind
instance GHC.Generics.Generic LLVM.AST.Instruction.LandingPadClause
instance Data.Data.Data LLVM.AST.Instruction.LandingPadClause
instance GHC.Show.Show LLVM.AST.Instruction.LandingPadClause
instance GHC.Read.Read LLVM.AST.Instruction.LandingPadClause
instance GHC.Classes.Ord LLVM.AST.Instruction.LandingPadClause
instance GHC.Classes.Eq LLVM.AST.Instruction.LandingPadClause
instance GHC.Generics.Generic LLVM.AST.Instruction.SynchronizationScope
instance Data.Data.Data LLVM.AST.Instruction.SynchronizationScope
instance GHC.Show.Show LLVM.AST.Instruction.SynchronizationScope
instance GHC.Read.Read LLVM.AST.Instruction.SynchronizationScope
instance GHC.Classes.Ord LLVM.AST.Instruction.SynchronizationScope
instance GHC.Classes.Eq LLVM.AST.Instruction.SynchronizationScope
instance GHC.Generics.Generic LLVM.AST.Instruction.MemoryOrdering
instance Data.Data.Data LLVM.AST.Instruction.MemoryOrdering
instance GHC.Show.Show LLVM.AST.Instruction.MemoryOrdering
instance GHC.Read.Read LLVM.AST.Instruction.MemoryOrdering
instance GHC.Classes.Ord LLVM.AST.Instruction.MemoryOrdering
instance GHC.Classes.Eq LLVM.AST.Instruction.MemoryOrdering
instance GHC.Generics.Generic LLVM.AST.Instruction.FastMathFlags
instance Data.Data.Data LLVM.AST.Instruction.FastMathFlags
instance GHC.Show.Show LLVM.AST.Instruction.FastMathFlags
instance GHC.Read.Read LLVM.AST.Instruction.FastMathFlags
instance GHC.Classes.Ord LLVM.AST.Instruction.FastMathFlags
instance GHC.Classes.Eq LLVM.AST.Instruction.FastMathFlags
instance GHC.Generics.Generic LLVM.AST.Instruction.Terminator
instance Data.Data.Data LLVM.AST.Instruction.Terminator
instance GHC.Show.Show LLVM.AST.Instruction.Terminator
instance GHC.Read.Read LLVM.AST.Instruction.Terminator
instance GHC.Classes.Eq LLVM.AST.Instruction.Terminator


-- | <a>Global</a>s - top-level values in <tt>Module</tt>s - and supporting
--   structures.
module LLVM.AST.Global

-- | <a>http://llvm.org/doxygen/classllvm_1_1GlobalValue.html</a>
data Global

-- | <a>http://llvm.org/docs/LangRef.html#global-variables</a>
GlobalVariable :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Bool -> Type -> AddrSpace -> Maybe Constant -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Global
[name] :: Global -> Name
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[threadLocalMode] :: Global -> Maybe Model
[unnamedAddr] :: Global -> Maybe UnnamedAddr
[isConstant] :: Global -> Bool
[type'] :: Global -> Type
[addrSpace] :: Global -> AddrSpace
[initializer] :: Global -> Maybe Constant
[section] :: Global -> Maybe ShortByteString
[comdat] :: Global -> Maybe ShortByteString
[alignment] :: Global -> Word32

-- | <a>http://llvm.org/docs/LangRef.html#aliases</a>
GlobalAlias :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Type -> AddrSpace -> Constant -> Global
[name] :: Global -> Name
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[threadLocalMode] :: Global -> Maybe Model
[unnamedAddr] :: Global -> Maybe UnnamedAddr
[type'] :: Global -> Type
[addrSpace] :: Global -> AddrSpace
[aliasee] :: Global -> Constant

-- | <a>http://llvm.org/docs/LangRef.html#functions</a>
Function :: Linkage -> Visibility -> Maybe StorageClass -> CallingConvention -> [ParameterAttribute] -> Type -> Name -> ([Parameter], Bool) -> [Either GroupID FunctionAttribute] -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Maybe ShortByteString -> Maybe Constant -> [BasicBlock] -> Maybe Constant -> Global
[linkage] :: Global -> Linkage
[visibility] :: Global -> Visibility
[dllStorageClass] :: Global -> Maybe StorageClass
[callingConvention] :: Global -> CallingConvention
[returnAttributes] :: Global -> [ParameterAttribute]
[returnType] :: Global -> Type
[name] :: Global -> Name

-- | snd indicates varargs
[parameters] :: Global -> ([Parameter], Bool)
[functionAttributes] :: Global -> [Either GroupID FunctionAttribute]
[section] :: Global -> Maybe ShortByteString
[comdat] :: Global -> Maybe ShortByteString
[alignment] :: Global -> Word32
[garbageCollectorName] :: Global -> Maybe ShortByteString
[prefix] :: Global -> Maybe Constant
[basicBlocks] :: Global -> [BasicBlock]
[personalityFunction] :: Global -> Maybe Constant

-- | <a>Parameter</a>s for <a>Function</a>s
data Parameter
Parameter :: Type -> Name -> [ParameterAttribute] -> Parameter

-- | <a>http://llvm.org/doxygen/classllvm_1_1BasicBlock.html</a> LLVM code
--   in a function is a sequence of <a>BasicBlock</a>s each with a label,
--   some instructions, and a terminator.
data BasicBlock
BasicBlock :: Name -> [Named Instruction] -> (Named Terminator) -> BasicBlock
data UnnamedAddr
LocalAddr :: UnnamedAddr
GlobalAddr :: UnnamedAddr

-- | helper for making <a>GlobalVariable</a>s
globalVariableDefaults :: Global

-- | helper for making <a>GlobalAlias</a>s
globalAliasDefaults :: Global

-- | helper for making <a>Function</a>s
functionDefaults :: Global
instance GHC.Generics.Generic LLVM.AST.Global.Global
instance Data.Data.Data LLVM.AST.Global.Global
instance GHC.Show.Show LLVM.AST.Global.Global
instance GHC.Read.Read LLVM.AST.Global.Global
instance GHC.Classes.Eq LLVM.AST.Global.Global
instance GHC.Generics.Generic LLVM.AST.Global.UnnamedAddr
instance Data.Data.Data LLVM.AST.Global.UnnamedAddr
instance GHC.Show.Show LLVM.AST.Global.UnnamedAddr
instance GHC.Read.Read LLVM.AST.Global.UnnamedAddr
instance GHC.Classes.Eq LLVM.AST.Global.UnnamedAddr
instance GHC.Generics.Generic LLVM.AST.Global.BasicBlock
instance Data.Data.Data LLVM.AST.Global.BasicBlock
instance GHC.Show.Show LLVM.AST.Global.BasicBlock
instance GHC.Read.Read LLVM.AST.Global.BasicBlock
instance GHC.Classes.Eq LLVM.AST.Global.BasicBlock
instance GHC.Generics.Generic LLVM.AST.Global.Parameter
instance Data.Data.Data LLVM.AST.Global.Parameter
instance GHC.Show.Show LLVM.AST.Global.Parameter
instance GHC.Read.Read LLVM.AST.Global.Parameter
instance GHC.Classes.Eq LLVM.AST.Global.Parameter


-- | <a>http://llvm.org/docs/LangRef.html#data-layout</a>
module LLVM.AST.DataLayout

-- | Little Endian is the one true way :-). Sadly, we must support the
--   infidels.
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness

-- | An AlignmentInfo describes how a given type must and would best be
--   aligned
data AlignmentInfo
AlignmentInfo :: Word32 -> Word32 -> AlignmentInfo
[abiAlignment] :: AlignmentInfo -> Word32
[preferredAlignment] :: AlignmentInfo -> Word32

-- | A type of type for which <a>AlignmentInfo</a> may be specified
data AlignType
IntegerAlign :: AlignType
VectorAlign :: AlignType
FloatAlign :: AlignType

-- | A style of name mangling
data Mangling
ELFMangling :: Mangling
MIPSMangling :: Mangling
MachOMangling :: Mangling
WindowsCOFFMangling :: Mangling

-- | a description of the various data layout properties which may be used
--   during optimization
data DataLayout
DataLayout :: Endianness -> Maybe Mangling -> Maybe Word32 -> Map AddrSpace (Word32, AlignmentInfo) -> Map (AlignType, Word32) AlignmentInfo -> AlignmentInfo -> Maybe (Set Word32) -> DataLayout
[endianness] :: DataLayout -> Endianness
[mangling] :: DataLayout -> Maybe Mangling
[stackAlignment] :: DataLayout -> Maybe Word32
[pointerLayouts] :: DataLayout -> Map AddrSpace (Word32, AlignmentInfo)
[typeLayouts] :: DataLayout -> Map (AlignType, Word32) AlignmentInfo
[aggregateLayout] :: DataLayout -> AlignmentInfo
[nativeSizes] :: DataLayout -> Maybe (Set Word32)

-- | a default <a>DataLayout</a>
defaultDataLayout :: Endianness -> DataLayout
instance GHC.Generics.Generic LLVM.AST.DataLayout.DataLayout
instance Data.Data.Data LLVM.AST.DataLayout.DataLayout
instance GHC.Show.Show LLVM.AST.DataLayout.DataLayout
instance GHC.Read.Read LLVM.AST.DataLayout.DataLayout
instance GHC.Classes.Ord LLVM.AST.DataLayout.DataLayout
instance GHC.Classes.Eq LLVM.AST.DataLayout.DataLayout
instance GHC.Generics.Generic LLVM.AST.DataLayout.Mangling
instance Data.Data.Data LLVM.AST.DataLayout.Mangling
instance GHC.Show.Show LLVM.AST.DataLayout.Mangling
instance GHC.Read.Read LLVM.AST.DataLayout.Mangling
instance GHC.Classes.Ord LLVM.AST.DataLayout.Mangling
instance GHC.Classes.Eq LLVM.AST.DataLayout.Mangling
instance GHC.Generics.Generic LLVM.AST.DataLayout.AlignType
instance Data.Data.Data LLVM.AST.DataLayout.AlignType
instance GHC.Show.Show LLVM.AST.DataLayout.AlignType
instance GHC.Read.Read LLVM.AST.DataLayout.AlignType
instance GHC.Classes.Ord LLVM.AST.DataLayout.AlignType
instance GHC.Classes.Eq LLVM.AST.DataLayout.AlignType
instance GHC.Generics.Generic LLVM.AST.DataLayout.AlignmentInfo
instance Data.Data.Data LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Show.Show LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Read.Read LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Classes.Ord LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Classes.Eq LLVM.AST.DataLayout.AlignmentInfo
instance GHC.Generics.Generic LLVM.AST.DataLayout.Endianness
instance Data.Data.Data LLVM.AST.DataLayout.Endianness
instance GHC.Show.Show LLVM.AST.DataLayout.Endianness
instance GHC.Read.Read LLVM.AST.DataLayout.Endianness
instance GHC.Classes.Ord LLVM.AST.DataLayout.Endianness
instance GHC.Classes.Eq LLVM.AST.DataLayout.Endianness

module LLVM.DataLayout
dataLayoutToString :: DataLayout -> ByteString

-- | Parse a <a>DataLayout</a>, given a default Endianness should one not
--   be specified in the string to be parsed. LLVM itself uses BigEndian as
--   the default: thus pass BigEndian to be conformant or LittleEndian to
--   be righteously defiant.
parseDataLayout :: Endianness -> ByteString -> Except String (Maybe DataLayout)


-- | This module and descendants define AST data types to represent LLVM
--   code. Note that these types are designed for fidelity rather than
--   convenience - if the truth of what LLVM supports is less than pretty,
--   so be it.
module LLVM.AST

-- | <a>http://llvm.org/docs/LangRef.html#module-structure</a>
data Module
Module :: ShortByteString -> ShortByteString -> Maybe DataLayout -> Maybe ShortByteString -> [Definition] -> Module
[moduleName] :: Module -> ShortByteString
[moduleSourceFileName] :: Module -> ShortByteString

-- | a <a>DataLayout</a>, if specified, must match that of the eventual
--   code generator
[moduleDataLayout] :: Module -> Maybe DataLayout
[moduleTargetTriple] :: Module -> Maybe ShortByteString
[moduleDefinitions] :: Module -> [Definition]

-- | helper for making <a>Module</a>s
defaultModule :: Module

-- | Any thing which can be at the top level of a <a>Module</a>
data Definition
GlobalDefinition :: Global -> Definition
TypeDefinition :: Name -> (Maybe Type) -> Definition
MetadataNodeDefinition :: MetadataNodeID -> [Maybe Metadata] -> Definition
NamedMetadataDefinition :: ShortByteString -> [MetadataNodeID] -> Definition
ModuleInlineAssembly :: ByteString -> Definition
FunctionAttributes :: GroupID -> [FunctionAttribute] -> Definition
COMDAT :: ShortByteString -> SelectionKind -> Definition

-- | <a>http://llvm.org/doxygen/classllvm_1_1GlobalValue.html</a>
data Global

-- | <a>http://llvm.org/docs/LangRef.html#global-variables</a>
GlobalVariable :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Bool -> Type -> AddrSpace -> Maybe Constant -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Global

-- | <a>http://llvm.org/docs/LangRef.html#aliases</a>
GlobalAlias :: Name -> Linkage -> Visibility -> Maybe StorageClass -> Maybe Model -> Maybe UnnamedAddr -> Type -> AddrSpace -> Constant -> Global

-- | <a>http://llvm.org/docs/LangRef.html#functions</a>
Function :: Linkage -> Visibility -> Maybe StorageClass -> CallingConvention -> [ParameterAttribute] -> Type -> Name -> ([Parameter], Bool) -> [Either GroupID FunctionAttribute] -> Maybe ShortByteString -> Maybe ShortByteString -> Word32 -> Maybe ShortByteString -> Maybe Constant -> [BasicBlock] -> Maybe Constant -> Global

-- | helper for making <a>GlobalVariable</a>s
globalVariableDefaults :: Global

-- | helper for making <a>GlobalAlias</a>s
globalAliasDefaults :: Global

-- | helper for making <a>Function</a>s
functionDefaults :: Global
data UnnamedAddr
LocalAddr :: UnnamedAddr
GlobalAddr :: UnnamedAddr

-- | <a>Parameter</a>s for <a>Function</a>s
data Parameter
Parameter :: Type -> Name -> [ParameterAttribute] -> Parameter

-- | <a>http://llvm.org/doxygen/classllvm_1_1BasicBlock.html</a> LLVM code
--   in a function is a sequence of <a>BasicBlock</a>s each with a label,
--   some instructions, and a terminator.
data BasicBlock
BasicBlock :: Name -> [Named Instruction] -> (Named Terminator) -> BasicBlock
instance GHC.Generics.Generic LLVM.AST.Module
instance Data.Data.Data LLVM.AST.Module
instance GHC.Show.Show LLVM.AST.Module
instance GHC.Read.Read LLVM.AST.Module
instance GHC.Classes.Eq LLVM.AST.Module
instance GHC.Generics.Generic LLVM.AST.Definition
instance Data.Data.Data LLVM.AST.Definition
instance GHC.Show.Show LLVM.AST.Definition
instance GHC.Read.Read LLVM.AST.Definition
instance GHC.Classes.Eq LLVM.AST.Definition

module LLVM.IRBuilder.Monad

-- | This provides a uniform API for creating instructions and inserting
--   them into a basic block: either at the end of a BasicBlock, or at a
--   specific location in a block.
newtype IRBuilderT m a
IRBuilderT :: StateT IRBuilderState m a -> IRBuilderT m a
[unIRBuilderT] :: IRBuilderT m a -> StateT IRBuilderState m a
type IRBuilder = IRBuilderT Identity
class Monad m => MonadIRBuilder m
liftIRState :: MonadIRBuilder m => State IRBuilderState a -> m a
liftIRState :: (MonadIRBuilder m, MonadTrans t, MonadIRBuilder m1, m ~ t m1) => State IRBuilderState a -> m a

-- | A partially constructed block as a sequence of instructions
data PartialBlock
PartialBlock :: !Name -> SnocList (Named Instruction) -> Maybe (Named Terminator) -> PartialBlock
[partialBlockName] :: PartialBlock -> !Name
[partialBlockInstrs] :: PartialBlock -> SnocList (Named Instruction)
[partialBlockTerm] :: PartialBlock -> Maybe (Named Terminator)
emptyPartialBlock :: Name -> PartialBlock

-- | Builder monad state
data IRBuilderState
IRBuilderState :: !Word -> !(HashSet ShortByteString) -> !(Maybe ShortByteString) -> SnocList BasicBlock -> !(Maybe PartialBlock) -> IRBuilderState
[builderSupply] :: IRBuilderState -> !Word
[builderUsedNames] :: IRBuilderState -> !(HashSet ShortByteString)
[builderNameSuggestion] :: IRBuilderState -> !(Maybe ShortByteString)
[builderBlocks] :: IRBuilderState -> SnocList BasicBlock
[builderBlock] :: IRBuilderState -> !(Maybe PartialBlock)
emptyIRBuilder :: IRBuilderState

-- | Evaluate IRBuilder to a result and a list of basic blocks
runIRBuilder :: IRBuilderState -> IRBuilder a -> (a, [BasicBlock])

-- | Evaluate IRBuilderT to a result and a list of basic blocks
runIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m (a, [BasicBlock])

-- | Evaluate IRBuilder to a list of basic blocks
execIRBuilder :: IRBuilderState -> IRBuilder a -> [BasicBlock]

-- | Evaluate IRBuilderT to a list of basic blocks
execIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m [BasicBlock]
modifyBlock :: MonadIRBuilder m => (PartialBlock -> PartialBlock) -> m ()

-- | Generate a fresh name. The resulting name is numbered or based on the
--   name suggested with <a>named</a> if that's used.
fresh :: MonadIRBuilder m => m Name

-- | Generate a fresh name from a name suggestion
freshName :: MonadIRBuilder m => ShortByteString -> m Name

-- | Generate a fresh numbered name
freshUnName :: MonadIRBuilder m => m Name

-- | Emit instruction
emitInstr :: MonadIRBuilder m => Type -> Instruction -> m Operand

-- | Emit instruction that returns void
emitInstrVoid :: MonadIRBuilder m => Instruction -> m ()

-- | Emit terminator
emitTerm :: MonadIRBuilder m => Terminator -> m ()

-- | Starts a new block labelled using the given name and ends the previous
--   one. The name is assumed to be fresh.
emitBlockStart :: MonadIRBuilder m => Name -> m ()

-- | Starts a new block and ends the previous one
block :: MonadIRBuilder m => m Name

-- | <tt>ir <a>named</a> name</tt> executes the <a>IRBuilder</a>
--   <tt>ir</tt> using <tt>name</tt> as the base name whenever a fresh
--   local name is generated. Collisions are avoided by appending numbers
--   (first <tt>"name"</tt>, then <tt>"name1"</tt>, <tt>"name2"</tt>, and
--   so on).
named :: MonadIRBuilder m => m r -> ShortByteString -> m r
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Trans.Class.MonadTrans LLVM.IRBuilder.Monad.IRBuilderT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Monad (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Functor m => GHC.Base.Functor (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (LLVM.IRBuilder.Monad.IRBuilderT m)
instance GHC.Base.Monad m => LLVM.IRBuilder.Monad.MonadIRBuilder (LLVM.IRBuilder.Monad.IRBuilderT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (LLVM.IRBuilder.Monad.IRBuilderT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Cont.ContT r m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Except.ExceptT e m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Identity.IdentityT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.List.ListT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Maybe.MaybeT m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Reader.ReaderT r m)
instance (LLVM.IRBuilder.Monad.MonadIRBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (LLVM.IRBuilder.Monad.MonadIRBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.State.Strict.StateT s m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Monad.MonadIRBuilder m) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Monad.MonadIRBuilder m) => LLVM.IRBuilder.Monad.MonadIRBuilder (Control.Monad.Trans.Writer.Lazy.WriterT w m)

module LLVM.IRBuilder.Module
newtype ModuleBuilderT m a
ModuleBuilderT :: StateT ModuleBuilderState m a -> ModuleBuilderT m a
[unModuleBuilderT] :: ModuleBuilderT m a -> StateT ModuleBuilderState m a
newtype ModuleBuilderState
ModuleBuilderState :: SnocList Definition -> ModuleBuilderState
[builderDefs] :: ModuleBuilderState -> SnocList Definition
emptyModuleBuilder :: ModuleBuilderState
type ModuleBuilder = ModuleBuilderT Identity
class Monad m => MonadModuleBuilder m
liftModuleState :: MonadModuleBuilder m => State ModuleBuilderState a -> m a
liftModuleState :: (MonadModuleBuilder m, MonadTrans t, MonadModuleBuilder m1, m ~ t m1) => State ModuleBuilderState a -> m a

-- | Evaluate <a>ModuleBuilder</a> to a result and a list of definitions
runModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> (a, [Definition])

-- | Evaluate <a>ModuleBuilderT</a> to a result and a list of definitions
runModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m (a, [Definition])

-- | Evaluate <a>ModuleBuilder</a> to a list of definitions
execModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> [Definition]

-- | Evaluate <a>ModuleBuilderT</a> to a list of definitions
execModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m [Definition]
emitDefn :: MonadModuleBuilder m => Definition -> m ()

-- | A parameter name suggestion
data ParameterName
NoParameterName :: ParameterName
ParameterName :: ShortByteString -> ParameterName

-- | Using <a>fromString</a> on non-ASCII strings will throw an error.

-- | Define and emit a (non-variadic) function definition
function :: MonadModuleBuilder m => Name -> [(Type, ParameterName)] -> Type -> ([Operand] -> IRBuilderT m ()) -> m Operand

-- | An external function definition
extern :: MonadModuleBuilder m => Name -> [Type] -> Type -> m Operand

-- | A named type definition
typedef :: MonadModuleBuilder m => Name -> Maybe Type -> m ()

-- | Convenience function for module construction
buildModule :: ShortByteString -> ModuleBuilder a -> Module

-- | Convenience function for module construction (transformer version)
buildModuleT :: Monad m => ShortByteString -> ModuleBuilderT m a -> m Module
instance GHC.Generics.Generic LLVM.IRBuilder.Module.ParameterName
instance Data.Data.Data LLVM.IRBuilder.Module.ParameterName
instance GHC.Show.Show LLVM.IRBuilder.Module.ParameterName
instance GHC.Read.Read LLVM.IRBuilder.Module.ParameterName
instance GHC.Classes.Ord LLVM.IRBuilder.Module.ParameterName
instance GHC.Classes.Eq LLVM.IRBuilder.Module.ParameterName
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Trans.Class.MonadTrans LLVM.IRBuilder.Module.ModuleBuilderT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Monad (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance GHC.Base.Functor m => GHC.Base.Functor (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Data.String.IsString LLVM.IRBuilder.Module.ParameterName
instance GHC.Base.Monad m => LLVM.IRBuilder.Module.MonadModuleBuilder (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Cont.ContT r m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Except.ExceptT e m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Identity.IdentityT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.List.ListT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Maybe.MaybeT m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Reader.ReaderT r m)
instance (LLVM.IRBuilder.Module.MonadModuleBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (LLVM.IRBuilder.Module.MonadModuleBuilder m, GHC.Base.Monoid w) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.State.Strict.StateT s m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Module.MonadModuleBuilder m) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, LLVM.IRBuilder.Module.MonadModuleBuilder m) => LLVM.IRBuilder.Module.MonadModuleBuilder (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (LLVM.IRBuilder.Module.ModuleBuilderT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (LLVM.IRBuilder.Module.ModuleBuilderT m)


-- | Querying the type of LLVM expressions
module LLVM.AST.Typed
class Typed a
typeOf :: Typed a => a -> Type
getElementType :: Type -> Type
getElementPtrType :: Type -> [Constant] -> Type
extractValueType :: [Word32] -> Type -> Type
instance LLVM.AST.Typed.Typed LLVM.AST.Operand.Operand
instance LLVM.AST.Typed.Typed LLVM.AST.Operand.CallableOperand
instance LLVM.AST.Typed.Typed LLVM.AST.Constant.Constant
instance LLVM.AST.Typed.Typed LLVM.AST.Float.SomeFloat
instance LLVM.AST.Typed.Typed LLVM.AST.Global.Global
instance LLVM.AST.Typed.Typed LLVM.AST.Global.Parameter

module LLVM.IRBuilder.Instruction
fadd :: MonadIRBuilder m => Operand -> Operand -> m Operand
fmul :: MonadIRBuilder m => Operand -> Operand -> m Operand
fsub :: MonadIRBuilder m => Operand -> Operand -> m Operand
fdiv :: MonadIRBuilder m => Operand -> Operand -> m Operand
frem :: MonadIRBuilder m => Operand -> Operand -> m Operand
add :: MonadIRBuilder m => Operand -> Operand -> m Operand
mul :: MonadIRBuilder m => Operand -> Operand -> m Operand
sub :: MonadIRBuilder m => Operand -> Operand -> m Operand
udiv :: MonadIRBuilder m => Operand -> Operand -> m Operand
sdiv :: MonadIRBuilder m => Operand -> Operand -> m Operand
urem :: MonadIRBuilder m => Operand -> Operand -> m Operand
shl :: MonadIRBuilder m => Operand -> Operand -> m Operand
lshr :: MonadIRBuilder m => Operand -> Operand -> m Operand
ashr :: MonadIRBuilder m => Operand -> Operand -> m Operand
and :: MonadIRBuilder m => Operand -> Operand -> m Operand
or :: MonadIRBuilder m => Operand -> Operand -> m Operand
xor :: MonadIRBuilder m => Operand -> Operand -> m Operand
alloca :: MonadIRBuilder m => Type -> Maybe Operand -> Word32 -> m Operand
load :: MonadIRBuilder m => Operand -> Word32 -> m Operand
store :: MonadIRBuilder m => Operand -> Word32 -> Operand -> m ()
gep :: MonadIRBuilder m => Operand -> [Operand] -> m Operand
trunc :: MonadIRBuilder m => Operand -> Type -> m Operand
zext :: MonadIRBuilder m => Operand -> Type -> m Operand
sext :: MonadIRBuilder m => Operand -> Type -> m Operand
fptoui :: MonadIRBuilder m => Operand -> Type -> m Operand
fptosi :: MonadIRBuilder m => Operand -> Type -> m Operand
uitofp :: MonadIRBuilder m => Operand -> Type -> m Operand
sitofp :: MonadIRBuilder m => Operand -> Type -> m Operand
ptrtoint :: MonadIRBuilder m => Operand -> Type -> m Operand
inttoptr :: MonadIRBuilder m => Operand -> Type -> m Operand
bitcast :: MonadIRBuilder m => Operand -> Type -> m Operand
icmp :: MonadIRBuilder m => IntegerPredicate -> Operand -> Operand -> m Operand
fcmp :: MonadIRBuilder m => FloatingPointPredicate -> Operand -> Operand -> m Operand

-- | Unconditional branch
br :: MonadIRBuilder m => Name -> m ()
phi :: MonadIRBuilder m => [(Operand, Name)] -> m Operand
retVoid :: MonadIRBuilder m => m ()
call :: MonadIRBuilder m => Operand -> [(Operand, [ParameterAttribute])] -> m Operand
ret :: MonadIRBuilder m => Operand -> m ()
switch :: MonadIRBuilder m => Operand -> Name -> [(Constant, Name)] -> m ()
select :: MonadIRBuilder m => Operand -> Operand -> Operand -> m Operand
condBr :: MonadIRBuilder m => Operand -> Name -> Name -> m ()
unreachable :: MonadIRBuilder m => m ()

module LLVM.IRBuilder.Constant
int64 :: Applicative f => Integer -> f Operand
int32 :: Applicative f => Integer -> f Operand
bit :: Applicative f => Integer -> f Operand
double :: Applicative f => Double -> f Operand
single :: Applicative f => Float -> f Operand
half :: Applicative f => Word16 -> f Operand
struct :: Applicative f => Maybe Name -> Bool -> [Constant] -> f Operand
array :: Applicative f => [Constant] -> f Operand

module LLVM.IRBuilder
