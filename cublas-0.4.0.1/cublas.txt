-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFI bindings to the CUDA BLAS library
--   
--   The cuBLAS library is an implementation of BLAS (Basic Linear Algebra
--   Subprograms) for NVIDIA GPUs. This package provides FFI bindings to
--   the functions of the cuBLAS library. You will need to install the CUDA
--   driver and developer toolkit:
--   
--   <a>http://developer.nvidia.com/cuda-downloads</a>
--   
--   See the <a>travis-ci.org</a> build matrix for tested CUDA library
--   versions.
@package cublas
@version 0.4.0.1


module Foreign.CUDA.BLAS.Error

-- | Error codes used by cuBLAS library functions
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasstatus_t</a>
data Status
Success :: Status
NotInitialized :: Status
AllocFailed :: Status
InvalidValue :: Status
ArchMismatch :: Status
MappingError :: Status
ExecutionFailed :: Status
InternalError :: Status
NotSupported :: Status
LicenseError :: Status
describe :: Status -> String
data CUBLASException
ExitCode :: Status -> CUBLASException
UserError :: String -> CUBLASException

-- | Raise a CUBLASException in the IO Monad
cublasError :: String -> IO a

-- | A specially formatted error message
requireSDK :: Name -> Double -> IO a

-- | Return the results of a function on successful execution, otherwise
--   throw an exception with an error string associated with the return
--   code
resultIfOk :: (Status, a) -> IO a

-- | Throw an exception with an error string associated with an
--   unsuccessful return code, otherwise return unit.
nothingIfOk :: Status -> IO ()
checkStatus :: CInt -> IO ()
instance GHC.Show.Show Foreign.CUDA.BLAS.Error.Status
instance GHC.Classes.Eq Foreign.CUDA.BLAS.Error.Status
instance GHC.Exception.Exception Foreign.CUDA.BLAS.Error.CUBLASException
instance GHC.Show.Show Foreign.CUDA.BLAS.Error.CUBLASException
instance GHC.Enum.Enum Foreign.CUDA.BLAS.Error.Status


module Foreign.CUDA.BLAS.Context

-- | An opaque handle to the cuBLAS library context, which is passed to all
--   library function calls.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublashandle_t</a>
newtype Handle
Handle :: ((Ptr ())) -> Handle
[useHandle] :: Handle -> ((Ptr ()))

-- | This function initializes the CUBLAS library and creates a handle to
--   an opaque structure holding the CUBLAS library context. It allocates
--   hardware resources on the host and device and must be called prior to
--   making any other CUBLAS library calls.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublascreate</a>
create :: IO ((Handle))

-- | This function releases hardware resources used by the CUBLAS library.
--   The release of GPU resources may be deferred until the application
--   exits. This function is usually the last call with a particular handle
--   to the CUBLAS library.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasdestroy</a>
destroy :: (Handle) -> IO ((()))

-- | For functions which take scalar value arguments, determines whether
--   those values are passed by reference on the host or device.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublaspointermode_t</a>
data PointerMode
Host :: PointerMode
Device :: PointerMode

-- | Determines whether cuBLAS routines can alternate implementations which
--   make use of atomic instructions.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasatomicsmode_t</a>
data AtomicsMode
NotAllowed :: AtomicsMode
Allowed :: AtomicsMode

-- | Enum for default math mode / tensor math mode
data MathMode

-- | Set the pointer mode used by cuBLAS library functions. For example,
--   this controls whether the scaling parameters &lt;math&gt; and
--   &lt;math&gt; of the <a>?gemm</a> operation are treated as residing in
--   host or device memory.
--   
--   The default mode is for values to be passed by reference from the
--   host.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassetpointermode</a>
setPointerMode :: (Handle) -> (PointerMode) -> IO ((()))

-- | Get the pointer mode used by cuBLAS library functions to pass scalar
--   arguments.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasgetpointermode</a>
getPointerMode :: (Handle) -> IO ((PointerMode))

-- | Set whether cuBLAS library functions are allowed to use atomic
--   functions, when available. The implementations are generally faster,
--   but can generate results which are not strictly identical from one run
--   to another.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassetatomicsmode</a>
setAtomicsMode :: (Handle) -> (AtomicsMode) -> IO ((()))

-- | Determine whether cuBLAS library functions are allowed to use atomic
--   operations.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasgetatomicsmode</a>
getAtomicsMode :: (Handle) -> IO ((AtomicsMode))

-- | Set whether cuBLAS library functions are allowed to use Tensor Core
--   operations where available.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassetmathmode</a>
--   
--   <pre>
--   since 0.4.0.0
--   </pre>
setMathMode :: Handle -> MathMode -> IO ()

-- | Determine whether cuBLAS library functions are allowed to use Tensor
--   Core operations where available.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasgetmathmode</a>
--   
--   <pre>
--   since 0.4.0.0
--   </pre>
getMathMode :: Handle -> IO MathMode


-- | For more information see the cuBLAS Level-1 function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublas-level-1-function-reference</a>
module Foreign.CUDA.BLAS.Level1
isamax :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Int32) -> IO ((()))
idamax :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Int32) -> IO ((()))
icamax :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Int32) -> IO ((()))
izamax :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Int32) -> IO ((()))
isamin :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Int32) -> IO ((()))
idamin :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Int32) -> IO ((()))
icamin :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Int32) -> IO ((()))
izamin :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Int32) -> IO ((()))
sasum :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> IO ((()))
dasum :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> IO ((()))
scasum :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Float) -> IO ((()))
dzasum :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Double) -> IO ((()))
saxpy :: (Handle) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
daxpy :: (Handle) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
caxpy :: (Handle) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zaxpy :: (Handle) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
scopy :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dcopy :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ccopy :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zcopy :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sdot :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> IO ((()))
ddot :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> IO ((()))
cdotu :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ((()))
zdotu :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ((()))
cdotc :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ((()))
zdotc :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ((()))
snrm2 :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> IO ((()))
dnrm2 :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> IO ((()))
scnrm2 :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Float) -> IO ((()))
dznrm2 :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Double) -> IO ((()))
srot :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (Ptr Float) -> IO ((()))
drot :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (Ptr Double) -> IO ((()))
crot :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> IO ((()))
csrot :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Float) -> (Ptr Float) -> IO ((()))
zrot :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> IO ((()))
zdrot :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Double) -> (Ptr Double) -> IO ((()))
srotg :: (Handle) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> IO ((()))
drotg :: (Handle) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> IO ((()))
crotg :: (Handle) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> IO ((()))
zrotg :: (Handle) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> IO ((()))
srotm :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> IO ((()))
drotm :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> IO ((()))
srotmg :: (Handle) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> IO ((()))
drotmg :: (Handle) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> IO ((()))
sscal :: (Handle) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dscal :: (Handle) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
cscal :: (Handle) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
csscal :: (Handle) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zscal :: (Handle) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
zdscal :: (Handle) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sswap :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dswap :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
cswap :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zswap :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))


-- | For more information see the cuBLAS Level-2 function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublas-level-2-function-reference</a>
module Foreign.CUDA.BLAS.Level2

-- | Indicates which operation needs to be performed with a dense matrix.
--   
--   <ul>
--   <li><tt>N</tt>: no transpose selected</li>
--   <li><tt>T</tt>: transpose operation</li>
--   <li><tt>C</tt>: conjugate transpose</li>
--   </ul>
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasoperation_t</a>
data Operation
N :: Operation
T :: Operation
C :: Operation

-- | Indicates which part, upper or lower, of a dense matrix was filled and
--   consequently should be used by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasfillmode_t</a>
data Fill
Lower :: Fill
Upper :: Fill

-- | Indicates whether the main diagonal of a dense matrix is unity and
--   consequently should not be be touched or modified by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasdiagtype_t</a>
data Diagonal
NonUnit :: Diagonal
Unit :: Diagonal
sgbmv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dgbmv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
cgbmv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgbmv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sgemv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dgemv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
cgemv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgemv :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sger :: (Handle) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dger :: (Handle) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
cgerc :: (Handle) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgerc :: (Handle) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cgeru :: (Handle) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgeru :: (Handle) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssbmv :: (Handle) -> (Fill) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsbmv :: (Handle) -> (Fill) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
sspmv :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dspmv :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
sspr :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((()))
dspr :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((()))
sspr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((()))
dspr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((()))
ssymv :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsymv :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
csymv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsymv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssyr :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsyr :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
csyr :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsyr :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssyr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsyr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
csyr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsyr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
stbmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtbmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctbmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztbmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
stbsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtbsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctbsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztbsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
stpmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtpmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctpmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztpmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
stpsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtpsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctpsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztpsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtrmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctrmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztrmv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtrsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctrsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztrsv :: (Handle) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
chemv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zhemv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
chbmv :: (Handle) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zhbmv :: (Handle) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
chpmv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zhpmv :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cher :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zher :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cher2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zher2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
chpr :: (Handle) -> (Fill) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((()))
zhpr :: (Handle) -> (Fill) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((()))
chpr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((()))
zhpr2 :: (Handle) -> (Fill) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((()))


-- | For more information see the cuBLAS Level-3 function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublas-level-3-function-reference</a>
module Foreign.CUDA.BLAS.Level3

-- | Indicates which operation needs to be performed with a dense matrix.
--   
--   <ul>
--   <li><tt>N</tt>: no transpose selected</li>
--   <li><tt>T</tt>: transpose operation</li>
--   <li><tt>C</tt>: conjugate transpose</li>
--   </ul>
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasoperation_t</a>
data Operation
N :: Operation
T :: Operation
C :: Operation

-- | Indicates which part, upper or lower, of a dense matrix was filled and
--   consequently should be used by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasfillmode_t</a>
data Fill
Lower :: Fill
Upper :: Fill

-- | Indicates whether the main diagonal of a dense matrix is unity and
--   consequently should not be be touched or modified by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasdiagtype_t</a>
data Diagonal
NonUnit :: Diagonal
Unit :: Diagonal

-- | Indicates whether the dense matrix is on the lift or right side in the
--   matrix equation solved by a particular function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassidemode_t</a>
data Side
Left :: Side
Right :: Side

-- | Used to specify the type of data underlying a <tt>void*</tt> pointer.
--   For example, it is used in the routine <a>?gemmEx</a>.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cuda_datatype_t</a>
data Type
R32f :: Type
R64f :: Type
R16f :: Type
R8i :: Type
C32f :: Type
C64f :: Type
C16f :: Type
C8i :: Type
R8u :: Type
C8u :: Type
R32i :: Type
C32i :: Type
R32u :: Type
C32u :: Type

-- | Used to run <a>gemmEx</a> with a specific, yet completely unspecified,
--   algorithm.
data GemmAlgorithm
GemmDefault :: GemmAlgorithm
GemmAlgo0 :: GemmAlgorithm
GemmAlgo1 :: GemmAlgorithm
GemmAlgo2 :: GemmAlgorithm
GemmAlgo3 :: GemmAlgorithm
GemmAlgo4 :: GemmAlgorithm
GemmAlgo5 :: GemmAlgorithm
GemmAlgo6 :: GemmAlgorithm
GemmAlgo7 :: GemmAlgorithm
sgemm :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dgemm :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
cgemm :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgemm :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sgemmBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (Ptr Float) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (Int) -> IO ((()))
dgemmBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (Ptr Double) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (Int) -> IO ((()))
cgemmBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (Int) -> IO ((()))
zgemmBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (Int) -> IO ((()))
ssymm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsymm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
csymm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsymm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssyrk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsyrk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
csyrk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsyrk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssyr2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsyr2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
csyr2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsyr2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
ssyrkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dsyrkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
csyrkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zsyrkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strmm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtrmm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctrmm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztrmm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strsm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtrsm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctrsm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztrsm :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strsmBatched :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (Int) -> IO ((()))
dtrsmBatched :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (Int) -> IO ((()))
ctrsmBatched :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (Int) -> IO ((()))
ztrsmBatched :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Diagonal) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (Int) -> IO ((()))
chemm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zhemm :: (Handle) -> (Side) -> (Fill) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cherk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zherk :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cher2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zher2k :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr Double) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
cherkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
zherkx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
sgeam :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
dgeam :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
cgeam :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgeam :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sdgmm :: (Handle) -> (Side) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((()))
ddgmm :: (Handle) -> (Side) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((()))
cdgmm :: (Handle) -> (Side) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zdgmm :: (Handle) -> (Side) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sgetrfBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (Ptr Int32) -> (Ptr Int32) -> (Int) -> IO ((()))
dgetrfBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (Ptr Int32) -> (Ptr Int32) -> (Int) -> IO ((()))
cgetrfBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (Ptr Int32) -> (Ptr Int32) -> (Int) -> IO ((()))
zgetrfBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (Ptr Int32) -> (Ptr Int32) -> (Int) -> IO ((()))
sgetriBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
dgetriBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
cgetriBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
zgetriBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
smatinvBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
dmatinvBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
cmatinvBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
zmatinvBatched :: (Handle) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr Int32) -> (Int) -> IO ((()))
sgeqrfBatched :: (Handle) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (HostPtr Int32) -> (Int) -> IO ((()))
dgeqrfBatched :: (Handle) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (HostPtr Int32) -> (Int) -> IO ((()))
cgeqrfBatched :: (Handle) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (HostPtr Int32) -> (Int) -> IO ((()))
zgeqrfBatched :: (Handle) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (HostPtr Int32) -> (Int) -> IO ((()))
sgelsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (HostPtr Int32) -> (DevicePtr Int32) -> (Int) -> IO ((()))
dgelsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (HostPtr Int32) -> (DevicePtr Int32) -> (Int) -> IO ((()))
cgelsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (HostPtr Int32) -> (DevicePtr Int32) -> (Int) -> IO ((()))
zgelsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (HostPtr Int32) -> (DevicePtr Int32) -> (Int) -> IO ((()))
stpttr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> IO ((()))
dtpttr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> IO ((()))
ctpttr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
ztpttr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
strttp :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((()))
dtrttp :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((()))
ctrttp :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((()))
ztrttp :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((()))
sgetrsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr Float)) -> (Int) -> (HostPtr Int32) -> (Int) -> IO ((()))
dgetrsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr Double)) -> (Int) -> (HostPtr Int32) -> (Int) -> IO ((()))
cgetrsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr (Complex Float))) -> (Int) -> (HostPtr Int32) -> (Int) -> IO ((()))
zgetrsBatched :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (DevicePtr (Complex Double))) -> (Int) -> (HostPtr Int32) -> (Int) -> IO ((()))
hgemm :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Half) -> (DevicePtr Half) -> (Int) -> (DevicePtr Half) -> (Int) -> (Ptr Half) -> (DevicePtr Half) -> (Int) -> IO ((()))
sgemmEx :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> IO ((()))
cgemm3m :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((()))
zgemm3m :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((()))
sgemmStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (Int64) -> (DevicePtr Float) -> (Int) -> (Int64) -> (Ptr Float) -> (DevicePtr Float) -> (Int) -> (Int64) -> (Int) -> IO ((()))
dgemmStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (Int64) -> (DevicePtr Double) -> (Int) -> (Int64) -> (Ptr Double) -> (DevicePtr Double) -> (Int) -> (Int64) -> (Int) -> IO ((()))
cgemmStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (Int) -> IO ((()))
zgemmStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Int64) -> (DevicePtr (Complex Double)) -> (Int) -> (Int64) -> (Ptr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Int64) -> (Int) -> IO ((()))
hgemmStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr Half) -> (DevicePtr Half) -> (Int) -> (Int64) -> (DevicePtr Half) -> (Int) -> (Int64) -> (Ptr Half) -> (DevicePtr Half) -> (Int) -> (Int64) -> (Int) -> IO ((()))
cgemm3mStridedBatched :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (Ptr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Int64) -> (Int) -> IO ((()))
cgemmEx :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr (Complex Float)) -> (DevicePtr ()) -> (Type) -> (Int) -> IO ((()))
gemmEx :: (Handle) -> (Operation) -> (Operation) -> (Int) -> (Int) -> (Int) -> (Ptr ()) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr ()) -> (DevicePtr ()) -> (Type) -> (Int) -> (Type) -> (GemmAlgorithm) -> IO ((()))
csyrkEx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Type) -> (Int) -> IO ((()))
csyrk3mEx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Type) -> (Int) -> IO ((()))
cherkEx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Type) -> (Int) -> IO ((()))
cherk3mEx :: (Handle) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (Ptr Float) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr Float) -> (DevicePtr (Complex Float)) -> (Type) -> (Int) -> IO ((()))
nrm2Ex :: (Handle) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr ()) -> (Type) -> (Type) -> IO ((()))
axpyEx :: (Handle) -> (Int) -> (Ptr ()) -> (Type) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Type) -> IO ((()))
dotEx :: (Handle) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr ()) -> (Type) -> (Type) -> IO ((()))
dotcEx :: (Handle) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (DevicePtr ()) -> (Type) -> (Int) -> (Ptr ()) -> (Type) -> (Type) -> IO ((()))
scalEx :: (Handle) -> (Int) -> (Ptr ()) -> (Type) -> (DevicePtr ()) -> (Type) -> (Int) -> (Type) -> IO ((()))


module Foreign.CUDA.BLAS.Stream

-- | Sets the execution stream which all subsequent cuBLAS library
--   functions will execute with. If not set, functions execute in the
--   default stream (which never overlaps any other operations).
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassetstream</a>
setStream :: (Handle) -> (Stream) -> IO ((()))


-- | The cuBLAS library is an implementation of BLAS (Basic Linear Algebra
--   Subprograms) for NVIDIA GPUs.
--   
--   To use operations from the cuBLAS library, the user must allocate the
--   required matrices and vectors in the GPU memory space, fill them with
--   data, call the desired sequence of cuBLAS functions, then copy the
--   results from the GPU memory space back to the host.
--   
--   The <a>cuda</a> package can be used for writing to and retrieving data
--   from the GPU.
--   
--   <ul>
--   <li><i><i>Data layout</i></i></li>
--   </ul>
--   
--   Unlike modern BLAS libraries, cuBLAS <i>only</i> provides
--   Fortran-style implementations of the subprograms, using column-major
--   storage and 1-based indexing.
--   
--   The <tt><a>?geam</a></tt> operation can be used to perform matrix
--   transposition.
--   
--   <ul>
--   <li><i><i>Example</i></i></li>
--   </ul>
--   
--   At a short example, we show how to compute the following matrix-matrix
--   product with <a>dgemm</a>:
--   
--   &lt;math&gt;
--   
--   I assume you know how to initialise the CUDA environment, as described
--   in the <a>Foreign.CUDA.Driver</a> module:
--   
--   <pre>
--   &gt;&gt;&gt; import Foreign.CUDA.Driver as CUDA
--   
--   &gt;&gt;&gt; import Foreign.CUDA.BLAS as BLAS
--   
--   &gt;&gt;&gt; CUDA.initialise []
--   
--   &gt;&gt;&gt; dev &lt;- CUDA.device 0
--   
--   &gt;&gt;&gt; ctx &lt;- CUDA.create dev []
--   </pre>
--   
--   Just as we must create a CUDA execution context with <a>create</a>
--   before interacting with the GPU, we must create a BLAS context handle
--   before executing any cuBLAS library operations, which will be
--   associated with the current device context:
--   
--   <pre>
--   &gt;&gt;&gt; hdl &lt;- BLAS.create
--   </pre>
--   
--   Now, let us generate the matrix data on the GPU. (For simplicity in
--   this example we will just marshal the data via lists, but in a real
--   application with a large amount of data we should of course use some
--   kind of unboxed array):
--   
--   <pre>
--   &gt;&gt;&gt; let rowsA = 3; colsA = 2; sizeA = rowsA * colsA
--   
--   &gt;&gt;&gt; let rowsB = 2; colsB = 3; sizeB = rowsB * colsB
--   
--   &gt;&gt;&gt; let sizeC = rowsA * colsB
--   
--   &gt;&gt;&gt; matA &lt;- CUDA.newListArray (take sizeA [1..])
--   
--   &gt;&gt;&gt; matB &lt;- CUDA.newListArray (take sizeB [1..])
--   
--   &gt;&gt;&gt; matC &lt;- CUDA.mallocArray sizeC
--   </pre>
--   
--   Note in the above that we store data in row-major order, as is the
--   convention in C. However, the cuBLAS library assumes a column-major
--   representation, as is the style of Fortran. However, we can make use
--   of the following equivalency:
--   
--   &lt;math&gt;
--   
--   and, since the transposed matrix in column-major representation is
--   equivalent to our matrix in row-major representation, we can avoid any
--   actual data manipulation to get things into a form suitable for cuBLAS
--   (phew!).
--   
--   The final thing to take care of are the scaling parameters to the
--   <a>dgemm</a> operation, &lt;math&gt; and &lt;math&gt;. By default, it
--   is assumed that these values reside in host memory, but this setting
--   can be changed with <a>setPointerMode</a>; When set to <a>Device</a>
--   mode, the function <a>withDevicePtr</a> can be used to treat the
--   device memory pointer as a plain pointer to pass to the function.
--   
--   Now, we are ready to piece it all together:
--   
--   <pre>
--   &gt;&gt;&gt; import Foreign.Marshal
--   
--   &gt;&gt;&gt; with 1.0 $ \alpha -&gt;
--   
--   &gt;&gt;&gt; with 0.0 $ \beta -&gt;
--   
--   &gt;&gt;&gt; dgemm hdl N N colsB rowsA colsA alpha matB colsB matA colsA beta matC colsB
--   </pre>
--   
--   And retrieve the result:
--   
--   <pre>
--   &gt;&gt;&gt; print =&lt;&lt; CUDA.peekListArray sizeC matC
--   [9.0,12.0,15.0,19.0,26.0,33.0,29.0,40.0,51.0]
--   </pre>
--   
--   Finally, we should <a>free</a> the device memory we allocated, and
--   release the BLAS context handle:
--   
--   <pre>
--   &gt;&gt;&gt; BLAS.destroy hdl
--   </pre>
--   
--   <ul>
--   <li><i><i>Additional information</i></i></li>
--   </ul>
--   
--   For more information, see the NVIDIA cuBLAS documentation:
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html</a>
module Foreign.CUDA.BLAS
