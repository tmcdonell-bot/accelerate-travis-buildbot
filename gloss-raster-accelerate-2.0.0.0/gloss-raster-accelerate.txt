-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parallel rendering of raster images using Accelerate
--   
--   Parallel rendering of raster images using Accelerate
@package gloss-raster-accelerate
@version 2.0.0.0


module Graphics.Gloss.Accelerate.Render

-- | The type for executing Accelerate computations. This matches the
--   <tt>run1</tt> style of executing programs.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b


-- | Rendering of Accelerate arrays as raster images
module Graphics.Gloss.Accelerate.Raster.Array

-- | The type for executing Accelerate computations. This matches the
--   <tt>run1</tt> style of executing programs.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen.
FullScreen :: Display

-- | Animate a bitmap generated by an Accelerate computation, specifying
--   the backend used to render the image.
animateArrayWith :: Render -> Display -> (Int, Int) -> (Exp Float -> Acc (Array DIM2 Colour)) -> IO ()

-- | Animate a bitmap generated by an Accelerate computation and IO
--   actions, specifying the backend used to render the image.
animateArrayIOWith :: Arrays world => Render -> Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation, specifying
--   the method used to render the world.
playArrayWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation and IO
--   actions, specifying the method used to render the world.
playArrayIOWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Lift an Accelerate computation from a <tt>world</tt> to an image into
--   a real Haskell-land function that executes the computation of the
--   image and wraps it as a Gloss picture ready for display.
makePicture :: Arrays world => Render -> Int -> Int -> (Acc world -> Acc (Array DIM2 Colour)) -> world -> Picture


-- | Rendering of 2D functions as raster fields
module Graphics.Gloss.Accelerate.Raster.Field

-- | The type for executing Accelerate computations. This matches the
--   <tt>run1</tt> style of executing programs.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen.
FullScreen :: Display

-- | Animate a continuous 2D function, specifying the backend used to
--   render the field.
animateFieldWith :: Render -> Display -> (Int, Int) -> (Exp Float -> Exp Point -> Exp Colour) -> IO ()

-- | Animate a continuous 2D function using IO actions, specifying the
--   backend used to render the field.
animateFieldIOWith :: Arrays world => Render -> Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> IO ()

-- | Play a game with a continuous 2D function, specifying the method used
--   to render the field.
playFieldWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play a game with a continuous 2D function using IO actions, specifying
--   the method used to render the field.
playFieldIOWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Lift a point-wise colouring function into an image creation function.
--   
--   The parameter <tt>world</tt> at this point can be arbitrary. However
--   if you use this function standalone, you will probably at some point
--   want the result of this function to plug into <a>makePicture</a> and
--   thus <a>Render</a>, and thus be a unary function from <a>Arrays</a> to
--   <a>Arrays</a>.
makeField :: Int -> Int -> (world -> Exp Point -> Exp Colour) -> world -> Acc (Array DIM2 Colour)
