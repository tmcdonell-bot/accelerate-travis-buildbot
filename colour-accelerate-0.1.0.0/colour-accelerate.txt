-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Working with colours in Accelerate
--   
--   This package provides data types for colours and transparency for use
--   with Accelerate. For further information refer to the main
--   <i>Accelerate</i> package:
--   <a>http://hackage.haskell.org/package/accelerate</a>.
@package colour-accelerate
@version 0.1.0.0


-- | Names for "familiar" colours, taken from
--   <a>http://paulbourke.net/texture_colour/colourspace/</a>
module Data.Array.Accelerate.Data.Colour.Names
class NamedColour c
antiqueWhite :: NamedColour c => c
azure :: NamedColour c => c
bisque :: NamedColour c => c
blanchedAlmond :: NamedColour c => c
cornsilk :: NamedColour c => c
eggshell :: NamedColour c => c
floralWhite :: NamedColour c => c
gainsboro :: NamedColour c => c
ghostWhite :: NamedColour c => c
honeydew :: NamedColour c => c
ivory :: NamedColour c => c
lavender :: NamedColour c => c
lavenderBlush :: NamedColour c => c
lemonChiffon :: NamedColour c => c
linen :: NamedColour c => c
mintCream :: NamedColour c => c
mistyRose :: NamedColour c => c
moccasin :: NamedColour c => c
navajoWhite :: NamedColour c => c
oldLace :: NamedColour c => c
papayaWhip :: NamedColour c => c
peachPuff :: NamedColour c => c
seashell :: NamedColour c => c
snow :: NamedColour c => c
thistle :: NamedColour c => c
titaniumWhite :: NamedColour c => c
wheat :: NamedColour c => c
white :: NamedColour c => c
whiteSmoke :: NamedColour c => c
zincWhite :: NamedColour c => c
coldGrey :: NamedColour c => c
dimGrey :: NamedColour c => c
grey :: NamedColour c => c
lightGrey :: NamedColour c => c
slateGrey :: NamedColour c => c
slateGreyDark :: NamedColour c => c
slateGreyLight :: NamedColour c => c
warmGrey :: NamedColour c => c
black :: NamedColour c => c
ivoryBlack :: NamedColour c => c
lampBlack :: NamedColour c => c
alizarinCrimson :: NamedColour c => c
brick :: NamedColour c => c
cadmiumRedDeep :: NamedColour c => c
coral :: NamedColour c => c
coralLight :: NamedColour c => c
deepPink :: NamedColour c => c
englishRed :: NamedColour c => c
firebrick :: NamedColour c => c
geraniumLake :: NamedColour c => c
hotPink :: NamedColour c => c
indianRed :: NamedColour c => c
lightSalmon :: NamedColour c => c
madderLakeDeep :: NamedColour c => c
maroon :: NamedColour c => c
pink :: NamedColour c => c
pinkLight :: NamedColour c => c
raspberry :: NamedColour c => c
red :: NamedColour c => c
roseMadder :: NamedColour c => c
salmon :: NamedColour c => c
tomato :: NamedColour c => c
venetianRed :: NamedColour c => c
beige :: NamedColour c => c
brown :: NamedColour c => c
brownMadder :: NamedColour c => c
brownOchre :: NamedColour c => c
burlywood :: NamedColour c => c
burntSienna :: NamedColour c => c
burntUmber :: NamedColour c => c
chocolate :: NamedColour c => c
deepOchre :: NamedColour c => c
flesh :: NamedColour c => c
fleshOchre :: NamedColour c => c
goldOchre :: NamedColour c => c
greenishUmber :: NamedColour c => c
khaki :: NamedColour c => c
khakiDark :: NamedColour c => c
lightBeige :: NamedColour c => c
peru :: NamedColour c => c
rosyBrown :: NamedColour c => c
rawSienna :: NamedColour c => c
rawUmber :: NamedColour c => c
sepia :: NamedColour c => c
sienna :: NamedColour c => c
saddleBrown :: NamedColour c => c
sandyBrown :: NamedColour c => c
tan :: NamedColour c => c
vanDykeBrown :: NamedColour c => c
cadmiumOrange :: NamedColour c => c
cadmiumRedLight :: NamedColour c => c
carrot :: NamedColour c => c
darkOrange :: NamedColour c => c
marsOrange :: NamedColour c => c
marsYellow :: NamedColour c => c
orange :: NamedColour c => c
orangeRed :: NamedColour c => c
yellowOchre :: NamedColour c => c
aureolineYellow :: NamedColour c => c
banana :: NamedColour c => c
cadmiumLemon :: NamedColour c => c
cadmiumYellow :: NamedColour c => c
gold :: NamedColour c => c
goldenrod :: NamedColour c => c
goldenrodDark :: NamedColour c => c
goldenrodLight :: NamedColour c => c
goldenrodPale :: NamedColour c => c
lightGoldenrod :: NamedColour c => c
melon :: NamedColour c => c
naplesyellowdeep :: NamedColour c => c
yellow :: NamedColour c => c
yellowLight :: NamedColour c => c
chartreuse :: NamedColour c => c
chromeoxidegreen :: NamedColour c => c
cinnabarGreen :: NamedColour c => c
cobaltGreen :: NamedColour c => c
emeraldGreen :: NamedColour c => c
forestGreen :: NamedColour c => c
green :: NamedColour c => c
greenDark :: NamedColour c => c
greenPale :: NamedColour c => c
greenYellow :: NamedColour c => c
lawnGreen :: NamedColour c => c
limeGreen :: NamedColour c => c
mint :: NamedColour c => c
olive :: NamedColour c => c
oliveDrab :: NamedColour c => c
oliveGreenDark :: NamedColour c => c
permanentGreen :: NamedColour c => c
sapGreen :: NamedColour c => c
seaGreen :: NamedColour c => c
seaGreenDark :: NamedColour c => c
seaGreenMedium :: NamedColour c => c
seaGreenLight :: NamedColour c => c
springGreen :: NamedColour c => c
springGreenmedium :: NamedColour c => c
terreVerte :: NamedColour c => c
viridianLight :: NamedColour c => c
yellowGreen :: NamedColour c => c
aquamarine :: NamedColour c => c
aquamarinemedium :: NamedColour c => c
cyan :: NamedColour c => c
cyanWhite :: NamedColour c => c
turquoise :: NamedColour c => c
turquoiseDark :: NamedColour c => c
turquoiseMedium :: NamedColour c => c
turquoisePale :: NamedColour c => c
aliceBlue :: NamedColour c => c
blue :: NamedColour c => c
blueLight :: NamedColour c => c
blueMedium :: NamedColour c => c
cadet :: NamedColour c => c
cobalt :: NamedColour c => c
cornflower :: NamedColour c => c
cerulean :: NamedColour c => c
dodgerBlue :: NamedColour c => c
indigo :: NamedColour c => c
manganeseBlue :: NamedColour c => c
midnightBlue :: NamedColour c => c
navy :: NamedColour c => c
peacock :: NamedColour c => c
powderBlue :: NamedColour c => c
royalBlue :: NamedColour c => c
slateBlue :: NamedColour c => c
slateBlueDark :: NamedColour c => c
slateBlueLight :: NamedColour c => c
slateBlueMedium :: NamedColour c => c
skyBlue :: NamedColour c => c
skyBlueDeep :: NamedColour c => c
skyBlueLight :: NamedColour c => c
steelBlue :: NamedColour c => c
steelBlueLight :: NamedColour c => c
turquoiseBlue :: NamedColour c => c
ultramarine :: NamedColour c => c
blueViolet :: NamedColour c => c
cobaltVioletdeep :: NamedColour c => c
magenta :: NamedColour c => c
orchid :: NamedColour c => c
orchidDark :: NamedColour c => c
orchidMedium :: NamedColour c => c
permanentViolet :: NamedColour c => c
plum :: NamedColour c => c
purple :: NamedColour c => c
purpleMedium :: NamedColour c => c
ultramarineViolet :: NamedColour c => c
violet :: NamedColour c => c
violetDark :: NamedColour c => c
violetRed :: NamedColour c => c
violetRedmedium :: NamedColour c => c
violetRedPale :: NamedColour c => c


-- | RGBA quadruples for an unspecified colour space
module Data.Array.Accelerate.Data.Colour.RGBA

-- | An RGBA colour value.
type Colour = RGBA Float

-- | An RGBA colour value to hold the colour components. All components lie
--   in the range [0..1).
--   
--   We need to parameterise by a type so that we can have both Exp (RGBA
--   a) and RGBA (Exp a).
data RGBA a
RGBA :: a -> a -> a -> a -> RGBA a

-- | Construct an RGBA colour from individual channel components. The
--   components will be clamped to the range [0..1].
rgba :: Exp Float -> Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct a colour from 8-bits-per-channel colour components.
rgba8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Clamp each component to the range [0..1]
clamp :: Exp Colour -> Exp Colour

-- | Blend two colours in the given proportions.
--   
--   Note that this uses an approximation of gamma=2 (i.e. sum-of-squares
--   method). It is recommended to instead convert to the sRGB colour space
--   if you want more accurate colour blending, or if you intend to use the
--   gamma-corrected values more than once (e.g. in a stencil).
--   
--   <pre>
--   blend c1 c2 ~= SRGB.toRGB ( (SRGB.fromRGB c1 + SRGB.fromRGB c2) / 2 )
--   </pre>
--   
--   See the Blur program in the examples for a comparison of mixing
--   colours in the RGB and sRGB colour spaces.
blend :: Exp Float -> Exp Float -> Exp Colour -> Exp Colour -> Exp Colour

-- | Luminance of an RGB colour (Y component of a YUV colour).
luminance :: Exp Colour -> Exp Float

-- | Set the opacity of the given colour. The opacity is clamped to the
--   range [0..1].
opacity :: Exp Float -> Exp Colour -> Exp Colour

-- | A completely opaque colour
opaque :: Exp Colour -> Exp Colour

-- | Make colour transparent
transparent :: Exp Colour -> Exp Colour

-- | Convert a Colour into a packed-word RGBA representation
packRGBA :: Exp Colour -> Exp Word32

-- | Convert a colour into a packed-word ABGR representation
packABGR :: Exp Colour -> Exp Word32

-- | Convert a colour from a packed-word RGBA representation
unpackRGBA :: Exp Word32 -> Exp Colour

-- | Convert a colour from a packed-word ABGR representation
unpackABGR :: Exp Word32 -> Exp Colour
packRGBA8 :: Exp (RGBA Word8) -> Exp Word32
packABGR8 :: Exp (RGBA Word8) -> Exp Word32
unpackRGBA8 :: Exp Word32 -> Exp (RGBA Word8)
unpackABGR8 :: Exp Word32 -> Exp (RGBA Word8)
instance [overlap ok] Typeable RGBA
instance [overlap ok] Show a => Show (RGBA a)
instance [overlap ok] Eq a => Eq (RGBA a)
instance [overlap ok] Functor RGBA
instance [overlap ok] NamedColour (RGBA Float)
instance [overlap ok] NamedColour (RGBA Word8)
instance [overlap ok] (Fractional a) => Fractional (Exp (RGBA a))
instance [overlap ok] (Num a) => Num (Exp (RGBA a))
instance [overlap ok] (Num a, Fractional a) => Fractional (RGBA a)
instance [overlap ok] Num a => Num (RGBA a)
instance [overlap ok] Elt a => Unlift Exp (RGBA (Exp a))
instance [overlap ok] (Lift Exp a, Elt (Plain a)) => Lift Exp (RGBA a)
instance [overlap ok] Elt a => IsProduct Elt (RGBA a)
instance [overlap ok] Elt a => Elt (RGBA a)


-- | RGB triples for an unspecified colour space
module Data.Array.Accelerate.Data.Colour.RGB

-- | An RGB colour value
type Colour = RGB Float
data RGB a
RGB :: a -> a -> a -> RGB a

-- | Construct an RGB colour from individual channel components. The
--   components will be clamped to the range [0..1].
rgb :: Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct a colour from 8-bit-per-channel colour components.
rgb8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Clamp each component of a colour to the range [0..1].
clamp :: Exp Colour -> Exp Colour

-- | Blend two colours in the given proportions.
--   
--   Note that this uses an approximation of gamma=2 (i.e. sum-of-squares
--   method). It is recommended to instead convert to the sRGB colour space
--   if you want more accurate colour blending, or if you intend to use the
--   gamma-corrected values more than once (e.g. in a stencil).
--   
--   <pre>
--   blend c1 c2 ~= SRGB.toRGB ( (SRGB.fromRGB c1 + SRGB.fromRGB c2) / 2 )
--   </pre>
--   
--   See the Blur program in the examples for a comparison of mixing
--   colours in the RGB and sRGB colour spaces.
blend :: Exp Float -> Exp Float -> Exp Colour -> Exp Colour -> Exp Colour

-- | Luminance of an RGB colour (Y component of a YUV colour).
luminance :: Exp Colour -> Exp Float

-- | Convert a Colour into a packed-word RGBA representation
packRGB :: Exp Colour -> Exp Word32

-- | Convert a colour into a packed-word ABGR representation
packBGR :: Exp Colour -> Exp Word32

-- | Convert a colour from a packed-word RGBA representation
unpackRGB :: Exp Word32 -> Exp Colour

-- | Convert a colour from a packed-word ABGR representation
unpackBGR :: Exp Word32 -> Exp Colour
packRGB8 :: Exp (RGB Word8) -> Exp Word32
packBGR8 :: Exp (RGB Word8) -> Exp Word32
unpackRGB8 :: Exp Word32 -> Exp (RGB Word8)
unpackBGR8 :: Exp Word32 -> Exp (RGB Word8)
instance [overlap ok] Typeable RGB
instance [overlap ok] Show a => Show (RGB a)
instance [overlap ok] Eq a => Eq (RGB a)
instance [overlap ok] Functor RGB
instance [overlap ok] NamedColour (RGB Float)
instance [overlap ok] NamedColour (RGB Word8)
instance [overlap ok] (Fractional a) => Fractional (Exp (RGB a))
instance [overlap ok] (Num a) => Num (Exp (RGB a))
instance [overlap ok] (Num a, Fractional a) => Fractional (RGB a)
instance [overlap ok] Num a => Num (RGB a)
instance [overlap ok] Elt a => Unlift Exp (RGB (Exp a))
instance [overlap ok] (Lift Exp a, Elt (Plain a)) => Lift Exp (RGB a)
instance [overlap ok] Elt a => IsProduct Elt (RGB a)
instance [overlap ok] Elt a => Elt (RGB a)


-- | Colours in the HSV (hue-saturation-value) cylindrical-coordinate
--   representation of points in the RGB colour space.
module Data.Array.Accelerate.Data.Colour.HSV

-- | A HSV colour value
type Colour = HSV Float
data HSV a
HSV :: a -> a -> a -> HSV a

-- | Construct a HSV colour value from the individual channel components.
--   The hue component is measured in degrees and wrapped to the range
--   [0..360), while the saturation and value are clamped to the range
--   [0..1].
hsv :: Exp Float -> Exp Float -> Exp Float -> Exp Colour
clamp :: Exp Colour -> Exp Colour

-- | Convert a HSV colour to an RGB colour-space value
toRGB :: Exp (HSV Float) -> Exp (RGB Float)

-- | Convert a point in the RGB colour-space to a point in the HSV
--   colour-space.
fromRGB :: Exp (RGB Float) -> Exp (HSV Float)

-- | Return the HSV-hue of an RGB colour
hue :: Exp (RGB Float) -> Exp Float

-- | Return the HSV-saturation of an RGB colour
saturation :: Exp (RGB Float) -> Exp Float

-- | Return the HSV-value of an RGB colour
value :: Exp (RGB Float) -> Exp Float
instance [overlap ok] Typeable HSV
instance [overlap ok] Show a => Show (HSV a)
instance [overlap ok] Eq a => Eq (HSV a)
instance [overlap ok] Functor HSV
instance [overlap ok] NamedColour (HSV Float)
instance [overlap ok] (Fractional a) => Fractional (Exp (HSV a))
instance [overlap ok] (Num a) => Num (Exp (HSV a))
instance [overlap ok] (Num a, Fractional a) => Fractional (HSV a)
instance [overlap ok] Num a => Num (HSV a)
instance [overlap ok] Elt a => Unlift Exp (HSV (Exp a))
instance [overlap ok] (Lift Exp a, Elt (Plain a)) => Lift Exp (HSV a)
instance [overlap ok] Elt a => IsProduct Elt (HSV a)
instance [overlap ok] Elt a => Elt (HSV a)


-- | Colours in the sRGB standard.
module Data.Array.Accelerate.Data.Colour.SRGB

-- | An sRGB colour value
type Colour = SRGB Float

-- | Synonym for an RGB colour that is in the sRGB colour space.
type SRGB a = RGB a

-- | Construct an sRGB colour from individual channel components. The
--   components will be clamped to the range [0..1].
srgb :: Exp Float -> Exp Float -> Exp Float -> Exp Colour

-- | Construct an sRGB colour from 8-bit-per-channel colour components.
srgb8 :: Exp Word8 -> Exp Word8 -> Exp Word8 -> Exp Colour

-- | Convert a colour in the linear sRGB colour space into the non-linear
--   RGB colour space.
toRGB :: Exp (SRGB Float) -> Exp (RGB Float)

-- | Convert a colour in the non-linear RGB colour space into the linear
--   sRGB colour space.
fromRGB :: Exp (RGB Float) -> Exp (SRGB Float)


-- | Colours in the HSL (hue-saturation-lightness) cylindrical-coordinate
--   representation of points in the RGB colour space.
module Data.Array.Accelerate.Data.Colour.HSL

-- | A HSL colour value
type Colour = HSL Float
data HSL a
HSL :: a -> a -> a -> HSL a

-- | Construct a HSL colour value from the individual channel components.
--   The hue component is measured in degrees and wrapped to the range
--   [0..360), while the saturation and value are clamped to the range
--   [0..1].
hsl :: Exp Float -> Exp Float -> Exp Float -> Exp Colour
clamp :: Exp Colour -> Exp Colour

-- | Convert a HSL colour to an RGB colour-space value
toRGB :: Exp (HSL Float) -> Exp (RGB Float)

-- | Convert a point in the RGB colour-space to a point in the HSL
--   colour-space.
fromRGB :: Exp (RGB Float) -> Exp (HSL Float)

-- | Return the HSL-hue of an RGB colour
hue :: Exp (RGB Float) -> Exp Float

-- | Return the HSL-saturation of an RGB colour
saturation :: Exp (RGB Float) -> Exp Float

-- | Return the HSL-lightness of an RGB colour
lightness :: Exp (RGB Float) -> Exp Float
instance [overlap ok] Typeable HSL
instance [overlap ok] Show a => Show (HSL a)
instance [overlap ok] Eq a => Eq (HSL a)
instance [overlap ok] Functor HSL
instance [overlap ok] NamedColour (HSL Float)
instance [overlap ok] (Fractional a) => Fractional (Exp (HSL a))
instance [overlap ok] (Num a) => Num (Exp (HSL a))
instance [overlap ok] (Num a, Fractional a) => Fractional (HSL a)
instance [overlap ok] Num a => Num (HSL a)
instance [overlap ok] Elt a => Unlift Exp (HSL (Exp a))
instance [overlap ok] (Lift Exp a, Elt (Plain a)) => Lift Exp (HSL a)
instance [overlap ok] Elt a => IsProduct Elt (HSL a)
instance [overlap ok] Elt a => Elt (HSL a)
