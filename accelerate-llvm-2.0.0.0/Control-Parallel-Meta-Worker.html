<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Parallel.Meta.Worker</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Parallel-Meta-Worker.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Parallel-Meta-Worker.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">accelerate-llvm-2.0.0.0: Accelerate backend generating LLVM</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>[2014..2015] Trevor L. McDonell
               [2014..2014] Vinod Grover (NVIDIA Corporation)</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Trevor L. McDonell &lt;tmcdonell@cse.unsw.edu.au&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Parallel.Meta.Worker</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Gang">Gang</a> = Vector <a href="Control-Parallel-Meta-Worker.html#t:Worker">Worker</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Worker">Worker</a> = <a href="#v:Worker">Worker</a> {<ul class="subs"><li><a href="#v:workerId">workerId</a> :: !<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a></li><li><a href="#v:requestVar">requestVar</a> :: !(<a href="../base-4.7.0.2/Control-Concurrent-MVar.html#t:MVar">MVar</a> <a href="Control-Parallel-Meta-Worker.html#t:Req">Req</a>)</li><li><a href="#v:resultVar">resultVar</a> :: !(<a href="../base-4.7.0.2/Control-Concurrent-MVar.html#t:MVar">MVar</a> ())</li><li><a href="#v:workpool">workpool</a> :: !(WSDeque <a href="Data-Range-Range.html#t:Range">Range</a>)</li><li><a href="#v:consecutiveFailures">consecutiveFailures</a> :: !(<a href="../base-4.7.0.2/Data-IORef.html#t:IORef">IORef</a> <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a>)</li><li><a href="#v:rngState">rngState</a> :: !GenIO</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Req">Req</a><ul class="subs"><li>= <a href="#v:ReqDo">ReqDo</a> (<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ())</li><li>| <a href="#v:ReqShutdown">ReqShutdown</a></li></ul></li><li class="src short"><a href="#v:gangSize">gangSize</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a></li><li class="src short"><a href="#v:forkGang">forkGang</a> :: <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a></li><li class="src short"><a href="#v:forkGangOn">forkGangOn</a> :: [<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a>] -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a></li><li class="src short"><a href="#v:gangIO">gangIO</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; (<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:exhausted">exhausted</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Bool">Bool</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Gang" class="def">Gang</a> = Vector <a href="Control-Parallel-Meta-Worker.html#t:Worker">Worker</a> <a href="src/Control-Parallel-Meta-Worker.html#Gang" class="link">Source</a></p><div class="doc"><p>The <code><a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a></code> structure tracks the state of all workers in the program. It
 starts empty, and workers append to it as they are brought online. Although
 the vector append operation is expensive, it is expected it is only called
 occasionally; e.g. at program initialisation. So, we prioritise for constant
 lookup of the worker structure, which will be done frequently during the work
 search.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Worker" class="def">Worker</a> <a href="src/Control-Parallel-Meta-Worker.html#Worker" class="link">Source</a></p><div class="doc"><p>The <code><a href="Control-Parallel-Meta-Worker.html#t:Worker">Worker</a></code> is the per-worker-thread state.</p><p>If the worker has work that can be stolen by other processors, it is stored
 in the <code><a href="Control-Parallel-Meta-Worker.html#v:workpool">workpool</a></code>. Thieves treat the workpool as a stack which can be popped
 on the right, where as the owner can both push and pop on the left.</p><p>In the lazy binary splitting work stealing setup, a worker processes its
 range in chunks, checking the state of its workpool periodically. Whenever
 the queue is empty, it splits it's current workload in two so that the second
 half can be stolen by another processor.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Worker" class="def">Worker</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:workerId" class="def">workerId</a> :: !<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:requestVar" class="def">requestVar</a> :: !(<a href="../base-4.7.0.2/Control-Concurrent-MVar.html#t:MVar">MVar</a> <a href="Control-Parallel-Meta-Worker.html#t:Req">Req</a>)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:resultVar" class="def">resultVar</a> :: !(<a href="../base-4.7.0.2/Control-Concurrent-MVar.html#t:MVar">MVar</a> ())</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:workpool" class="def">workpool</a> :: !(WSDeque <a href="Data-Range-Range.html#t:Range">Range</a>)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:consecutiveFailures" class="def">consecutiveFailures</a> :: !(<a href="../base-4.7.0.2/Data-IORef.html#t:IORef">IORef</a> <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a>)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:rngState" class="def">rngState</a> :: !GenIO</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Worker" class="caption collapser" onclick="toggleSection('i:Worker')">Instances</p><div id="section.i:Worker" class="show"><table><tr><td class="src"><a href="../base-4.7.0.2/Data-Eq.html#t:Eq">Eq</a> <a href="Control-Parallel-Meta-Worker.html#t:Worker">Worker</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Req" class="def">Req</a> <a href="src/Control-Parallel-Meta-Worker.html#Req" class="link">Source</a></p><div class="doc"><p>The <code><a href="Control-Parallel-Meta-Worker.html#t:Req">Req</a></code> type encapsulates work requests for individual workers</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ReqDo" class="def">ReqDo</a> (<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ())</td><td class="doc"><p>Instruct the worker to run the given action</p></td></tr><tr><td class="src"><a name="v:ReqShutdown" class="def">ReqShutdown</a></td><td class="doc"><p>Tell the worker to exit. The worker should signal that it received the
 request by writing its result var before exiting.</p></td></tr></table></div></div><div class="top"><p class="src"><a name="v:gangSize" class="def">gangSize</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> <a href="src/Control-Parallel-Meta-Worker.html#gangSize" class="link">Source</a></p><div class="doc"><p>O(1). Yield the number of threads in the <code><a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:forkGang" class="def">forkGang</a> :: <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> <a href="src/Control-Parallel-Meta-Worker.html#forkGang" class="link">Source</a></p><div class="doc"><p>Create a set of workers. This is a somewhat expensive function, so it is
 expected that it is called only occasionally (e.g. once per program
 execution).</p></div></div><div class="top"><p class="src"><a name="v:forkGangOn" class="def">forkGangOn</a> :: [<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a>] -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> <a href="src/Control-Parallel-Meta-Worker.html#forkGangOn" class="link">Source</a></p><div class="doc"><p>Create a set of workers on specific capabilities. Note that the thread ID
 passed to the <code>gangWorker</code> is the index of this worker in the gang structure,
 not necessarily the capability is is spawned on.</p></div></div><div class="top"><p class="src"><a name="v:gangIO" class="def">gangIO</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; (<a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()) -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> () <a href="src/Control-Parallel-Meta-Worker.html#gangIO" class="link">Source</a></p><div class="doc"><p>Issue work requests to the gang and wait until they complete</p></div></div><div class="top"><p class="src"><a name="v:exhausted" class="def">exhausted</a> :: <a href="Control-Parallel-Meta-Worker.html#t:Gang">Gang</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../accelerate-2.0.0.0/Data-Array-Accelerate.html#t:Bool">Bool</a> <a href="src/Control-Parallel-Meta-Worker.html#exhausted" class="link">Source</a></p><div class="doc"><p>Check whether the work queues of the gang are all empty</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>