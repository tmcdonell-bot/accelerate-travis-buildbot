<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcFlatten.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP, ViewPatterns #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcFlatten</span><span class='hs-layout'>(</span>
<a name="line-4"></a>   <span class='hs-conid'>FlattenMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-5"></a>   <span class='hs-varid'>flatten</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenManyNom</span><span class='hs-layout'>,</span>
<a name="line-6"></a>
<a name="line-7"></a>   <span class='hs-varid'>unflatten</span><span class='hs-layout'>,</span>
<a name="line-8"></a> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCoRep</span>   <span class='hs-comment'>-- performs delicate algorithm on types</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameEnv</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>(</span> <span class='hs-conid'>DynFlags</span> <span class='hs-layout'>)</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pair</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MonadUtils</span> <span class='hs-layout'>(</span> <span class='hs-varid'>zipWithAndUnzipM</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Exts</span> <span class='hs-layout'>(</span> <span class='hs-varid'>inline</span> <span class='hs-layout'>)</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &lt; 709</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Applicative</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$&gt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-cpp'>#endif</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Arrow</span> <span class='hs-layout'>(</span> <span class='hs-varid'>first</span> <span class='hs-layout'>)</span>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-comment'>{-
<a name="line-39"></a>Note [The flattening story]
<a name="line-40"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-41"></a>* A CFunEqCan is either of form
<a name="line-42"></a>     [G] &lt;F xis&gt; : F xis ~ fsk   -- fsk is a FlatSkol
<a name="line-43"></a>     [W]       x : F xis ~ fmv   -- fmv is a unification variable,
<a name="line-44"></a>                                 -- but untouchable,
<a name="line-45"></a>                                 -- with MetaInfo = FlatMetaTv
<a name="line-46"></a>  where
<a name="line-47"></a>     x is the witness variable
<a name="line-48"></a>     fsk/fmv is a flatten skolem
<a name="line-49"></a>     xis are function-free
<a name="line-50"></a>  CFunEqCans are always [Wanted], or [Given], never [Derived]
<a name="line-51"></a>
<a name="line-52"></a>  fmv untouchable just means that in a CTyVarEq, say,
<a name="line-53"></a>       fmv ~ Int
<a name="line-54"></a>  we do NOT unify fmv.
<a name="line-55"></a>
<a name="line-56"></a>* KEY INSIGHTS:
<a name="line-57"></a>
<a name="line-58"></a>   - A given flatten-skolem, fsk, is known a-priori to be equal to
<a name="line-59"></a>     F xis (the LHS), with &lt;F xis&gt; evidence
<a name="line-60"></a>
<a name="line-61"></a>   - A unification flatten-skolem, fmv, stands for the as-yet-unknown
<a name="line-62"></a>     type to which (F xis) will eventually reduce
<a name="line-63"></a>
<a name="line-64"></a>* Inert set invariant: if F xis1 ~ fsk1, F xis2 ~ fsk2
<a name="line-65"></a>                       then xis1 /= xis2
<a name="line-66"></a>  i.e. at most one CFunEqCan with a particular LHS
<a name="line-67"></a>
<a name="line-68"></a>* Each canonical CFunEqCan x : F xis ~ fsk/fmv has its own
<a name="line-69"></a>  distinct evidence variable x and flatten-skolem fsk/fmv.
<a name="line-70"></a>  Why? We make a fresh fsk/fmv when the constraint is born;
<a name="line-71"></a>  and we never rewrite the RHS of a CFunEqCan.
<a name="line-72"></a>
<a name="line-73"></a>* Function applications can occur in the RHS of a CTyEqCan.  No reason
<a name="line-74"></a>  not allow this, and it reduces the amount of flattening that must occur.
<a name="line-75"></a>
<a name="line-76"></a>* Flattening a type (F xis):
<a name="line-77"></a>    - If we are flattening in a Wanted/Derived constraint
<a name="line-78"></a>      then create new [W] x : F xis ~ fmv
<a name="line-79"></a>      else create new [G] x : F xis ~ fsk
<a name="line-80"></a>      with fresh evidence variable x and flatten-skolem fsk/fmv
<a name="line-81"></a>
<a name="line-82"></a>    - Add it to the work list
<a name="line-83"></a>
<a name="line-84"></a>    - Replace (F xis) with fsk/fmv in the type you are flattening
<a name="line-85"></a>
<a name="line-86"></a>    - You can also add the CFunEqCan to the "flat cache", which
<a name="line-87"></a>      simply keeps track of all the function applications you
<a name="line-88"></a>      have flattened.
<a name="line-89"></a>
<a name="line-90"></a>    - If (F xis) is in the cache already, just
<a name="line-91"></a>      use its fsk/fmv and evidence x, and emit nothing.
<a name="line-92"></a>
<a name="line-93"></a>    - No need to substitute in the flat-cache. It's not the end
<a name="line-94"></a>      of the world if we start with, say (F alpha ~ fmv1) and
<a name="line-95"></a>      (F Int ~ fmv2) and then find alpha := Int.  Athat will
<a name="line-96"></a>      simply give rise to fmv1 := fmv2 via [Interacting rule] below
<a name="line-97"></a>
<a name="line-98"></a>* Canonicalising a CFunEqCan [G/W] x : F xis ~ fsk/fmv
<a name="line-99"></a>    - Flatten xis (to substitute any tyvars; there are already no functions)
<a name="line-100"></a>                  cos :: xis ~ flat_xis
<a name="line-101"></a>    - New wanted  x2 :: F flat_xis ~ fsk/fmv
<a name="line-102"></a>    - Add new wanted to flat cache
<a name="line-103"></a>    - Discharge x = F cos ; x2
<a name="line-104"></a>
<a name="line-105"></a>* Unification flatten-skolems, fmv, ONLY get unified when either
<a name="line-106"></a>    a) The CFunEqCan takes a step, using an axiom
<a name="line-107"></a>    b) During un-flattening
<a name="line-108"></a>  They are never unified in any other form of equality.
<a name="line-109"></a>  For example [W] ffmv ~ Int  is stuck; it does not unify with fmv.
<a name="line-110"></a>
<a name="line-111"></a>* We *never* substitute in the RHS (i.e. the fsk/fmv) of a CFunEqCan.
<a name="line-112"></a>  That would destroy the invariant about the shape of a CFunEqCan,
<a name="line-113"></a>  and it would risk wanted/wanted interactions. The only way we
<a name="line-114"></a>  learn information about fsk is when the CFunEqCan takes a step.
<a name="line-115"></a>
<a name="line-116"></a>  However we *do* substitute in the LHS of a CFunEqCan (else it
<a name="line-117"></a>  would never get to fire!)
<a name="line-118"></a>
<a name="line-119"></a>* [Interacting rule]
<a name="line-120"></a>    (inert)     [W] x1 : F tys ~ fmv1
<a name="line-121"></a>    (work item) [W] x2 : F tys ~ fmv2
<a name="line-122"></a>  Just solve one from the other:
<a name="line-123"></a>    x2 := x1
<a name="line-124"></a>    fmv2 := fmv1
<a name="line-125"></a>  This just unites the two fsks into one.
<a name="line-126"></a>  Always solve given from wanted if poss.
<a name="line-127"></a>
<a name="line-128"></a>* For top-level reductions, see Note [Top-level reductions for type functions]
<a name="line-129"></a>  in TcInteract
<a name="line-130"></a>
<a name="line-131"></a>
<a name="line-132"></a>Why given-fsks, alone, doesn't work
<a name="line-133"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-134"></a>Could we get away with only flatten meta-tyvars, with no flatten-skolems? No.
<a name="line-135"></a>
<a name="line-136"></a>  [W] w : alpha ~ [F alpha Int]
<a name="line-137"></a>
<a name="line-138"></a>---&gt; flatten
<a name="line-139"></a>  w = ...w'...
<a name="line-140"></a>  [W] w' : alpha ~ [fsk]
<a name="line-141"></a>  [G] &lt;F alpha Int&gt; : F alpha Int ~ fsk
<a name="line-142"></a>
<a name="line-143"></a>--&gt; unify (no occurs check)
<a name="line-144"></a>  alpha := [fsk]
<a name="line-145"></a>
<a name="line-146"></a>But since fsk = F alpha Int, this is really an occurs check error.  If
<a name="line-147"></a>that is all we know about alpha, we will succeed in constraint
<a name="line-148"></a>solving, producing a program with an infinite type.
<a name="line-149"></a>
<a name="line-150"></a>Even if we did finally get (g : fsk ~ Boo)l by solving (F alpha Int ~ fsk)
<a name="line-151"></a>using axiom, zonking would not see it, so (x::alpha) sitting in the
<a name="line-152"></a>tree will get zonked to an infinite type.  (Zonking always only does
<a name="line-153"></a>refl stuff.)
<a name="line-154"></a>
<a name="line-155"></a>Why flatten-meta-vars, alone doesn't work
<a name="line-156"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-157"></a>Look at Simple13, with unification-fmvs only
<a name="line-158"></a>
<a name="line-159"></a>  [G] g : a ~ [F a]
<a name="line-160"></a>
<a name="line-161"></a>---&gt; Flatten given
<a name="line-162"></a>  g' = g;[x]
<a name="line-163"></a>  [G] g'  : a ~ [fmv]
<a name="line-164"></a>  [W] x : F a ~ fmv
<a name="line-165"></a>
<a name="line-166"></a>--&gt; subst a in x
<a name="line-167"></a>       x = F g' ; x2
<a name="line-168"></a>   [W] x2 : F [fmv] ~ fmv
<a name="line-169"></a>
<a name="line-170"></a>And now we have an evidence cycle between g' and x!
<a name="line-171"></a>
<a name="line-172"></a>If we used a given instead (ie current story)
<a name="line-173"></a>
<a name="line-174"></a>  [G] g : a ~ [F a]
<a name="line-175"></a>
<a name="line-176"></a>---&gt; Flatten given
<a name="line-177"></a>  g' = g;[x]
<a name="line-178"></a>  [G] g'  : a ~ [fsk]
<a name="line-179"></a>  [G] &lt;F a&gt; : F a ~ fsk
<a name="line-180"></a>
<a name="line-181"></a>---&gt; Substitute for a
<a name="line-182"></a>  [G] g'  : a ~ [fsk]
<a name="line-183"></a>  [G] F (sym g'); &lt;F a&gt; : F [fsk] ~ fsk
<a name="line-184"></a>
<a name="line-185"></a>
<a name="line-186"></a>Why is it right to treat fmv's differently to ordinary unification vars?
<a name="line-187"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-188"></a>  f :: forall a. a -&gt; a -&gt; Bool
<a name="line-189"></a>  g :: F Int -&gt; F Int -&gt; Bool
<a name="line-190"></a>
<a name="line-191"></a>Consider
<a name="line-192"></a>  f (x:Int) (y:Bool)
<a name="line-193"></a>This gives alpha~Int, alpha~Bool.  There is an inconsistency,
<a name="line-194"></a>but really only one error.  SherLoc may tell you which location
<a name="line-195"></a>is most likely, based on other occurrences of alpha.
<a name="line-196"></a>
<a name="line-197"></a>Consider
<a name="line-198"></a>  g (x:Int) (y:Bool)
<a name="line-199"></a>Here we get (F Int ~ Int, F Int ~ Bool), which flattens to
<a name="line-200"></a>  (fmv ~ Int, fmv ~ Bool)
<a name="line-201"></a>But there are really TWO separate errors.
<a name="line-202"></a>
<a name="line-203"></a>  ** We must not complain about Int~Bool. **
<a name="line-204"></a>
<a name="line-205"></a>Moreover these two errors could arise in entirely unrelated parts of
<a name="line-206"></a>the code.  (In the alpha case, there must be *some* connection (eg
<a name="line-207"></a>v:alpha in common envt).)
<a name="line-208"></a>
<a name="line-209"></a>Note [Orientation of equalities with fmvs] and
<a name="line-210"></a>Note [Unflattening can force the solver to iterate]
<a name="line-211"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-212"></a>Here is a bad dilemma concerning flatten meta-vars (fmvs).
<a name="line-213"></a>
<a name="line-214"></a>This example comes from IndTypesPerfMerge, T10226, T10009.
<a name="line-215"></a>From the ambiguity check for
<a name="line-216"></a>  f :: (F a ~ a) =&gt; a
<a name="line-217"></a>we get:
<a name="line-218"></a>      [G] F a ~ a
<a name="line-219"></a>      [W] F alpha ~ alpha, alpha ~ a
<a name="line-220"></a>
<a name="line-221"></a>From Givens we get
<a name="line-222"></a>      [G] F a ~ fsk, fsk ~ a
<a name="line-223"></a>
<a name="line-224"></a>Now if we flatten we get
<a name="line-225"></a>      [W] alpha ~ fmv, F alpha ~ fmv, alpha ~ a
<a name="line-226"></a>
<a name="line-227"></a>Now, processing the first one first, choosing alpha := fmv
<a name="line-228"></a>      [W] F fmv ~ fmv, fmv ~ a
<a name="line-229"></a>
<a name="line-230"></a>And now we are stuck.  We must either *unify* fmv := a, or
<a name="line-231"></a>use the fmv ~ a to rewrite F fmv ~ fmv, so we can make it
<a name="line-232"></a>meet up with the given F a ~ blah.
<a name="line-233"></a>
<a name="line-234"></a>Old solution: always put fmvs on the left, so we get
<a name="line-235"></a>      [W] fmv ~ alpha, F alpha ~ fmv, alpha ~ a
<a name="line-236"></a>
<a name="line-237"></a>BUT this works badly for Trac #10340:
<a name="line-238"></a>     get :: MonadState s m =&gt; m s
<a name="line-239"></a>     instance MonadState s (State s) where ...
<a name="line-240"></a>
<a name="line-241"></a>     foo :: State Any Any
<a name="line-242"></a>     foo = get
<a name="line-243"></a>
<a name="line-244"></a>For 'foo' we instantiate 'get' at types mm ss
<a name="line-245"></a>       [W] MonadState ss mm, [W] mm ss ~ State Any Any
<a name="line-246"></a>Flatten, and decompose
<a name="line-247"></a>       [W] MonadState ss mm, [W] Any ~ fmv, [W] mm ~ State fmv, [W] fmv ~ ss
<a name="line-248"></a>Unify mm := State fmv:
<a name="line-249"></a>       [W] MonadState ss (State fmv), [W] Any ~ fmv, [W] fmv ~ ss
<a name="line-250"></a>If we orient with (untouchable) fmv on the left we are now stuck:
<a name="line-251"></a>alas, the instance does not match!!  But if instead we orient with
<a name="line-252"></a>(touchable) ss on the left, we unify ss:=fmv, to get
<a name="line-253"></a>       [W] MonadState fmv (State fmv), [W] Any ~ fmv
<a name="line-254"></a>Now we can solve.
<a name="line-255"></a>
<a name="line-256"></a>This is a real dilemma. CURRENT SOLUTION:
<a name="line-257"></a> * Orient with touchable variables on the left.  This is the
<a name="line-258"></a>   simple, uniform thing to do.  So we would orient ss ~ fmv,
<a name="line-259"></a>   not the other way round.
<a name="line-260"></a>
<a name="line-261"></a> * In the 'f' example, we get stuck with
<a name="line-262"></a>        F fmv ~ fmv, fmv ~ a
<a name="line-263"></a>   But during unflattening we will fail to dischargeFmv for the
<a name="line-264"></a>   CFunEqCan F fmv ~ fmv, because fmv := F fmv would make an ininite
<a name="line-265"></a>   type.  Instead we unify fmv:=a, AND record that we have done so.
<a name="line-266"></a>
<a name="line-267"></a>   If any such "non-CFunEqCan unifications" take place (in
<a name="line-268"></a>   unflatten_eq in TcFlatten.unflatten) iterate the entire process.
<a name="line-269"></a>   This is done by the 'go' loop in solveSimpleWanteds.
<a name="line-270"></a>
<a name="line-271"></a>This story does not feel right but it's the best I can do; and the
<a name="line-272"></a>iteration only happens in pretty obscure circumstances.
<a name="line-273"></a>
<a name="line-274"></a>
<a name="line-275"></a>************************************************************************
<a name="line-276"></a>*                                                                      *
<a name="line-277"></a>*                  Other notes (Oct 14)
<a name="line-278"></a>      I have not revisted these, but I didn't want to discard them
<a name="line-279"></a>*                                                                      *
<a name="line-280"></a>************************************************************************
<a name="line-281"></a>
<a name="line-282"></a>
<a name="line-283"></a>Try: rewrite wanted with wanted only for fmvs (not all meta-tyvars)
<a name="line-284"></a>
<a name="line-285"></a>But:   fmv ~ alpha[0]
<a name="line-286"></a>       alpha[0] ~ fmv’
<a name="line-287"></a>Now we don’t see that fmv ~ fmv’, which is a problem for injectivity detection.
<a name="line-288"></a>
<a name="line-289"></a>Conclusion: rewrite wanteds with wanted for all untouchables.
<a name="line-290"></a>
<a name="line-291"></a>skol ~ untch, must re-orieint to untch ~ skol, so that we can use it to rewrite.
<a name="line-292"></a>
<a name="line-293"></a>
<a name="line-294"></a>
<a name="line-295"></a>************************************************************************
<a name="line-296"></a>*                                                                      *
<a name="line-297"></a>*                  Examples
<a name="line-298"></a>     Here is a long series of examples I had to work through
<a name="line-299"></a>*                                                                      *
<a name="line-300"></a>************************************************************************
<a name="line-301"></a>
<a name="line-302"></a>Simple20
<a name="line-303"></a>~~~~~~~~
<a name="line-304"></a>axiom F [a] = [F a]
<a name="line-305"></a>
<a name="line-306"></a> [G] F [a] ~ a
<a name="line-307"></a>--&gt;
<a name="line-308"></a> [G] fsk ~ a
<a name="line-309"></a> [G] [F a] ~ fsk  (nc)
<a name="line-310"></a>--&gt;
<a name="line-311"></a> [G] F a ~ fsk2
<a name="line-312"></a> [G] fsk ~ [fsk2]
<a name="line-313"></a> [G] fsk ~ a
<a name="line-314"></a>--&gt;
<a name="line-315"></a> [G] F a ~ fsk2
<a name="line-316"></a> [G] a ~ [fsk2]
<a name="line-317"></a> [G] fsk ~ a
<a name="line-318"></a>
<a name="line-319"></a>
<a name="line-320"></a>-----------------------------------
<a name="line-321"></a>
<a name="line-322"></a>----------------------------------------
<a name="line-323"></a>indexed-types/should_compile/T44984
<a name="line-324"></a>
<a name="line-325"></a>  [W] H (F Bool) ~ H alpha
<a name="line-326"></a>  [W] alpha ~ F Bool
<a name="line-327"></a>--&gt;
<a name="line-328"></a>  F Bool  ~ fmv0
<a name="line-329"></a>  H fmv0  ~ fmv1
<a name="line-330"></a>  H alpha ~ fmv2
<a name="line-331"></a>
<a name="line-332"></a>  fmv1 ~ fmv2
<a name="line-333"></a>  fmv0 ~ alpha
<a name="line-334"></a>
<a name="line-335"></a>flatten
<a name="line-336"></a>~~~~~~~
<a name="line-337"></a>  fmv0  := F Bool
<a name="line-338"></a>  fmv1  := H (F Bool)
<a name="line-339"></a>  fmv2  := H alpha
<a name="line-340"></a>  alpha := F Bool
<a name="line-341"></a>plus
<a name="line-342"></a>  fmv1 ~ fmv2
<a name="line-343"></a>
<a name="line-344"></a>But these two are equal under the above assumptions.
<a name="line-345"></a>Solve by Refl.
<a name="line-346"></a>
<a name="line-347"></a>
<a name="line-348"></a>--- under plan B, namely solve fmv1:=fmv2 eagerly ---
<a name="line-349"></a>  [W] H (F Bool) ~ H alpha
<a name="line-350"></a>  [W] alpha ~ F Bool
<a name="line-351"></a>--&gt;
<a name="line-352"></a>  F Bool  ~ fmv0
<a name="line-353"></a>  H fmv0  ~ fmv1
<a name="line-354"></a>  H alpha ~ fmv2
<a name="line-355"></a>
<a name="line-356"></a>  fmv1 ~ fmv2
<a name="line-357"></a>  fmv0 ~ alpha
<a name="line-358"></a>--&gt;
<a name="line-359"></a>  F Bool  ~ fmv0
<a name="line-360"></a>  H fmv0  ~ fmv1
<a name="line-361"></a>  H alpha ~ fmv2    fmv2 := fmv1
<a name="line-362"></a>
<a name="line-363"></a>  fmv0 ~ alpha
<a name="line-364"></a>
<a name="line-365"></a>flatten
<a name="line-366"></a>  fmv0 := F Bool
<a name="line-367"></a>  fmv1 := H fmv0 = H (F Bool)
<a name="line-368"></a>  retain   H alpha ~ fmv2
<a name="line-369"></a>    because fmv2 has been filled
<a name="line-370"></a>  alpha := F Bool
<a name="line-371"></a>
<a name="line-372"></a>
<a name="line-373"></a>----------------------------
<a name="line-374"></a>indexed-types/should_failt/T4179
<a name="line-375"></a>
<a name="line-376"></a>after solving
<a name="line-377"></a>  [W] fmv_1 ~ fmv_2
<a name="line-378"></a>  [W] A3 (FCon x)           ~ fmv_1    (CFunEqCan)
<a name="line-379"></a>  [W] A3 (x (aoa -&gt; fmv_2)) ~ fmv_2    (CFunEqCan)
<a name="line-380"></a>
<a name="line-381"></a>----------------------------------------
<a name="line-382"></a>indexed-types/should_fail/T7729a
<a name="line-383"></a>
<a name="line-384"></a>a)  [W]   BasePrimMonad (Rand m) ~ m1
<a name="line-385"></a>b)  [W]   tt m1 ~ BasePrimMonad (Rand m)
<a name="line-386"></a>
<a name="line-387"></a>---&gt;  process (b) first
<a name="line-388"></a>    BasePrimMonad (Ramd m) ~ fmv_atH
<a name="line-389"></a>    fmv_atH ~ tt m1
<a name="line-390"></a>
<a name="line-391"></a>---&gt;  now process (a)
<a name="line-392"></a>    m1 ~ s_atH ~ tt m1    -- An obscure occurs check
<a name="line-393"></a>
<a name="line-394"></a>
<a name="line-395"></a>----------------------------------------
<a name="line-396"></a>typecheck/TcTypeNatSimple
<a name="line-397"></a>
<a name="line-398"></a>Original constraint
<a name="line-399"></a>  [W] x + y ~ x + alpha  (non-canonical)
<a name="line-400"></a>==&gt;
<a name="line-401"></a>  [W] x + y     ~ fmv1   (CFunEqCan)
<a name="line-402"></a>  [W] x + alpha ~ fmv2   (CFuneqCan)
<a name="line-403"></a>  [W] fmv1 ~ fmv2        (CTyEqCan)
<a name="line-404"></a>
<a name="line-405"></a>(sigh)
<a name="line-406"></a>
<a name="line-407"></a>----------------------------------------
<a name="line-408"></a>indexed-types/should_fail/GADTwrong1
<a name="line-409"></a>
<a name="line-410"></a>  [G] Const a ~ ()
<a name="line-411"></a>==&gt; flatten
<a name="line-412"></a>  [G] fsk ~ ()
<a name="line-413"></a>  work item: Const a ~ fsk
<a name="line-414"></a>==&gt; fire top rule
<a name="line-415"></a>  [G] fsk ~ ()
<a name="line-416"></a>  work item fsk ~ ()
<a name="line-417"></a>
<a name="line-418"></a>Surely the work item should rewrite to () ~ ()?  Well, maybe not;
<a name="line-419"></a>it'a very special case.  More generally, our givens look like
<a name="line-420"></a>F a ~ Int, where (F a) is not reducible.
<a name="line-421"></a>
<a name="line-422"></a>
<a name="line-423"></a>----------------------------------------
<a name="line-424"></a>indexed_types/should_fail/T8227:
<a name="line-425"></a>
<a name="line-426"></a>Why using a different can-rewrite rule in CFunEqCan heads
<a name="line-427"></a>does not work.
<a name="line-428"></a>
<a name="line-429"></a>Assuming NOT rewriting wanteds with wanteds
<a name="line-430"></a>
<a name="line-431"></a>   Inert: [W] fsk_aBh ~ fmv_aBk -&gt; fmv_aBk
<a name="line-432"></a>          [W] fmv_aBk ~ fsk_aBh
<a name="line-433"></a>
<a name="line-434"></a>          [G] Scalar fsk_aBg ~ fsk_aBh
<a name="line-435"></a>          [G] V a ~ f_aBg
<a name="line-436"></a>
<a name="line-437"></a>   Worklist includes  [W] Scalar fmv_aBi ~ fmv_aBk
<a name="line-438"></a>   fmv_aBi, fmv_aBk are flatten unificaiton variables
<a name="line-439"></a>
<a name="line-440"></a>   Work item: [W] V fsk_aBh ~ fmv_aBi
<a name="line-441"></a>
<a name="line-442"></a>Note that the inert wanteds are cyclic, because we do not rewrite
<a name="line-443"></a>wanteds with wanteds.
<a name="line-444"></a>
<a name="line-445"></a>
<a name="line-446"></a>Then we go into a loop when normalise the work-item, because we
<a name="line-447"></a>use rewriteOrSame on the argument of V.
<a name="line-448"></a>
<a name="line-449"></a>Conclusion: Don't make canRewrite context specific; instead use
<a name="line-450"></a>[W] a ~ ty to rewrite a wanted iff 'a' is a unification variable.
<a name="line-451"></a>
<a name="line-452"></a>
<a name="line-453"></a>----------------------------------------
<a name="line-454"></a>
<a name="line-455"></a>Here is a somewhat similar case:
<a name="line-456"></a>
<a name="line-457"></a>   type family G a :: *
<a name="line-458"></a>
<a name="line-459"></a>   blah :: (G a ~ Bool, Eq (G a)) =&gt; a -&gt; a
<a name="line-460"></a>   blah = error "urk"
<a name="line-461"></a>
<a name="line-462"></a>   foo x = blah x
<a name="line-463"></a>
<a name="line-464"></a>For foo we get
<a name="line-465"></a>   [W] Eq (G a), G a ~ Bool
<a name="line-466"></a>Flattening
<a name="line-467"></a>   [W] G a ~ fmv, Eq fmv, fmv ~ Bool
<a name="line-468"></a>We can't simplify away the Eq Bool unless we substitute for fmv.
<a name="line-469"></a>Maybe that doesn't matter: we would still be left with unsolved
<a name="line-470"></a>G a ~ Bool.
<a name="line-471"></a>
<a name="line-472"></a>--------------------------
<a name="line-473"></a>Trac #9318 has a very simple program leading to
<a name="line-474"></a>
<a name="line-475"></a>  [W] F Int ~ Int
<a name="line-476"></a>  [W] F Int ~ Bool
<a name="line-477"></a>
<a name="line-478"></a>We don't want to get "Error Int~Bool".  But if fmv's can rewrite
<a name="line-479"></a>wanteds, we will
<a name="line-480"></a>
<a name="line-481"></a>  [W] fmv ~ Int
<a name="line-482"></a>  [W] fmv ~ Bool
<a name="line-483"></a>---&gt;
<a name="line-484"></a>  [W] Int ~ Bool
<a name="line-485"></a>
<a name="line-486"></a>
<a name="line-487"></a>************************************************************************
<a name="line-488"></a>*                                                                      *
<a name="line-489"></a>*                FlattenEnv &amp; FlatM
<a name="line-490"></a>*             The flattening environment &amp; monad
<a name="line-491"></a>*                                                                      *
<a name="line-492"></a>************************************************************************
<a name="line-493"></a>
<a name="line-494"></a>-}</span>
<a name="line-495"></a>
<a name="line-496"></a><a name="FlatWorkListRef"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FlatWorkListRef</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcRef</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-497"></a>
<a name="line-498"></a><a name="FlattenEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-499"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span>
<a name="line-500"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span>              <span class='hs-comment'>-- See Note [Flattener CtLoc]</span>
<a name="line-501"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtFlavour</span>
<a name="line-502"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EqRel</span>              <span class='hs-comment'>-- See Note [Flattener EqRels]</span>
<a name="line-503"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_work</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatWorkListRef</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-504"></a>
<a name="line-505"></a><a name="FlattenMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenMode</span>  <span class='hs-comment'>-- Postcondition for all three: inert wrt the type substitution</span>
<a name="line-506"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FM_FlattenAll</span>          <span class='hs-comment'>-- Postcondition: function-free</span>
<a name="line-507"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FM_SubstOnly</span>           <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-508"></a>
<a name="line-509"></a><span class='hs-comment'>--  | FM_Avoid TcTyVar Bool  -- See Note [Lazy flattening]</span>
<a name="line-510"></a><span class='hs-comment'>--                           -- Postcondition:</span>
<a name="line-511"></a><span class='hs-comment'>--                           --  * tyvar is only mentioned in result under a rigid path</span>
<a name="line-512"></a><span class='hs-comment'>--                           --    e.g.   [a] is ok, but F a won't happen</span>
<a name="line-513"></a><span class='hs-comment'>--                           --  * If flat_top is True, top level is not a function application</span>
<a name="line-514"></a><span class='hs-comment'>--                           --   (but under type constructors is ok e.g. [F a])</span>
<a name="line-515"></a>
<a name="line-516"></a><a name="mkFlattenEnv"></a><span class='hs-definition'>mkFlattenEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatWorkListRef</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-517"></a><span class='hs-definition'>mkFlattenEnv</span> <span class='hs-varid'>fm</span> <span class='hs-varid'>ctev</span> <span class='hs-varid'>ref</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fm</span>
<a name="line-518"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ctev</span>
<a name="line-519"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ctev</span>
<a name="line-520"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ctev</span>
<a name="line-521"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>fe_work</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ref</span> <span class='hs-layout'>}</span>
<a name="line-522"></a>
<a name="line-523"></a><a name="FlatM"></a><span class='hs-comment'>-- | The 'FlatM' monad is a wrapper around 'TcS' with the following</span>
<a name="line-524"></a><a name="FlatM"></a><span class='hs-comment'>-- extra capabilities: (1) it offers access to a 'FlattenEnv';</span>
<a name="line-525"></a><a name="FlatM"></a><span class='hs-comment'>-- and (2) it maintains the flattening worklist.</span>
<a name="line-526"></a><a name="FlatM"></a><span class='hs-comment'>-- See Note [The flattening work list].</span>
<a name="line-527"></a><a name="FlatM"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-528"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>runFlatM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
<a name="line-529"></a>
<a name="line-530"></a><a name="instance%20Monad%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-531"></a>  <span class='hs-varid'>return</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span>
<a name="line-532"></a>  <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-533"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>env</span>
<a name="line-534"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>runFlatM</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span>
<a name="line-535"></a>
<a name="line-536"></a><a name="instance%20Functor%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-537"></a>  <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span>
<a name="line-538"></a>
<a name="line-539"></a><a name="instance%20Applicative%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-540"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>const</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-541"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-542"></a>
<a name="line-543"></a><a name="liftTcS"></a><span class='hs-definition'>liftTcS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-544"></a><span class='hs-definition'>liftTcS</span> <span class='hs-varid'>thing_inside</span>
<a name="line-545"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>const</span> <span class='hs-varid'>thing_inside</span>
<a name="line-546"></a>
<a name="line-547"></a><a name="emitFlatWork"></a><span class='hs-definition'>emitFlatWork</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-548"></a><span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-549"></a><span class='hs-definition'>emitFlatWork</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>updTcRef</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_work</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span>
<a name="line-550"></a>
<a name="line-551"></a><a name="runFlatten"></a><span class='hs-definition'>runFlatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span>
<a name="line-552"></a><span class='hs-comment'>-- Run thing_inside (which does flattening), and put all</span>
<a name="line-553"></a><span class='hs-comment'>-- the work it generates onto the main work list</span>
<a name="line-554"></a><span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-555"></a><span class='hs-comment'>-- NB: The returned evidence is always the same as the original, but with</span>
<a name="line-556"></a><span class='hs-comment'>-- perhaps a new CtLoc</span>
<a name="line-557"></a><span class='hs-definition'>runFlatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>thing_inside</span>
<a name="line-558"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>flat_ref</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcRef</span> <span class='hs-conid'>[]</span>
<a name="line-559"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFlattenEnv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>flat_ref</span>
<a name="line-560"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>fmode</span>
<a name="line-561"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTcRef</span> <span class='hs-varid'>flat_ref</span>
<a name="line-562"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>add_flats</span> <span class='hs-varid'>new_flats</span><span class='hs-layout'>)</span>
<a name="line-563"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-564"></a>  <span class='hs-keyword'>where</span>
<a name="line-565"></a>    <span class='hs-varid'>add_flats</span> <span class='hs-varid'>new_flats</span> <span class='hs-varid'>wl</span>
<a name="line-566"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wl_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_funeqs</span> <span class='hs-varid'>new_flats</span> <span class='hs-layout'>(</span><span class='hs-varid'>wl_funeqs</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-567"></a>
<a name="line-568"></a>    <span class='hs-varid'>add_funeqs</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>wl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span>
<a name="line-569"></a>    <span class='hs-varid'>add_funeqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>fs</span><span class='hs-layout'>)</span> <span class='hs-varid'>wl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_funeqs</span> <span class='hs-varid'>fs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>wl</span><span class='hs-layout'>)</span>
<a name="line-570"></a>      <span class='hs-comment'>-- add_funeqs fs ws = reverse fs ++ ws</span>
<a name="line-571"></a>      <span class='hs-comment'>-- e.g. add_funeqs [f1,f2,f3] [w1,w2,w3,w4]</span>
<a name="line-572"></a>      <span class='hs-comment'>--        = [f3,f2,f1,w1,w2,w3,w4]</span>
<a name="line-573"></a>
<a name="line-574"></a><a name="traceFlat"></a><span class='hs-definition'>traceFlat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-575"></a><span class='hs-definition'>traceFlat</span> <span class='hs-varid'>herald</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceTcS</span> <span class='hs-varid'>herald</span> <span class='hs-varid'>doc</span>
<a name="line-576"></a>
<a name="line-577"></a><a name="getFlatEnvField"></a><span class='hs-definition'>getFlatEnvField</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-578"></a><span class='hs-definition'>getFlatEnvField</span> <span class='hs-varid'>accessor</span>
<a name="line-579"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>accessor</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-580"></a>
<a name="line-581"></a><a name="getEqRel"></a><span class='hs-definition'>getEqRel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>EqRel</span>
<a name="line-582"></a><span class='hs-definition'>getEqRel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_eq_rel</span>
<a name="line-583"></a>
<a name="line-584"></a><a name="getRole"></a><span class='hs-definition'>getRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>Role</span>
<a name="line-585"></a><span class='hs-definition'>getRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getEqRel</span>
<a name="line-586"></a>
<a name="line-587"></a><a name="getFlavour"></a><span class='hs-definition'>getFlavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtFlavour</span>
<a name="line-588"></a><span class='hs-definition'>getFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_flavour</span>
<a name="line-589"></a>
<a name="line-590"></a><a name="getFlavourRole"></a><span class='hs-definition'>getFlavourRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtFlavourRole</span>
<a name="line-591"></a><span class='hs-definition'>getFlavourRole</span>
<a name="line-592"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>flavour</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-593"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-594"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>flavour</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-595"></a>
<a name="line-596"></a><a name="getMode"></a><span class='hs-definition'>getMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenMode</span>
<a name="line-597"></a><span class='hs-definition'>getMode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_mode</span>
<a name="line-598"></a>
<a name="line-599"></a><a name="getLoc"></a><span class='hs-definition'>getLoc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtLoc</span>
<a name="line-600"></a><span class='hs-definition'>getLoc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_loc</span>
<a name="line-601"></a>
<a name="line-602"></a><a name="checkStackDepth"></a><span class='hs-definition'>checkStackDepth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-603"></a><span class='hs-definition'>checkStackDepth</span> <span class='hs-varid'>ty</span>
<a name="line-604"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLoc</span>
<a name="line-605"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>checkReductionDepth</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-606"></a>
<a name="line-607"></a><a name="setEqRel"></a><span class='hs-comment'>-- | Change the 'EqRel' in a 'FlatM'.</span>
<a name="line-608"></a><span class='hs-definition'>setEqRel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-609"></a><span class='hs-definition'>setEqRel</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-varid'>thing_inside</span>
<a name="line-610"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-611"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>env</span>
<a name="line-612"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span>
<a name="line-613"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-614"></a>
<a name="line-615"></a><a name="setMode"></a><span class='hs-comment'>-- | Change the 'FlattenMode' in a 'FlattenEnv'.</span>
<a name="line-616"></a><span class='hs-definition'>setMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-617"></a><span class='hs-definition'>setMode</span> <span class='hs-varid'>new_mode</span> <span class='hs-varid'>thing_inside</span>
<a name="line-618"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-619"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>new_mode</span> <span class='hs-varop'>`eq`</span> <span class='hs-varid'>fe_mode</span> <span class='hs-varid'>env</span>
<a name="line-620"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span>
<a name="line-621"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_mode</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-622"></a>  <span class='hs-keyword'>where</span>
<a name="line-623"></a>    <span class='hs-conid'>FM_FlattenAll</span>   <span class='hs-varop'>`eq`</span> <span class='hs-conid'>FM_FlattenAll</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-624"></a>    <span class='hs-conid'>FM_SubstOnly</span>    <span class='hs-varop'>`eq`</span> <span class='hs-conid'>FM_SubstOnly</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-625"></a><span class='hs-comment'>--  FM_Avoid tv1 b1 `eq` FM_Avoid tv2 b2 = tv1 == tv2 &amp;&amp; b1 == b2</span>
<a name="line-626"></a>    <span class='hs-keyword'>_</span>               <span class='hs-varop'>`eq`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-627"></a>
<a name="line-628"></a><a name="flattenKinds"></a><span class='hs-comment'>-- | Use when flattening kinds/kind coercions. See</span>
<a name="line-629"></a><span class='hs-comment'>-- Note [No derived kind equalities] in TcCanonical</span>
<a name="line-630"></a><span class='hs-definition'>flattenKinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-631"></a><span class='hs-definition'>flattenKinds</span> <span class='hs-varid'>thing_inside</span>
<a name="line-632"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-633"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>kind_flav</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-634"></a>                      <span class='hs-conid'>Given</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Given</span>
<a name="line-635"></a>                      <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Wanted</span>
<a name="line-636"></a>    <span class='hs-keyword'>in</span>
<a name="line-637"></a>    <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>kind_flav</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-638"></a>
<a name="line-639"></a><a name="bumpDepth"></a><span class='hs-definition'>bumpDepth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-640"></a><span class='hs-definition'>bumpDepth</span> <span class='hs-layout'>(</span><span class='hs-conid'>FlatM</span> <span class='hs-varid'>thing_inside</span><span class='hs-layout'>)</span>
<a name="line-641"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_loc</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-642"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>}</span>
<a name="line-643"></a>
<a name="line-644"></a><a name="newFlattenSkolemFlatM"></a><span class='hs-comment'>-- Flatten skolems</span>
<a name="line-645"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-646"></a><span class='hs-definition'>newFlattenSkolemFlatM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcType</span>         <span class='hs-comment'>-- F xis</span>
<a name="line-647"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>CtEvidence</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- [W] x:: F xis ~ fsk</span>
<a name="line-648"></a><span class='hs-definition'>newFlattenSkolemFlatM</span> <span class='hs-varid'>ty</span>
<a name="line-649"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>flavour</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-650"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLoc</span>
<a name="line-651"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>newFlattenSkolem</span> <span class='hs-varid'>flavour</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-652"></a>
<a name="line-653"></a><span class='hs-comment'>{-
<a name="line-654"></a>Note [The flattening work list]
<a name="line-655"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-656"></a>The "flattening work list", held in the fe_work field of FlattenEnv,
<a name="line-657"></a>is a list of CFunEqCans generated during flattening.  The key idea
<a name="line-658"></a>is this.  Consider flattening (Eq (F (G Int) (H Bool)):
<a name="line-659"></a>  * The flattener recursively calls itself on sub-terms before building
<a name="line-660"></a>    the main term, so it will encounter the terms in order
<a name="line-661"></a>              G Int
<a name="line-662"></a>              H Bool
<a name="line-663"></a>              F (G Int) (H Bool)
<a name="line-664"></a>    flattening to sub-goals
<a name="line-665"></a>              w1: G Int ~ fuv0
<a name="line-666"></a>              w2: H Bool ~ fuv1
<a name="line-667"></a>              w3: F fuv0 fuv1 ~ fuv2
<a name="line-668"></a>
<a name="line-669"></a>  * Processing w3 first is BAD, because we can't reduce i t,so it'll
<a name="line-670"></a>    get put into the inert set, and later kicked out when w1, w2 are
<a name="line-671"></a>    solved.  In Trac #9872 this led to inert sets containing hundreds
<a name="line-672"></a>    of suspended calls.
<a name="line-673"></a>
<a name="line-674"></a>  * So we want to process w1, w2 first.
<a name="line-675"></a>
<a name="line-676"></a>  * So you might think that we should just use a FIFO deque for the work-list,
<a name="line-677"></a>    so that putting adding goals in order w1,w2,w3 would mean we processed
<a name="line-678"></a>    w1 first.
<a name="line-679"></a>
<a name="line-680"></a>  * BUT suppose we have 'type instance G Int = H Char'.  Then processing
<a name="line-681"></a>    w1 leads to a new goal
<a name="line-682"></a>                w4: H Char ~ fuv0
<a name="line-683"></a>    We do NOT want to put that on the far end of a deque!  Instead we want
<a name="line-684"></a>    to put it at the *front* of the work-list so that we continue to work
<a name="line-685"></a>    on it.
<a name="line-686"></a>
<a name="line-687"></a>So the work-list structure is this:
<a name="line-688"></a>
<a name="line-689"></a>  * The wl_funeqs (in TcS) is a LIFO stack; we push new goals (such as w4) on
<a name="line-690"></a>    top (extendWorkListFunEq), and take new work from the top
<a name="line-691"></a>    (selectWorkItem).
<a name="line-692"></a>
<a name="line-693"></a>  * When flattening, emitFlatWork pushes new flattening goals (like
<a name="line-694"></a>    w1,w2,w3) onto the flattening work list, fe_work, another
<a name="line-695"></a>    push-down stack.
<a name="line-696"></a>
<a name="line-697"></a>  * When we finish flattening, we *reverse* the fe_work stack
<a name="line-698"></a>    onto the wl_funeqs stack (which brings w1 to the top).
<a name="line-699"></a>
<a name="line-700"></a>The function runFlatten initialises the fe_work stack, and reverses
<a name="line-701"></a>it onto wl_fun_eqs at the end.
<a name="line-702"></a>
<a name="line-703"></a>Note [Flattener EqRels]
<a name="line-704"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-705"></a>When flattening, we need to know which equality relation -- nominal
<a name="line-706"></a>or representation -- we should be respecting. The only difference is
<a name="line-707"></a>that we rewrite variables by representational equalities when fe_eq_rel
<a name="line-708"></a>is ReprEq, and that we unwrap newtypes when flattening w.r.t.
<a name="line-709"></a>representational equality.
<a name="line-710"></a>
<a name="line-711"></a>Note [Flattener CtLoc]
<a name="line-712"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-713"></a>The flattener does eager type-family reduction.
<a name="line-714"></a>Type families might loop, and we
<a name="line-715"></a>don't want GHC to do so. A natural solution is to have a bounded depth
<a name="line-716"></a>to these processes. A central difficulty is that such a solution isn't
<a name="line-717"></a>quite compositional. For example, say it takes F Int 10 steps to get to Bool.
<a name="line-718"></a>How many steps does it take to get from F Int -&gt; F Int to Bool -&gt; Bool?
<a name="line-719"></a>10? 20? What about getting from Const Char (F Int) to Char? 11? 1? Hard to
<a name="line-720"></a>know and hard to track. So, we punt, essentially. We store a CtLoc in
<a name="line-721"></a>the FlattenEnv and just update the environment when recurring. In the
<a name="line-722"></a>TyConApp case, where there may be multiple type families to flatten,
<a name="line-723"></a>we just copy the current CtLoc into each branch. If any branch hits the
<a name="line-724"></a>stack limit, then the whole thing fails.
<a name="line-725"></a>
<a name="line-726"></a>A consequence of this is that setting the stack limits appropriately
<a name="line-727"></a>will be essentially impossible. So, the official recommendation if a
<a name="line-728"></a>stack limit is hit is to disable the check entirely. Otherwise, there
<a name="line-729"></a>will be baffling, unpredictable errors.
<a name="line-730"></a>
<a name="line-731"></a>Note [Lazy flattening]
<a name="line-732"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-733"></a>The idea of FM_Avoid mode is to flatten less aggressively.  If we have
<a name="line-734"></a>       a ~ [F Int]
<a name="line-735"></a>there seems to be no great merit in lifting out (F Int).  But if it was
<a name="line-736"></a>       a ~ [G a Int]
<a name="line-737"></a>then we *do* want to lift it out, in case (G a Int) reduces to Bool, say,
<a name="line-738"></a>which gets rid of the occurs-check problem.  (For the flat_top Bool, see
<a name="line-739"></a>comments above and at call sites.)
<a name="line-740"></a>
<a name="line-741"></a>HOWEVER, the lazy flattening actually seems to make type inference go
<a name="line-742"></a>*slower*, not faster.  perf/compiler/T3064 is a case in point; it gets
<a name="line-743"></a>*dramatically* worse with FM_Avoid.  I think it may be because
<a name="line-744"></a>floating the types out means we normalise them, and that often makes
<a name="line-745"></a>them smaller and perhaps allows more re-use of previously solved
<a name="line-746"></a>goals.  But to be honest I'm not absolutely certain, so I am leaving
<a name="line-747"></a>FM_Avoid in the code base.  What I'm removing is the unique place
<a name="line-748"></a>where it is *used*, namely in TcCanonical.canEqTyVar.
<a name="line-749"></a>
<a name="line-750"></a>See also Note [Conservative unification check] in TcUnify, which gives
<a name="line-751"></a>other examples where lazy flattening caused problems.
<a name="line-752"></a>
<a name="line-753"></a>Bottom line: FM_Avoid is unused for now (Nov 14).
<a name="line-754"></a>Note: T5321Fun got faster when I disabled FM_Avoid
<a name="line-755"></a>      T5837 did too, but it's pathalogical anyway
<a name="line-756"></a>
<a name="line-757"></a>Note [Phantoms in the flattener]
<a name="line-758"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-759"></a>Suppose we have
<a name="line-760"></a>
<a name="line-761"></a>data Proxy p = Proxy
<a name="line-762"></a>
<a name="line-763"></a>and we're flattening (Proxy ty) w.r.t. ReprEq. Then, we know that `ty`
<a name="line-764"></a>is really irrelevant -- it will be ignored when solving for representational
<a name="line-765"></a>equality later on. So, we omit flattening `ty` entirely. This may
<a name="line-766"></a>violate the expectation of "xi"s for a bit, but the canonicaliser will
<a name="line-767"></a>soon throw out the phantoms when decomposing a TyConApp. (Or, the
<a name="line-768"></a>canonicaliser will emit an insoluble, in which case the unflattened version
<a name="line-769"></a>yields a better error message anyway.)
<a name="line-770"></a>
<a name="line-771"></a>-}</span>
<a name="line-772"></a>
<a name="line-773"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-774"></a>*                                                                      *
<a name="line-775"></a>*      Externally callable flattening functions                        *
<a name="line-776"></a>*                                                                      *
<a name="line-777"></a>*  They are all wrapped in runFlatten, so their                        *
<a name="line-778"></a>*  flattening work gets put into the work list                         *
<a name="line-779"></a>*                                                                      *
<a name="line-780"></a>********************************************************************* -}</span>
<a name="line-781"></a>
<a name="line-782"></a><a name="flatten"></a><span class='hs-definition'>flatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>
<a name="line-783"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-784"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty</span>
<a name="line-785"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-786"></a>
<a name="line-787"></a><a name="flattenManyNom"></a><span class='hs-definition'>flattenManyNom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-788"></a><span class='hs-comment'>-- Externally-callable, hence runFlatten</span>
<a name="line-789"></a><span class='hs-comment'>-- Flatten a bunch of types all at once; in fact they are</span>
<a name="line-790"></a><span class='hs-comment'>-- always the arguments of a saturated type-family, so</span>
<a name="line-791"></a><span class='hs-comment'>--      ctEvFlavour ev = Nominal</span>
<a name="line-792"></a><span class='hs-comment'>-- and we want to flatten all at nominal role</span>
<a name="line-793"></a><span class='hs-definition'>flattenManyNom</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tys</span>
<a name="line-794"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-795"></a>
<a name="line-796"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-797"></a>*                                                                      *
<a name="line-798"></a>*           The main flattening functions
<a name="line-799"></a>*                                                                      *
<a name="line-800"></a>********************************************************************* -}</span>
<a name="line-801"></a>
<a name="line-802"></a><span class='hs-comment'>{- Note [Flattening]
<a name="line-803"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-804"></a>  flatten ty  ==&gt;   (xi, co)
<a name="line-805"></a>    where
<a name="line-806"></a>      xi has no type functions, unless they appear under ForAlls
<a name="line-807"></a>      co :: xi ~ ty
<a name="line-808"></a>
<a name="line-809"></a>Note that it is flatten's job to flatten *every type function it sees*.
<a name="line-810"></a>flatten is only called on *arguments* to type functions, by canEqGiven.
<a name="line-811"></a>
<a name="line-812"></a>Flattening also:
<a name="line-813"></a>  * zonks, removing any metavariables, and
<a name="line-814"></a>  * applies the substitution embodied in the inert set
<a name="line-815"></a>
<a name="line-816"></a>Because flattening zonks and the returned coercion ("co" above) is also
<a name="line-817"></a>zonked, it's possible that (co :: xi ~ ty) isn't quite true, as ty (the
<a name="line-818"></a>input to the flattener) might not be zonked. After zonking everything,
<a name="line-819"></a>(co :: xi ~ ty) will be true, however. It is for this reason that we
<a name="line-820"></a>occasionally have to explicitly zonk, when (co :: xi ~ ty) is important
<a name="line-821"></a>even before we zonk the whole program. (In particular, this is why the
<a name="line-822"></a>zonk in flatten_tyvar3 is necessary.)
<a name="line-823"></a>
<a name="line-824"></a>Flattening a type also means flattening its kind. In the case of a type
<a name="line-825"></a>variable whose kind mentions a type family, this might mean that the result
<a name="line-826"></a>of flattening has a cast in it.
<a name="line-827"></a>
<a name="line-828"></a>Recall that in comments we use alpha[flat = ty] to represent a
<a name="line-829"></a>flattening skolem variable alpha which has been generated to stand in
<a name="line-830"></a>for ty.
<a name="line-831"></a>
<a name="line-832"></a>----- Example of flattening a constraint: ------
<a name="line-833"></a>  flatten (List (F (G Int)))  ==&gt;  (xi, cc)
<a name="line-834"></a>    where
<a name="line-835"></a>      xi  = List alpha
<a name="line-836"></a>      cc  = { G Int ~ beta[flat = G Int],
<a name="line-837"></a>              F beta ~ alpha[flat = F beta] }
<a name="line-838"></a>Here
<a name="line-839"></a>  * alpha and beta are 'flattening skolem variables'.
<a name="line-840"></a>  * All the constraints in cc are 'given', and all their coercion terms
<a name="line-841"></a>    are the identity.
<a name="line-842"></a>
<a name="line-843"></a>NB: Flattening Skolems only occur in canonical constraints, which
<a name="line-844"></a>are never zonked, so we don't need to worry about zonking doing
<a name="line-845"></a>accidental unflattening.
<a name="line-846"></a>
<a name="line-847"></a>Note that we prefer to leave type synonyms unexpanded when possible,
<a name="line-848"></a>so when the flattener encounters one, it first asks whether its
<a name="line-849"></a>transitive expansion contains any type function applications.  If so,
<a name="line-850"></a>it expands the synonym and proceeds; if not, it simply returns the
<a name="line-851"></a>unexpanded synonym.
<a name="line-852"></a>
<a name="line-853"></a>Note [flatten_many performance]
<a name="line-854"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-855"></a>In programs with lots of type-level evaluation, flatten_many becomes
<a name="line-856"></a>part of a tight loop. For example, see test perf/compiler/T9872a, which
<a name="line-857"></a>calls flatten_many a whopping 7,106,808 times. It is thus important
<a name="line-858"></a>that flatten_many be efficient.
<a name="line-859"></a>
<a name="line-860"></a>Performance testing showed that the current implementation is indeed
<a name="line-861"></a>efficient. It's critically important that zipWithAndUnzipM be
<a name="line-862"></a>specialized to TcS, and it's also quite helpful to actually `inline`
<a name="line-863"></a>it. On test T9872a, here are the allocation stats (Dec 16, 2014):
<a name="line-864"></a>
<a name="line-865"></a> * Unspecialized, uninlined:     8,472,613,440 bytes allocated in the heap
<a name="line-866"></a> * Specialized, uninlined:       6,639,253,488 bytes allocated in the heap
<a name="line-867"></a> * Specialized, inlined:         6,281,539,792 bytes allocated in the heap
<a name="line-868"></a>
<a name="line-869"></a>To improve performance even further, flatten_many_nom is split off
<a name="line-870"></a>from flatten_many, as nominal equality is the common case. This would
<a name="line-871"></a>be natural to write using mapAndUnzipM, but even inlined, that function
<a name="line-872"></a>is not as performant as a hand-written loop.
<a name="line-873"></a>
<a name="line-874"></a> * mapAndUnzipM, inlined:        7,463,047,432 bytes allocated in the heap
<a name="line-875"></a> * hand-written recursion:       5,848,602,848 bytes allocated in the heap
<a name="line-876"></a>
<a name="line-877"></a>If you make any change here, pay close attention to the T9872{a,b,c} tests
<a name="line-878"></a>and T5321Fun.
<a name="line-879"></a>
<a name="line-880"></a>If we need to make this yet more performant, a possible way forward is to
<a name="line-881"></a>duplicate the flattener code for the nominal case, and make that case
<a name="line-882"></a>faster. This doesn't seem quite worth it, yet.
<a name="line-883"></a>-}</span>
<a name="line-884"></a>
<a name="line-885"></a><a name="flatten_many"></a><span class='hs-definition'>flatten_many</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-886"></a><span class='hs-comment'>-- Coercions :: Xi ~ Type, at roles given</span>
<a name="line-887"></a><span class='hs-comment'>-- Returns True iff (no flattening happened)</span>
<a name="line-888"></a><span class='hs-comment'>-- NB: The EvVar inside the 'fe_ev :: CtEvidence' is unused,</span>
<a name="line-889"></a><span class='hs-comment'>--     we merely want (a) Given/Solved/Derived/Wanted info</span>
<a name="line-890"></a><span class='hs-comment'>--                    (b) the GivenLoc/WantedLoc for when we create new evidence</span>
<a name="line-891"></a><span class='hs-definition'>flatten_many</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-892"></a><span class='hs-comment'>-- See Note [flatten_many performance]</span>
<a name="line-893"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>zipWithAndUnzipM</span> <span class='hs-varid'>go</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-894"></a>  <span class='hs-keyword'>where</span>
<a name="line-895"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Nominal</span>          <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>NomEq</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-896"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-897"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Phantom</span>          <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [Phantoms in the flattener]</span>
<a name="line-898"></a>                             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>ty</span>
<a name="line-899"></a>                                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Phantom</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-900"></a>
<a name="line-901"></a><a name="flatten_many_nom"></a><span class='hs-comment'>-- | Like 'flatten_many', but assumes that every role is nominal.</span>
<a name="line-902"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-903"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-904"></a><span class='hs-comment'>-- See Note [flatten_many performance]</span>
<a name="line-905"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-906"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-907"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>tys</span>
<a name="line-908"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-conop'>:</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-conop'>:</span><span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-909"></a><a name="flatten_one"></a><span class='hs-comment'>------------------</span>
<a name="line-910"></a><span class='hs-definition'>flatten_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-911"></a><span class='hs-comment'>-- Flatten a type to get rid of type function applications, returning</span>
<a name="line-912"></a><span class='hs-comment'>-- the new type-function-free type, and a collection of new equality</span>
<a name="line-913"></a><span class='hs-comment'>-- constraints.  See Note [Flattening] for more detail.</span>
<a name="line-914"></a><span class='hs-comment'>--</span>
<a name="line-915"></a><span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ TcType</span>
<a name="line-916"></a><span class='hs-comment'>-- The role on the result coercion matches the EqRel in the FlattenEnv</span>
<a name="line-917"></a>
<a name="line-918"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>xi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-919"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-920"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-921"></a>
<a name="line-922"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-923"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_tyvar</span> <span class='hs-varid'>tv</span>
<a name="line-924"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-925"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyword'>of</span>
<a name="line-926"></a>           <span class='hs-conid'>FTRCasted</span> <span class='hs-varid'>tv'</span> <span class='hs-varid'>kco</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Done</span>
<a name="line-927"></a>                       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flattenTyVar1"</span>
<a name="line-928"></a>                              <span class='hs-layout'>(</span><span class='hs-varid'>pprTvBndr</span> <span class='hs-varid'>tv'</span> <span class='hs-varop'>$$</span>
<a name="line-929"></a>                               <span class='hs-varid'>ppr</span> <span class='hs-varid'>kco</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>kco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-930"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty</span>
<a name="line-931"></a>                                         <span class='hs-varop'>`mkCoherenceLeftCo`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>kco</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-932"></a>                    <span class='hs-keyword'>where</span>
<a name="line-933"></a>                       <span class='hs-varid'>ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span>
<a name="line-934"></a>                       <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>kco</span>
<a name="line-935"></a>
<a name="line-936"></a>           <span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span>  <span class='hs-comment'>-- Recur</span>
<a name="line-937"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-938"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flattenTyVar2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-939"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span> <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-940"></a>
<a name="line-941"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-942"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-943"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-944"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>eq_rel</span><span class='hs-layout'>,</span> <span class='hs-varid'>nextRole</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-945"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span>  <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>NomEq</span>
<a name="line-946"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>NomEq</span>
<a name="line-947"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Representational</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>ReprEq</span>
<a name="line-948"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Phantom</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>-&gt;</span>
<a name="line-949"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>ty2</span>
<a name="line-950"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty2</span>
<a name="line-951"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>mkAppCo</span> <span class='hs-varid'>co1</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNomReflCo</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-952"></a>  <span class='hs-keyword'>where</span>
<a name="line-953"></a>    <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>eq_rel2</span>
<a name="line-954"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqRel</span> <span class='hs-varid'>eq_rel2</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty2</span>
<a name="line-955"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>role1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-956"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel2</span>
<a name="line-957"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten/appty"</span>
<a name="line-958"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span> <span class='hs-varop'>$$</span>
<a name="line-959"></a>                        <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>role1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>role2</span><span class='hs-layout'>)</span>
<a name="line-960"></a>
<a name="line-961"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span>
<a name="line-962"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>mkTransAppCo</span> <span class='hs-varid'>role1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty1</span>
<a name="line-963"></a>                                   <span class='hs-varid'>role2</span> <span class='hs-varid'>co2</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ty2</span>
<a name="line-964"></a>                                   <span class='hs-varid'>role1</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- output should match fmode</span>
<a name="line-965"></a>
<a name="line-966"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-967"></a>  <span class='hs-comment'>-- Expand type synonyms that mention type families</span>
<a name="line-968"></a>  <span class='hs-comment'>-- on the RHS; see Note [Flattening synonyms]</span>
<a name="line-969"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tenv</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>expandSynTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-970"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>expanded_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTvSubstPrs</span> <span class='hs-varid'>tenv</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys'</span>
<a name="line-971"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getMode</span>
<a name="line-972"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>used_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConsOfType</span> <span class='hs-varid'>rhs</span>
<a name="line-973"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-974"></a>           <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>anyNameEnv</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>used_tcs</span>
<a name="line-975"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>expanded_ty</span>
<a name="line-976"></a>           <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span>
<a name="line-977"></a>
<a name="line-978"></a>  <span class='hs-comment'>-- Otherwise, it's a type function application, and we have to</span>
<a name="line-979"></a>  <span class='hs-comment'>-- flatten it away as well, and generate a new given equality constraint</span>
<a name="line-980"></a>  <span class='hs-comment'>-- between the application and a newly generated flattening skolem variable.</span>
<a name="line-981"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-982"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-983"></a>
<a name="line-984"></a>  <span class='hs-comment'>-- For * a normal data type application</span>
<a name="line-985"></a>  <span class='hs-comment'>--     * data family application</span>
<a name="line-986"></a>  <span class='hs-comment'>-- we just recursively flatten the arguments.</span>
<a name="line-987"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-988"></a><span class='hs-comment'>-- FM_Avoid stuff commented out; see Note [Lazy flattening]</span>
<a name="line-989"></a><span class='hs-comment'>--  , let fmode' = case fmode of  -- Switch off the flat_top bit in FM_Avoid</span>
<a name="line-990"></a><span class='hs-comment'>--                   FE { fe_mode = FM_Avoid tv _ }</span>
<a name="line-991"></a><span class='hs-comment'>--                     -&gt; fmode { fe_mode = FM_Avoid tv False }</span>
<a name="line-992"></a><span class='hs-comment'>--                   _ -&gt; fmode</span>
<a name="line-993"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-994"></a>
<a name="line-995"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-996"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-997"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty2</span>
<a name="line-998"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-999"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFunCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1000"></a>
<a name="line-1001"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1002"></a><span class='hs-comment'>-- TODO (RAE): This is inadequate, as it doesn't flatten the kind of</span>
<a name="line-1003"></a><span class='hs-comment'>-- the bound tyvar. Doing so will require carrying around a substitution</span>
<a name="line-1004"></a><span class='hs-comment'>-- and the usual substTyVarBndr-like silliness. Argh.</span>
<a name="line-1005"></a>
<a name="line-1006"></a><span class='hs-comment'>-- We allow for-alls when, but only when, no type function</span>
<a name="line-1007"></a><span class='hs-comment'>-- applications inside the forall involve the bound type variables.</span>
<a name="line-1008"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rho</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitNamedPiTys</span> <span class='hs-varid'>ty</span>
<a name="line-1009"></a>             <span class='hs-varid'>tvs</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>binderVar</span> <span class='hs-str'>"flatten"</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-1010"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setMode</span> <span class='hs-conid'>FM_SubstOnly</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>rho</span>
<a name="line-1011"></a>                         <span class='hs-comment'>-- Substitute only under a forall</span>
<a name="line-1012"></a>                         <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-1013"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkForAllTys</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkHomoForAllCos</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1014"></a>
<a name="line-1015"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-1016"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1017"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>g'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_co</span> <span class='hs-varid'>g</span>
<a name="line-1018"></a>
<a name="line-1019"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCastTy</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>g'</span><span class='hs-layout'>,</span> <span class='hs-varid'>castCoercionKind</span> <span class='hs-varid'>co</span> <span class='hs-varid'>g'</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1020"></a>
<a name="line-1021"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>first</span> <span class='hs-varid'>mkCoercionTy</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>flatten_co</span> <span class='hs-varid'>co</span>
<a name="line-1022"></a>
<a name="line-1023"></a><a name="flatten_co"></a><span class='hs-comment'>-- | "Flatten" a coercion. Really, just flatten the types that it coerces</span>
<a name="line-1024"></a><span class='hs-comment'>-- between and then use transitivity.</span>
<a name="line-1025"></a><span class='hs-definition'>flatten_co</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1026"></a><span class='hs-definition'>flatten_co</span> <span class='hs-varid'>co</span>
<a name="line-1027"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>role</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKindRole</span> <span class='hs-varid'>co</span>
<a name="line-1028"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkCo</span> <span class='hs-varid'>co</span>  <span class='hs-comment'>-- squeeze out any metavars from the original</span>
<a name="line-1029"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenKinds</span> <span class='hs-varop'>$</span>
<a name="line-1030"></a>                       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-1031"></a>                          <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty2</span>
<a name="line-1032"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1033"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>downgradeRole</span> <span class='hs-varid'>role</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1034"></a>                   <span class='hs-varid'>co</span> <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1035"></a>                   <span class='hs-varid'>mkSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>downgradeRole</span> <span class='hs-varid'>role</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-1036"></a>             <span class='hs-comment'>-- kco :: (ty1' ~r ty2') ~N (ty1 ~r ty2)</span>
<a name="line-1037"></a>             <span class='hs-varid'>kco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>(</span><span class='hs-varid'>equalityTyCon</span> <span class='hs-varid'>role</span><span class='hs-layout'>)</span>
<a name="line-1038"></a>                     <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkKindCo</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkKindCo</span> <span class='hs-varid'>co2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span> <span class='hs-keyglyph'>]</span>
<a name="line-1039"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten_co"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1040"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>env_role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1041"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>co'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkProofIrrelCo</span> <span class='hs-varid'>env_role</span> <span class='hs-varid'>kco</span> <span class='hs-varid'>co'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1042"></a>
<a name="line-1043"></a><a name="flatten_ty_con_app"></a><span class='hs-definition'>flatten_ty_con_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1044"></a><span class='hs-definition'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1045"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1046"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1047"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>of</span>
<a name="line-1048"></a>                         <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>tys</span>
<a name="line-1049"></a>                         <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_many</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesRepresentational</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1050"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1051"></a>
<a name="line-1052"></a><span class='hs-comment'>{-
<a name="line-1053"></a>Note [Flattening synonyms]
<a name="line-1054"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1055"></a>Not expanding synonyms aggressively improves error messages, and
<a name="line-1056"></a>keeps types smaller. But we need to take care.
<a name="line-1057"></a>
<a name="line-1058"></a>Suppose
<a name="line-1059"></a>   type T a = a -&gt; a
<a name="line-1060"></a>and we want to flatten the type (T (F a)).  Then we can safely flatten
<a name="line-1061"></a>the (F a) to a skolem, and return (T fsk).  We don't need to expand the
<a name="line-1062"></a>synonym.  This works because TcTyConAppCo can deal with synonyms
<a name="line-1063"></a>(unlike TyConAppCo), see Note [TcCoercions] in TcEvidence.
<a name="line-1064"></a>
<a name="line-1065"></a>But (Trac #8979) for
<a name="line-1066"></a>   type T a = (F a, a)    where F is a type function
<a name="line-1067"></a>we must expand the synonym in (say) T Int, to expose the type function
<a name="line-1068"></a>to the flattener.
<a name="line-1069"></a>
<a name="line-1070"></a>
<a name="line-1071"></a>Note [Flattening under a forall]
<a name="line-1072"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1073"></a>Under a forall, we
<a name="line-1074"></a>  (a) MUST apply the inert substitution
<a name="line-1075"></a>  (b) MUST NOT flatten type family applications
<a name="line-1076"></a>Hence FMSubstOnly.
<a name="line-1077"></a>
<a name="line-1078"></a>For (a) consider   c ~ a, a ~ T (forall b. (b, [c]))
<a name="line-1079"></a>If we don't apply the c~a substitution to the second constraint
<a name="line-1080"></a>we won't see the occurs-check error.
<a name="line-1081"></a>
<a name="line-1082"></a>For (b) consider  (a ~ forall b. F a b), we don't want to flatten
<a name="line-1083"></a>to     (a ~ forall b.fsk, F a b ~ fsk)
<a name="line-1084"></a>because now the 'b' has escaped its scope.  We'd have to flatten to
<a name="line-1085"></a>       (a ~ forall b. fsk b, forall b. F a b ~ fsk b)
<a name="line-1086"></a>and we have not begun to think about how to make that work!
<a name="line-1087"></a>
<a name="line-1088"></a>************************************************************************
<a name="line-1089"></a>*                                                                      *
<a name="line-1090"></a>             Flattening a type-family application
<a name="line-1091"></a>*                                                                      *
<a name="line-1092"></a>************************************************************************
<a name="line-1093"></a>-}</span>
<a name="line-1094"></a>
<a name="line-1095"></a><a name="flatten_fam_app"></a><span class='hs-definition'>flatten_fam_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1096"></a>  <span class='hs-comment'>--   flatten_fam_app            can be over-saturated</span>
<a name="line-1097"></a>  <span class='hs-comment'>--   flatten_exact_fam_app       is exactly saturated</span>
<a name="line-1098"></a>  <span class='hs-comment'>--   flatten_exact_fam_app_fully lifts out the application to top level</span>
<a name="line-1099"></a>  <span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ F tys</span>
<a name="line-1100"></a><span class='hs-definition'>flatten_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>  <span class='hs-comment'>-- Can be over-saturated</span>
<a name="line-1101"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys</span>
<a name="line-1102"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1103"></a>                 <span class='hs-comment'>-- Type functions are saturated</span>
<a name="line-1104"></a>                 <span class='hs-comment'>-- The type function might be *over* saturated</span>
<a name="line-1105"></a>                 <span class='hs-comment'>-- in which case the remaining arguments should</span>
<a name="line-1106"></a>                 <span class='hs-comment'>-- be dealt with by AppTys</span>
<a name="line-1107"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1108"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_exact_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span>
<a name="line-1109"></a>               <span class='hs-comment'>-- co1 :: xi1 ~ F tys1</span>
<a name="line-1110"></a>
<a name="line-1111"></a>               <span class='hs-comment'>-- all Nominal roles b/c the tycon is oversaturated</span>
<a name="line-1112"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis_rest</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys_rest</span>
<a name="line-1113"></a>               <span class='hs-comment'>-- cos_res :: xis_rest ~ tys_rest</span>
<a name="line-1114"></a>
<a name="line-1115"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xis_rest</span>   <span class='hs-comment'>-- NB mkAppTys: rhs_xi might not be a type variable</span>
<a name="line-1116"></a>                                            <span class='hs-comment'>--    cf Trac #5655</span>
<a name="line-1117"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>mkAppCos</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>cos_rest</span>
<a name="line-1118"></a>                            <span class='hs-comment'>-- (rhs_xi :: F xis) ; (F cos :: F xis ~ F tys)</span>
<a name="line-1119"></a>                  <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1120"></a>
<a name="line-1121"></a><a name="flatten_exact_fam_app"></a><span class='hs-definition'>flatten_exact_fam_app</span><span class='hs-layout'>,</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span> <span class='hs-keyglyph'>::</span>
<a name="line-1122"></a>  <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1123"></a>
<a name="line-1124"></a><span class='hs-definition'>flatten_exact_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1125"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getMode</span>
<a name="line-1126"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1127"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1128"></a>           <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1129"></a>
<a name="line-1130"></a>           <span class='hs-conid'>FM_SubstOnly</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-1131"></a>                              <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1132"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1133"></a>             <span class='hs-keyword'>where</span>
<a name="line-1134"></a>               <span class='hs-comment'>-- These are always going to be Nominal for now,</span>
<a name="line-1135"></a>               <span class='hs-comment'>-- but not if #8177 is implemented</span>
<a name="line-1136"></a>               <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>}</span>
<a name="line-1137"></a>
<a name="line-1138"></a><span class='hs-comment'>--       FM_Avoid tv flat_top -&gt;</span>
<a name="line-1139"></a><span class='hs-comment'>--         do { (xis, cos) &lt;- flatten_many fmode roles tys</span>
<a name="line-1140"></a><span class='hs-comment'>--            ; if flat_top || tv `elemVarSet` tyCoVarsOfTypes xis</span>
<a name="line-1141"></a><span class='hs-comment'>--              then flatten_exact_fam_app_fully fmode tc tys</span>
<a name="line-1142"></a><span class='hs-comment'>--              else return ( mkTyConApp tc xis</span>
<a name="line-1143"></a><span class='hs-comment'>--                          , mkTcTyConAppCo (feRole fmode) tc cos ) }</span>
<a name="line-1144"></a>
<a name="line-1145"></a><a name="flatten_exact_fam_app_fully"></a><span class='hs-definition'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1146"></a>  <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-1147"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>False</span> <span class='hs-varid'>id</span> <span class='hs-varop'>$</span>
<a name="line-1148"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- First, flatten the arguments</span>
<a name="line-1149"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>NomEq</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>tys</span>
<a name="line-1150"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1151"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1152"></a>             <span class='hs-varid'>ret_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span>
<a name="line-1153"></a>              <span class='hs-comment'>-- ret_co :: F xis ~ F tys</span>
<a name="line-1154"></a>
<a name="line-1155"></a>        <span class='hs-comment'>-- Now, look in the cache</span>
<a name="line-1156"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lookupFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1157"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavourRole</span>
<a name="line-1158"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-1159"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>flav</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- co :: F xis ~ fsk</span>
<a name="line-1160"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>flav</span><span class='hs-layout'>,</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span> <span class='hs-varop'>`funEqCanDischargeFR`</span> <span class='hs-varid'>fr</span>
<a name="line-1161"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Usable hit in the flat-cache</span>
<a name="line-1162"></a>                 <span class='hs-comment'>-- We certainly *can* use a Wanted for a Wanted</span>
<a name="line-1163"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten/flat-cache hit"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xis</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-1164"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-1165"></a>                          <span class='hs-comment'>-- The fsk may already have been unified, so flatten it</span>
<a name="line-1166"></a>                          <span class='hs-comment'>-- fsk_co :: fsk_xi ~ fsk</span>
<a name="line-1167"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>fsk_xi</span>
<a name="line-1168"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span> <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1169"></a>                              <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1170"></a>                              <span class='hs-varid'>ret_co</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1171"></a>                                    <span class='hs-comment'>-- :: fsk_xi ~ F xis</span>
<a name="line-1172"></a>
<a name="line-1173"></a>           <span class='hs-comment'>-- Try to reduce the family application right now</span>
<a name="line-1174"></a>           <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-1175"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1176"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1177"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlattenSkolemFlatM</span> <span class='hs-varid'>fam_ty</span>
<a name="line-1178"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fsk_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>fsk</span>
<a name="line-1179"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>(</span> <span class='hs-varid'>co</span>
<a name="line-1180"></a>                                                      <span class='hs-layout'>,</span> <span class='hs-varid'>fsk_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1181"></a>
<a name="line-1182"></a>                   <span class='hs-comment'>-- The new constraint (F xis ~ fsk) is not necessarily inert</span>
<a name="line-1183"></a>                   <span class='hs-comment'>-- (e.g. the LHS may be a redex) so we must put it in the work list</span>
<a name="line-1184"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-1185"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-1186"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-1187"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsk</span> <span class='hs-layout'>}</span>
<a name="line-1188"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>emitFlatWork</span> <span class='hs-varid'>ct</span>
<a name="line-1189"></a>
<a name="line-1190"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten/flat-cache miss"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fsk</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1191"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fsk_ty</span>
<a name="line-1192"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span>
<a name="line-1193"></a>                                     <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1194"></a>                                     <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1195"></a>                                     <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>ret_co</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1196"></a>        <span class='hs-layout'>}</span>
<a name="line-1197"></a>
<a name="line-1198"></a>  <span class='hs-keyword'>where</span>
<a name="line-1199"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>   <span class='hs-comment'>-- F, family tycon</span>
<a name="line-1200"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- args, not necessarily flattened</span>
<a name="line-1201"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- add to the flat cache?</span>
<a name="line-1202"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span>   <span class='hs-conid'>Coercion</span>     <span class='hs-comment'>-- :: xi ~ F args</span>
<a name="line-1203"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- what to return from outer function</span>
<a name="line-1204"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- continuation upon failure</span>
<a name="line-1205"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1206"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>cache</span> <span class='hs-varid'>update_co</span> <span class='hs-varid'>k</span>
<a name="line-1207"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkStackDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1208"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1209"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyword'>of</span>
<a name="line-1210"></a>               <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>norm_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>norm_ty</span><span class='hs-layout'>)</span>
<a name="line-1211"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Eager T.F. reduction success"</span> <span class='hs-varop'>$</span>
<a name="line-1212"></a>                         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1213"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_co</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span>
<a name="line-1214"></a>                                            <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>norm_co</span><span class='hs-layout'>)</span>
<a name="line-1215"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cache</span><span class='hs-keyglyph'>]</span>
<a name="line-1216"></a>                       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bumpDepth</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1217"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1218"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>norm_co</span>
<a name="line-1219"></a>                                  <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>final_co</span>
<a name="line-1220"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>flavour</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-1221"></a>                           <span class='hs-comment'>-- NB: only extend cache with nominal equalities</span>
<a name="line-1222"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>cache</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1223"></a>                         <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span>
<a name="line-1224"></a>                         <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>(</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>flavour</span> <span class='hs-layout'>)</span>
<a name="line-1225"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>update_co</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1226"></a>               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span>
<a name="line-1227"></a>
<a name="line-1228"></a><span class='hs-comment'>{- Note [Reduce type family applications eagerly]
<a name="line-1229"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1230"></a>If we come across a type-family application like (Append (Cons x Nil) t),
<a name="line-1231"></a>then, rather than flattening to a skolem etc, we may as well just reduce
<a name="line-1232"></a>it on the spot to (Cons x t).  This saves a lot of intermediate steps.
<a name="line-1233"></a>Examples that are helped are tests T9872, and T5321Fun.
<a name="line-1234"></a>
<a name="line-1235"></a>Performance testing indicates that it's best to try this *twice*, once
<a name="line-1236"></a>before flattening arguments and once after flattening arguments.
<a name="line-1237"></a>Adding the extra reduction attempt before flattening arguments cut
<a name="line-1238"></a>the allocation amounts for the T9872{a,b,c} tests by half.
<a name="line-1239"></a>
<a name="line-1240"></a>An example of where the early reduction appears helpful:
<a name="line-1241"></a>
<a name="line-1242"></a>  type family Last x where
<a name="line-1243"></a>    Last '[x]     = x
<a name="line-1244"></a>    Last (h ': t) = Last t
<a name="line-1245"></a>
<a name="line-1246"></a>  workitem: (x ~ Last '[1,2,3,4,5,6])
<a name="line-1247"></a>
<a name="line-1248"></a>Flattening the argument never gets us anywhere, but trying to flatten
<a name="line-1249"></a>it at every step is quadratic in the length of the list. Reducing more
<a name="line-1250"></a>eagerly makes simplifying the right-hand type linear in its length.
<a name="line-1251"></a>
<a name="line-1252"></a>Testing also indicated that the early reduction should *not* use the
<a name="line-1253"></a>flat-cache, but that the later reduction *should*. (Although the
<a name="line-1254"></a>effect was not large.)  Hence the Bool argument to try_to_reduce.  To
<a name="line-1255"></a>me (SLPJ) this seems odd; I get that eager reduction usually succeeds;
<a name="line-1256"></a>and if don't use the cache for eager reduction, we will miss most of
<a name="line-1257"></a>the opportunities for using it at all.  More exploration would be good
<a name="line-1258"></a>here.
<a name="line-1259"></a>
<a name="line-1260"></a>At the end, once we've got a flat rhs, we extend the flatten-cache to record
<a name="line-1261"></a>the result. Doing so can save lots of work when the same redex shows up more
<a name="line-1262"></a>than once. Note that we record the link from the redex all the way to its
<a name="line-1263"></a>*final* value, not just the single step reduction. Interestingly, using the
<a name="line-1264"></a>flat-cache for the first reduction resulted in an increase in allocations
<a name="line-1265"></a>of about 3% for the four T9872x tests. However, using the flat-cache in
<a name="line-1266"></a>the later reduction is a similar gain. I (Richard E) don't currently (Dec '14)
<a name="line-1267"></a>have any knowledge as to *why* these facts are true.
<a name="line-1268"></a>
<a name="line-1269"></a>************************************************************************
<a name="line-1270"></a>*                                                                      *
<a name="line-1271"></a>             Flattening a type variable
<a name="line-1272"></a>*                                                                      *
<a name="line-1273"></a>********************************************************************* -}</span>
<a name="line-1274"></a>
<a name="line-1275"></a><a name="FlattenTvResult"></a><span class='hs-comment'>-- | The result of flattening a tyvar "one step".</span>
<a name="line-1276"></a><a name="FlattenTvResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1277"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FTRCasted</span> <span class='hs-conid'>TyVar</span> <span class='hs-conid'>Coercion</span>
<a name="line-1278"></a>      <span class='hs-comment'>-- ^ Flattening the tyvar's kind produced a cast.</span>
<a name="line-1279"></a>      <span class='hs-comment'>-- co :: new kind ~N old kind;</span>
<a name="line-1280"></a>      <span class='hs-comment'>-- The 'TyVar' in there might have a new, zonked kind</span>
<a name="line-1281"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FTRFollowed</span> <span class='hs-conid'>TcType</span> <span class='hs-conid'>Coercion</span>
<a name="line-1282"></a>      <span class='hs-comment'>-- ^ The tyvar flattens to a not-necessarily flat other type.</span>
<a name="line-1283"></a>      <span class='hs-comment'>-- co :: new type ~r old type, where the role is determined by</span>
<a name="line-1284"></a>      <span class='hs-comment'>-- the FlattenEnv</span>
<a name="line-1285"></a>
<a name="line-1286"></a><a name="flatten_tyvar"></a><span class='hs-definition'>flatten_tyvar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1287"></a><span class='hs-comment'>-- "Flattening" a type variable means to apply the substitution to it</span>
<a name="line-1288"></a><span class='hs-comment'>-- Specifically, look up the tyvar in</span>
<a name="line-1289"></a><span class='hs-comment'>--   * the internal MetaTyVar box</span>
<a name="line-1290"></a><span class='hs-comment'>--   * the inerts</span>
<a name="line-1291"></a><span class='hs-comment'>-- See also the documentation for FlattenTvResult</span>
<a name="line-1292"></a>
<a name="line-1293"></a><span class='hs-definition'>flatten_tyvar</span> <span class='hs-varid'>tv</span>
<a name="line-1294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTcTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- Happens when flatten under a (forall a. ty)</span>
<a name="line-1295"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_tyvar3</span> <span class='hs-varid'>tv</span>
<a name="line-1296"></a>          <span class='hs-comment'>-- So ty contains references to the non-TcTyVar a</span>
<a name="line-1297"></a>
<a name="line-1298"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1299"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-1300"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1301"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1302"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Following filled tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1303"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-1304"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavourRole</span>
<a name="line-1305"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>flatten_tyvar2</span>  <span class='hs-varid'>tv</span> <span class='hs-varid'>fr</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1306"></a>
<a name="line-1307"></a><a name="flatten_tyvar2"></a><span class='hs-definition'>flatten_tyvar2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1308"></a><span class='hs-comment'>-- Try in the inert equalities</span>
<a name="line-1309"></a><span class='hs-comment'>-- See Definition [Applying a generalised substitution] in TcSMonad</span>
<a name="line-1310"></a><span class='hs-comment'>-- See Note [Stability of flattening] in TcSMonad</span>
<a name="line-1311"></a>
<a name="line-1312"></a><span class='hs-definition'>flatten_tyvar2</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>fr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>flavour</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span>
<a name="line-1313"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Derived</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flavour</span>  <span class='hs-comment'>-- For derived equalities, consult the inert_model (only)</span>
<a name="line-1314"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>model</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getInertModel</span>
<a name="line-1315"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupDVarEnv</span> <span class='hs-varid'>model</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1316"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1317"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprPanic</span> <span class='hs-str'>"flatten_tyvar2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1318"></a>                              <span class='hs-comment'>-- Evidence is irrelevant for Derived contexts</span>
<a name="line-1319"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_tyvar3</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>}</span>
<a name="line-1320"></a>
<a name="line-1321"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- For non-derived equalities, consult the inert_eqs (only)</span>
<a name="line-1322"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getInertEqs</span>
<a name="line-1323"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupDVarEnv</span> <span class='hs-varid'>ieqs</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1324"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- If the first doesn't work,</span>
<a name="line-1325"></a>                         <span class='hs-comment'>-- the subsequent ones won't either</span>
<a name="line-1326"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ct</span>
<a name="line-1327"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>`eqCanRewriteFR`</span> <span class='hs-varid'>fr</span>
<a name="line-1328"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Following inert tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-1329"></a>                    <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rewrite_co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ctEvCoercion</span> <span class='hs-varid'>ctev</span>
<a name="line-1330"></a>                          <span class='hs-varid'>rewrite_co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1331"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-sel'>_rel</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-sel'>_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>ReprEq</span> <span class='hs-layout'>)</span>
<a name="line-1332"></a>                                    <span class='hs-comment'>-- if this ASSERT fails, then</span>
<a name="line-1333"></a>                                    <span class='hs-comment'>-- eqCanRewriteFR answered incorrectly</span>
<a name="line-1334"></a>                                               <span class='hs-varid'>rewrite_co1</span>
<a name="line-1335"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1336"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkSubCo</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1337"></a>
<a name="line-1338"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>rewrite_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1339"></a>                    <span class='hs-comment'>-- NB: ct is Derived then fmode must be also, hence</span>
<a name="line-1340"></a>                    <span class='hs-comment'>-- we are not going to touch the returned coercion</span>
<a name="line-1341"></a>                    <span class='hs-comment'>-- so ctEvCoercion is fine.</span>
<a name="line-1342"></a>
<a name="line-1343"></a>           <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_tyvar3</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>}</span>
<a name="line-1344"></a>
<a name="line-1345"></a><a name="flatten_tyvar3"></a><span class='hs-definition'>flatten_tyvar3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1346"></a><span class='hs-comment'>-- Always returns FTRCasted!</span>
<a name="line-1347"></a><span class='hs-definition'>flatten_tyvar3</span> <span class='hs-varid'>tv</span>
<a name="line-1348"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Done, but make sure the kind is zonked</span>
<a name="line-1349"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-1350"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-sel'>_new_kind</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1351"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setMode</span> <span class='hs-conid'>FM_SubstOnly</span> <span class='hs-varop'>$</span>
<a name="line-1352"></a>              <span class='hs-varid'>flattenKinds</span> <span class='hs-varop'>$</span>
<a name="line-1353"></a>              <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>kind</span>
<a name="line-1354"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flattenTyVarFinal"</span>
<a name="line-1355"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1356"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-sel'>_new_kind</span>
<a name="line-1357"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>kind_co</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1358"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>orig_kind</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>kind</span>
<a name="line-1359"></a>             <span class='hs-comment'>-- NB: orig_kind is *not* the kind returned from flatten</span>
<a name="line-1360"></a>             <span class='hs-comment'>-- This zonk is necessary because we might later see the tv's kind</span>
<a name="line-1361"></a>             <span class='hs-comment'>-- in canEqTyVarTyVar (where we use getCastedTyVar_maybe).</span>
<a name="line-1362"></a>             <span class='hs-comment'>-- If you remove it, then e.g. dependent/should_fail/T11407 panics</span>
<a name="line-1363"></a>             <span class='hs-comment'>-- See also Note [Flattening]</span>
<a name="line-1364"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRCasted</span> <span class='hs-layout'>(</span><span class='hs-varid'>setTyVarKind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>orig_kind</span><span class='hs-layout'>)</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1365"></a>
<a name="line-1366"></a><span class='hs-comment'>{-
<a name="line-1367"></a>Note [An alternative story for the inert substitution]
<a name="line-1368"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1369"></a>(This entire note is just background, left here in case we ever want
<a name="line-1370"></a> to return the the previousl state of affairs)
<a name="line-1371"></a>
<a name="line-1372"></a>We used (GHC 7.8) to have this story for the inert substitution inert_eqs
<a name="line-1373"></a>
<a name="line-1374"></a> * 'a' is not in fvs(ty)
<a name="line-1375"></a> * They are *inert* in the weaker sense that there is no infinite chain of
<a name="line-1376"></a>   (i1 `eqCanRewrite` i2), (i2 `eqCanRewrite` i3), etc
<a name="line-1377"></a>
<a name="line-1378"></a>This means that flattening must be recursive, but it does allow
<a name="line-1379"></a>  [G] a ~ [b]
<a name="line-1380"></a>  [G] b ~ Maybe c
<a name="line-1381"></a>
<a name="line-1382"></a>This avoids "saturating" the Givens, which can save a modest amount of work.
<a name="line-1383"></a>It is easy to implement, in TcInteract.kick_out, by only kicking out an inert
<a name="line-1384"></a>only if (a) the work item can rewrite the inert AND
<a name="line-1385"></a>        (b) the inert cannot rewrite the work item
<a name="line-1386"></a>
<a name="line-1387"></a>This is signifcantly harder to think about. It can save a LOT of work
<a name="line-1388"></a>in occurs-check cases, but we don't care about them much.  Trac #5837
<a name="line-1389"></a>is an example; all the constraints here are Givens
<a name="line-1390"></a>
<a name="line-1391"></a>             [G] a ~ TF (a,Int)
<a name="line-1392"></a>    --&gt;
<a name="line-1393"></a>    work     TF (a,Int) ~ fsk
<a name="line-1394"></a>    inert    fsk ~ a
<a name="line-1395"></a>
<a name="line-1396"></a>    ---&gt;
<a name="line-1397"></a>    work     fsk ~ (TF a, TF Int)
<a name="line-1398"></a>    inert    fsk ~ a
<a name="line-1399"></a>
<a name="line-1400"></a>    ---&gt;
<a name="line-1401"></a>    work     a ~ (TF a, TF Int)
<a name="line-1402"></a>    inert    fsk ~ a
<a name="line-1403"></a>
<a name="line-1404"></a>    ---&gt; (attempting to flatten (TF a) so that it does not mention a
<a name="line-1405"></a>    work     TF a ~ fsk2
<a name="line-1406"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1407"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1408"></a>
<a name="line-1409"></a>    ---&gt; (substitute for a)
<a name="line-1410"></a>    work     TF (fsk2, TF Int) ~ fsk2
<a name="line-1411"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1412"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1413"></a>
<a name="line-1414"></a>    ---&gt; (top-level reduction, re-orient)
<a name="line-1415"></a>    work     fsk2 ~ (TF fsk2, TF Int)
<a name="line-1416"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1417"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1418"></a>
<a name="line-1419"></a>    ---&gt; (attempt to flatten (TF fsk2) to get rid of fsk2
<a name="line-1420"></a>    work     TF fsk2 ~ fsk3
<a name="line-1421"></a>    work     fsk2 ~ (fsk3, TF Int)
<a name="line-1422"></a>    inert    a   ~ (fsk2, TF Int)
<a name="line-1423"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1424"></a>
<a name="line-1425"></a>    ---&gt;
<a name="line-1426"></a>    work     TF fsk2 ~ fsk3
<a name="line-1427"></a>    inert    fsk2 ~ (fsk3, TF Int)
<a name="line-1428"></a>    inert    a   ~ ((fsk3, TF Int), TF Int)
<a name="line-1429"></a>    inert    fsk ~ ((fsk3, TF Int), TF Int)
<a name="line-1430"></a>
<a name="line-1431"></a>Because the incoming given rewrites all the inert givens, we get more and
<a name="line-1432"></a>more duplication in the inert set.  But this really only happens in pathalogical
<a name="line-1433"></a>casee, so we don't care.
<a name="line-1434"></a>
<a name="line-1435"></a>
<a name="line-1436"></a>************************************************************************
<a name="line-1437"></a>*                                                                      *
<a name="line-1438"></a>             Unflattening
<a name="line-1439"></a>*                                                                      *
<a name="line-1440"></a>************************************************************************
<a name="line-1441"></a>
<a name="line-1442"></a>An unflattening example:
<a name="line-1443"></a>    [W] F a ~ alpha
<a name="line-1444"></a>flattens to
<a name="line-1445"></a>    [W] F a ~ fmv   (CFunEqCan)
<a name="line-1446"></a>    [W] fmv ~ alpha (CTyEqCan)
<a name="line-1447"></a>We must solve both!
<a name="line-1448"></a>-}</span>
<a name="line-1449"></a>
<a name="line-1450"></a><a name="unflatten"></a><span class='hs-definition'>unflatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1451"></a><span class='hs-definition'>unflatten</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varid'>funeqs</span>
<a name="line-1452"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1453"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcLevel</span>
<a name="line-1454"></a>
<a name="line-1455"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-varop'>$</span>
<a name="line-1456"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Funeqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1457"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Tv eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1458"></a>
<a name="line-1459"></a>         <span class='hs-comment'>-- Step 1: unflatten the CFunEqCans, except if that causes an occurs check</span>
<a name="line-1460"></a>         <span class='hs-comment'>-- Occurs check: consider  [W] alpha ~ [F alpha]</span>
<a name="line-1461"></a>         <span class='hs-comment'>--                 ==&gt; (flatten) [W] F alpha ~ fmv, [W] alpha ~ [fmv]</span>
<a name="line-1462"></a>         <span class='hs-comment'>--                 ==&gt; (unify)   [W] F [fmv] ~ fmv</span>
<a name="line-1463"></a>         <span class='hs-comment'>-- See Note [Unflatten using funeqs first]</span>
<a name="line-1464"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-layout'>(</span><span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1465"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 1"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1466"></a>
<a name="line-1467"></a>          <span class='hs-comment'>-- Step 2: unify the tv_eqs, if possible</span>
<a name="line-1468"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-layout'>(</span><span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1469"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 2"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span><span class='hs-layout'>)</span>
<a name="line-1470"></a>
<a name="line-1471"></a>          <span class='hs-comment'>-- Step 3: fill any remaining fmvs with fresh unification variables</span>
<a name="line-1472"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>funeqs</span>
<a name="line-1473"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 3"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1474"></a>
<a name="line-1475"></a>          <span class='hs-comment'>-- Step 4: remove any tv_eqs that look like ty ~ ty</span>
<a name="line-1476"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1477"></a>
<a name="line-1478"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>funeqs</span>
<a name="line-1479"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening done"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>all_flat</span><span class='hs-layout'>)</span>
<a name="line-1480"></a>
<a name="line-1481"></a>          <span class='hs-comment'>-- Step 5: zonk the result</span>
<a name="line-1482"></a>          <span class='hs-comment'>-- Motivation: makes them nice and ready for the next step</span>
<a name="line-1483"></a>          <span class='hs-comment'>--             (see TcInteract.solveSimpleWanteds)</span>
<a name="line-1484"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>zonkSimples</span> <span class='hs-varid'>all_flat</span> <span class='hs-layout'>}</span>
<a name="line-1485"></a>  <span class='hs-keyword'>where</span>
<a name="line-1486"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1487"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1488"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-1489"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1490"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- fmv should be an un-filled flatten meta-tv;</span>
<a name="line-1491"></a>               <span class='hs-comment'>-- we now fix its final value by filling it, being careful</span>
<a name="line-1492"></a>               <span class='hs-comment'>-- to observe the occurs check.  Zonking will eliminate it</span>
<a name="line-1493"></a>               <span class='hs-comment'>-- altogether in due course</span>
<a name="line-1494"></a>             <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span>
<a name="line-1495"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occurCheckExpand</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fmv</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyword'>of</span>
<a name="line-1496"></a>               <span class='hs-conid'>OC_OK</span> <span class='hs-varid'>rhs''</span>    <span class='hs-comment'>-- Normal case: fill the tyvar</span>
<a name="line-1497"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span>
<a name="line-1498"></a>                               <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs''</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1499"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>unflattenFmv</span> <span class='hs-varid'>fmv</span> <span class='hs-varid'>rhs''</span>
<a name="line-1500"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-1501"></a>
<a name="line-1502"></a>               <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Occurs check</span>
<a name="line-1503"></a>                     <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1504"></a>
<a name="line-1505"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>other_ct</span> <span class='hs-keyword'>_</span>
<a name="line-1506"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>other_ct</span><span class='hs-layout'>)</span>
<a name="line-1507"></a>
<a name="line-1508"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1509"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Ct</span>
<a name="line-1510"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1511"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>demoteUnfilledFmv</span> <span class='hs-varid'>fmv</span>
<a name="line-1512"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1513"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1514"></a>
<a name="line-1515"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1516"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1517"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1518"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>   <span class='hs-comment'>-- Previously these fmvs were untouchable,</span>
<a name="line-1519"></a>                        <span class='hs-comment'>-- but now they are touchable</span>
<a name="line-1520"></a>                        <span class='hs-comment'>-- NB: unlike unflattenFmv, filling a fmv here does</span>
<a name="line-1521"></a>                        <span class='hs-comment'>--     bump the unification count; it is "improvement"</span>
<a name="line-1522"></a>                        <span class='hs-comment'>-- Note [Unflattening can force the solver to iterate]</span>
<a name="line-1523"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lhs_elim</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>ev</span>
<a name="line-1524"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>lhs_elim</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-keyword'>else</span>
<a name="line-1525"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rhs_elim</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_fill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1526"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>rhs_elim</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-keyword'>else</span>
<a name="line-1527"></a>             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1528"></a>
<a name="line-1529"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1530"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-1531"></a>
<a name="line-1532"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1533"></a>
<a name="line-1534"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1535"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1536"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-1537"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1538"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1539"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1540"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-1541"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>is_refl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-1542"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_refl</span> <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span>
<a name="line-1543"></a>                                            <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varop'>$</span>
<a name="line-1544"></a>                                             <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1545"></a>                                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-1546"></a>                        <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1547"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1548"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-1549"></a>
<a name="line-1550"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1551"></a>
<a name="line-1552"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1553"></a>    <span class='hs-varid'>try_fill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1554"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1555"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isTouchableOrFmv</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv1</span>
<a name="line-1556"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-1557"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ev</span>
<a name="line-1558"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1559"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1560"></a>
<a name="line-1561"></a><a name="tryFill"></a><span class='hs-definition'>tryFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-1562"></a><span class='hs-comment'>-- (tryFill tv rhs ev) sees if 'tv' is an un-filled MetaTv</span>
<a name="line-1563"></a><span class='hs-comment'>-- If so, and if tv does not appear in 'rhs', set tv := rhs</span>
<a name="line-1564"></a><span class='hs-comment'>-- bind the evidence (which should be a CtWanted) to Refl&lt;rhs&gt;</span>
<a name="line-1565"></a><span class='hs-comment'>-- and return True.  Otherwise return False</span>
<a name="line-1566"></a><span class='hs-definition'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>ev</span>
<a name="line-1567"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>)</span>
<a name="line-1568"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1569"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span> <span class='hs-keyword'>else</span>
<a name="line-1570"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-1571"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occurCheckExpand</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyword'>of</span>
<a name="line-1572"></a>           <span class='hs-conid'>OC_OK</span> <span class='hs-varid'>rhs''</span>    <span class='hs-comment'>-- Normal case: fill the tyvar</span>
<a name="line-1573"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span>
<a name="line-1574"></a>                               <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs''</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1575"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>unifyTyVar</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs''</span>
<a name="line-1576"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-1577"></a>
<a name="line-1578"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Occurs check</span>
<a name="line-1579"></a>                 <span class='hs-varid'>return</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1580"></a>
<a name="line-1581"></a><span class='hs-comment'>{-
<a name="line-1582"></a>Note [Unflatten using funeqs first]
<a name="line-1583"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1584"></a>    [W] G a ~ Int
<a name="line-1585"></a>    [W] F (G a) ~ G a
<a name="line-1586"></a>
<a name="line-1587"></a>do not want to end up with
<a name="line-1588"></a>    [W] F Int ~ Int
<a name="line-1589"></a>because that might actually hold!  Better to end up with the two above
<a name="line-1590"></a>unsolved constraints.  The flat form will be
<a name="line-1591"></a>
<a name="line-1592"></a>    G a ~ fmv1     (CFunEqCan)
<a name="line-1593"></a>    F fmv1 ~ fmv2  (CFunEqCan)
<a name="line-1594"></a>    fmv1 ~ Int     (CTyEqCan)
<a name="line-1595"></a>    fmv1 ~ fmv2    (CTyEqCan)
<a name="line-1596"></a>
<a name="line-1597"></a>Flatten using the fun-eqs first.
<a name="line-1598"></a>-}</span>
</pre></body>
</html>
