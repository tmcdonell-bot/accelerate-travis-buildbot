-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lifting linear vector spaces into Accelerate
--   
--   Lifting linear vector spaces into Accelerate
@package linear-accelerate
@version 0.3


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Epsilon

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Float)
--   True
--   </pre>
class Num a => Epsilon a
nearZero :: Epsilon a => Exp a -> Exp Bool

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-6
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-12
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-6
--   </pre>

-- | <pre>
--   <a>abs</a> a <a>&lt;=</a> 1e-12
--   </pre>
instance Epsilon CDouble
instance Epsilon CFloat
instance Epsilon Double
instance Epsilon Float


module Data.Array.Accelerate.Linear.Type
type Box f a = (Unlift Exp (f (Exp a)), Plain (f (Exp a)) ~ f a)
type Box2 f g a = (Box f (g a), Box g a, Lift Exp (f (g (Exp a))), Plain (f (g (Exp a))) ~ f (g a))


-- | Operations on free vector spaces
module Data.Array.Accelerate.Linear.Vector

-- | A vector is an additive group with additional structure.
--   
--   TODO: Support both <a>Exp</a> and <a>Acc</a>
class Additive f => Additive f where zero = constant (zero) (^+^) = lift2 ((^+^) :: f (Exp a) -> f (Exp a) -> f (Exp a)) (^-^) = lift2 ((^-^) :: f (Exp a) -> f (Exp a) -> f (Exp a)) lerp = lift3 (lerp :: Exp a -> f (Exp a) -> f (Exp a) -> f (Exp a))
zero :: (Additive f, Elt (f a), Num a) => Exp (f a)
(^+^) :: (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)
(^-^) :: (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)
lerp :: (Additive f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a) -> Exp (f a)
type IsAdditive f a = (Additive f, Box f a)

-- | Basis element
newtype E t
E :: (forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)) -> E t
el :: E t -> forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | Compute the negation of a vector
--   
--   <pre>
--   &gt;&gt;&gt; negated (V2 2 4)
--   V2 (-2) (-4)
--   </pre>
negated :: (Functor f, Num a, Box f a) => Exp (f a) -> Exp (f a)

-- | Compute the left scalar product
--   
--   <pre>
--   &gt;&gt;&gt; 2 *^ V2 3 4
--   V2 6 8
--   </pre>
(*^) :: (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)

-- | Compute the right scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 3 4 ^* 2
--   V2 6 8
--   </pre>
(^*) :: (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)

-- | Compute division by a scalar on the right
--   
--   V2 4 6 ^/ 2 V2 2 3
(^/) :: (Functor f, Fractional a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)

-- | Compute division of a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 4 /^ V2 2 4
--   V2 2 1
--   </pre>
(/^) :: (Functor f, Fractional a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)

-- | Addition with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 2 +^ V2 3 4
--   V2 5 4
--   </pre>
(+^) :: (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)

-- | Addition with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 ^+ 3
--   V2 4 3
--   </pre>
(^+) :: (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)

-- | Subtraction with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; 2 -^ V2 3 4
--   V2 1 2
--   </pre>
(-^) :: (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)

-- | Subtraction with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 ^- 3
--   V2 (-2) (-1)
--   </pre>
(^-) :: (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Metric

-- | Free and sparse inner product/metric spaces.
class Metric f => Metric f where dot = lift2 (dot :: f (Exp a) -> f (Exp a) -> Exp a) quadrance = lift1 (quadrance :: f (Exp a) -> Exp a) qd = lift2 (qd :: f (Exp a) -> f (Exp a) -> Exp a) distance = lift2 (distance :: f (Exp a) -> f (Exp a) -> Exp a) norm = lift1 (norm :: f (Exp a) -> Exp a) signorm = lift1 (signorm :: f (Exp a) -> f (Exp a))
dot :: (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a
quadrance :: (Metric f, Num a, Box f a) => Exp (f a) -> Exp a
qd :: (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a
distance :: (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a
norm :: (Metric f, Floating a, Box f a) => Exp (f a) -> Exp a
signorm :: (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a)
type IsMetric f a = (Metric f, Box f a)

-- | Normalize a <a>Metric</a> functor to have unit <a>norm</a>. This
--   function does not change the functor if its <a>norm</a> is 0 or 1.
normalize :: (Elt (f a), Floating a, IsMetric f a, Epsilon a) => Exp (f a) -> Exp (f a)

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: (Floating a, IsMetric f a) => Exp (f a) -> Exp (f a) -> Exp (f a)


-- | 0-D Vectors
module Data.Array.Accelerate.Linear.V0
data V0 a :: * -> *
V0 :: V0 a
instance [incoherent] (Elt a, Elt b) => Each (Exp (V0 a)) (Exp (V0 b)) (Exp a) (Exp b)
instance [incoherent] (Num a) => Num (Exp (V0 a))
instance [incoherent] Unlift Exp (V0 a)
instance [incoherent] Lift Exp (V0 a)
instance [incoherent] IsProduct cst (V0 a)
instance [incoherent] Elt a => Elt (V0 a)
instance [incoherent] Additive V0
instance [incoherent] Metric V0


-- | 1-D Vectors
module Data.Array.Accelerate.Linear.V1
newtype V1 a :: * -> *
V1 :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
ex :: R1 t => E t
instance [incoherent] (Elt a, Elt b) => Each (Exp (V1 a)) (Exp (V1 b)) (Exp a) (Exp b)
instance [incoherent] (Floating a) => Floating (Exp (V1 a))
instance [incoherent] (Floating a) => Fractional (Exp (V1 a))
instance [incoherent] (Num a) => Num (Exp (V1 a))
instance [incoherent] Elt a => Unlift Exp (V1 (Exp a))
instance [incoherent] (Lift Exp a, Elt (Plain a)) => Lift Exp (V1 a)
instance [incoherent] (cst a) => IsProduct cst (V1 a)
instance [incoherent] Elt a => Elt (V1 a)
instance [incoherent] R1 V1
instance [incoherent] Additive V1
instance [incoherent] Metric V1


-- | 2-D Vectors
module Data.Array.Accelerate.Linear.V2
data V2 a :: * -> *
V2 :: SrictNotUnpackeda -> SrictNotUnpackeda -> V2 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
ex :: R1 t => E t
ey :: R2 t => E t

-- | the counter-clockwise perpendicular vector
--   
--   <pre>
--   &gt;&gt;&gt; perp $ V2 10 20
--   V2 (-20) 10
--   </pre>
perp :: Num a => Exp (V2 a) -> Exp (V2 a)

-- | Unit vector with given phase angle (modulo 2*<a>pi</a>)
angle :: Floating a => Exp a -> Exp (V2 a)
instance [incoherent] (Elt a, Elt b) => Each (Exp (V2 a)) (Exp (V2 b)) (Exp a) (Exp b)
instance [incoherent] (Floating a) => Floating (Exp (V2 a))
instance [incoherent] (Floating a) => Fractional (Exp (V2 a))
instance [incoherent] (Num a) => Num (Exp (V2 a))
instance [incoherent] Elt a => Unlift Exp (V2 (Exp a))
instance [incoherent] (Lift Exp a, Elt (Plain a)) => Lift Exp (V2 a)
instance [incoherent] (cst a) => IsProduct cst (V2 a)
instance [incoherent] Elt a => Elt (V2 a)
instance [incoherent] R2 V2
instance [incoherent] R1 V2
instance [incoherent] Additive V2
instance [incoherent] Metric V2


-- | 3-D Vectors
module Data.Array.Accelerate.Linear.V3
data V3 a :: * -> *
V3 :: SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> V3 a

-- | cross product
cross :: Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a)

-- | scalar triple product
triple :: Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a) -> Exp a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t where _z = liftLens (_z :: Lens' (t (Exp a)) (Exp a)) _xyz = liftLens (_xyz :: Lens' (t (Exp a)) (V3 (Exp a)))
_z :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
instance [incoherent] (Elt a, Elt b) => Each (Exp (V3 a)) (Exp (V3 b)) (Exp a) (Exp b)
instance [incoherent] (Floating a) => Floating (Exp (V3 a))
instance [incoherent] (Floating a) => Fractional (Exp (V3 a))
instance [incoherent] (Num a) => Num (Exp (V3 a))
instance [incoherent] Elt a => Unlift Exp (V3 (Exp a))
instance [incoherent] (Lift Exp a, Elt (Plain a)) => Lift Exp (V3 a)
instance [incoherent] (cst a) => IsProduct cst (V3 a)
instance [incoherent] Elt a => Elt (V3 a)
instance [incoherent] R3 V3
instance [incoherent] R2 V3
instance [incoherent] R1 V3
instance [incoherent] Additive V3
instance [incoherent] Metric V3


-- | Quaternions
module Data.Array.Accelerate.Linear.Quaternion
data Quaternion a :: * -> *
Quaternion :: SrictNotUnpackeda -> Unpk(V3 a) -> Quaternion a
instance (Elt a, Elt b) => Each (Exp (Quaternion a)) (Exp (Quaternion b)) (Exp a) (Exp b)
instance Elt a => Unlift Exp (Quaternion (Exp a))
instance (Lift Exp a, Elt (Plain a)) => Lift Exp (Quaternion a)
instance (cst a) => IsProduct cst (Quaternion a)
instance Elt a => Elt (Quaternion a)
instance Additive Quaternion
instance Metric Quaternion


-- | 4-D Vectors
module Data.Array.Accelerate.Linear.V4
data V4 a :: * -> *
V4 :: SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> V4 a

-- | Convert a 3-dimensional affine vector into a 4-dimensional homogeneous
--   vector.
vector :: Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert a 3-dimensional affine point into a 4-dimensional homogeneous
--   vector.
point :: Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert 4-dimensional projective coordinates to a 3-dimensional point.
--   This operation may be denoted, <tt>euclidean [x:y:z:w] = (x/w, y/w,
--   z/w)</tt> where the projective, homogenous, coordinate
--   <tt>[x:y:z:w]</tt> is one of many associated with a single point
--   <tt>(x/w, y/w, z/w)</tt>.
normalizePoint :: Floating a => Exp (V4 a) -> Exp (V3 a)

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t where _x = liftLens (_x :: Lens' (t (Exp a)) (Exp a))
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t where _y = liftLens (_y :: Lens' (t (Exp a)) (Exp a)) _xy = liftLens (_xy :: Lens' (t (Exp a)) (V2 (Exp a)))
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t where _z = liftLens (_z :: Lens' (t (Exp a)) (Exp a)) _xyz = liftLens (_xyz :: Lens' (t (Exp a)) (V3 (Exp a)))
_z :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, and <a>_w</a>. (Although it may have more.)
class (R4 t, R3 t) => R4 t where _w = liftLens (_w :: Lens' (t (Exp a)) (Exp a)) _xyzw = liftLens (_xyzw :: Lens' (t (Exp a)) (V4 (Exp a)))
_w :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyzw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xyw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xzw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xywz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzyw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzwy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwyz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwzy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxzw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxwz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzxw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzwx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywxz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywzx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxyw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxwy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zyxw :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zywx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwxy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwyx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxyz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxzy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyxz :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyzx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzxy :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzyx :: (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
ew :: R4 t => E t
instance [incoherent] (Elt a, Elt b) => Each (Exp (V4 a)) (Exp (V4 b)) (Exp a) (Exp b)
instance [incoherent] (Floating a) => Floating (Exp (V4 a))
instance [incoherent] (Floating a) => Fractional (Exp (V4 a))
instance [incoherent] (Num a) => Num (Exp (V4 a))
instance [incoherent] Elt a => Unlift Exp (V4 (Exp a))
instance [incoherent] (Lift Exp a, Elt (Plain a)) => Lift Exp (V4 a)
instance [incoherent] (cst a) => IsProduct cst (V4 a)
instance [incoherent] Elt a => Elt (V4 a)
instance [incoherent] R4 V4
instance [incoherent] R3 V4
instance [incoherent] R2 V4
instance [incoherent] R1 V4
instance [incoherent] Additive V4
instance [incoherent] Metric V4


-- | Plücker coordinates for lines in 3d homogeneous space.
module Data.Array.Accelerate.Linear.Plucker
data Plucker a :: * -> *
Plucker :: SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> Plucker a

-- | Valid Plücker coordinates <tt>p</tt> will have <tt><a>squaredError</a>
--   p <a>==</a> 0</tt>
--   
--   That said, floating point makes a mockery of this claim, so you may
--   want to use <tt>nearZero</tt>.
squaredError :: Num a => Exp (Plucker a) -> Exp a

-- | This isn't the actual metric because this bilinear form gives rise to
--   an isotropic quadratic space
(><) :: Num a => Exp (Plucker a) -> Exp (Plucker a) -> Exp a

-- | Given a pair of points represented by homogeneous coordinates generate
--   Plücker coordinates for the line through them, directed from the
--   second towards the first.
plucker :: Num a => Exp (V4 a) -> Exp (V4 a) -> Exp (Plucker a)

-- | Given a pair of 3D points, generate Plücker coordinates for the line
--   through them, directed from the second towards the first.
plucker3D :: Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (Plucker a)
instance Typeable Plucker
instance (Elt a, Elt b) => Each (Exp (Plucker a)) (Exp (Plucker b)) (Exp a) (Exp b)
instance Elt a => Unlift Exp (Plucker (Exp a))
instance (Lift Exp a, Elt (Plain a)) => Lift Exp (Plucker a)
instance (cst a) => IsProduct cst (Plucker a)
instance Elt a => Elt (Plucker a)
instance Additive Plucker
instance Metric Plucker


-- | Simple matrix operations for low-dimensional primitives
module Data.Array.Accelerate.Linear.Matrix
type M22 a = V2 (V2 a)
type M23 a = V2 (V3 a)
type M24 a = V2 (V4 a)
type M32 a = V3 (V2 a)
type M33 a = V3 (V3 a)
type M34 a = V3 (V4 a)
type M42 a = V4 (V2 a)
type M43 a = V4 (V3 a)
type M44 a = V4 (V4 a)

-- | Matrix product. This can compute any combination of sparse and dense
--   multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !*! V3 (V2 1 2) (V2 3 4) (V2 4 5)
--   V2 (V2 19 25) (V2 43 58)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 (fromList [(1,2)]) (fromList [(2,3)]) !*! fromList [(1,V3 0 0 1), (2, V3 0 0 5)]
--   V2 (V3 0 0 2) (V3 0 0 15)
--   </pre>
(!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a, Box2 m t a, Box2 t n a, Box2 m n a) => Exp (m (t a)) -> Exp (t (n a)) -> Exp (m (n a))

-- | Entry-wise matrix addition.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !+! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 8 10 12) (V3 5 7 9)
--   </pre>
(!+!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))

-- | Entry-wise matrix subtraction.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !-! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 (-6) (-6) (-6)) (V3 3 3 3)
--   </pre>
(!-!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))

-- | Matrix * column vector
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !* V3 7 8 9
--   V2 50 122
--   </pre>
(!*) :: (Functor m, Foldable r, Additive r, Num a, Box2 m r a, Box m a) => Exp (m (r a)) -> Exp (r a) -> Exp (m a)

-- | Row vector * matrix
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 *! V2 (V3 3 4 5) (V3 6 7 8)
--   V3 15 18 21
--   </pre>
(*!) :: (Foldable t, Additive f, Additive t, Num a, Box t a, Box f a, Box2 t f a) => Exp (t a) -> Exp (t (f a)) -> Exp (f a)

-- | Matrix-scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V2 1 2) (V2 3 4) !!* 5
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(!!*) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))

-- | Scalar-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; 5 *!! V2 (V2 1 2) (V2 3 4)
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(*!!) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp a -> Exp (m (r a)) -> Exp (m (r a))

-- | Matrix-scalar division
(!!/) :: (Functor m, Functor r, Floating a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))

-- | <a>transpose</a> is just an alias for <a>distribute</a>
--   
--   <pre>
--   transpose (V3 (V2 1 2) (V2 3 4) (V2 5 6))
--   </pre>
--   
--   V2 (V3 1 3 5) (V3 2 4 6)
transpose :: (Distributive g, Functor f, Box2 f g a, Box2 g f a) => Exp (f (g a)) -> Exp (g (f a))

-- | The identity matrix for any dimension vector.
--   
--   <pre>
--   &gt;&gt;&gt; identity :: M44 Int
--   V4 (V4 1 0 0 0) (V4 0 1 0 0) (V4 0 0 1 0) (V4 0 0 0 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; identity :: V3 (V3 Int)
--   V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   </pre>
identity :: (Traversable t, Applicative t, Num a, Box2 t t a) => Exp (t (t a))
class Trace m => Trace m where trace = lift . trace . unlift' diagonal = lift . diagonal . unlift'
trace :: (Trace m, Num a, Box2 m m a) => Exp (m (m a)) -> Exp a
diagonal :: (Trace m, Box2 m m a) => Exp (m (m a)) -> Exp (m a)
instance Trace Quaternion
instance Trace Plucker
instance Trace V4
instance Trace V3
instance Trace V2
instance Trace V1
instance Trace V0
instance Trace Complex


-- | This module simply re-exports everything from the various modules that
--   make up the linear package, lifted to Accelerate.
module Data.Array.Accelerate.Linear
