-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lifting numeric-prelude into Accelerate
--   
--   Lifting numeric-prelude into Accelerate
@package numeric-prelude-accelerate
@version 0.1.0.0


module Data.Array.Accelerate.Algebra.Additive
instance (Elt a, Elt b, C (Exp a), C (Exp b)) => C (Exp (a, b))
instance C (Exp Double)
instance C (Exp Float)
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.ZeroTestable
class C a
isZero :: C a => a -> Exp Bool

-- | Checks if a number is the zero element. This test is not possible for
--   all <a>C</a> types, since e.g. a function type does not belong to Eq.
--   isZero is possible for some types where (==zero) fails because there
--   is no unique zero.
--   
--   Examples are vector (the length of the zero vector is unknown),
--   physical values (the unit of a zero quantity is unknown), residue
--   class (the modulus is unknown).
defltIsZero :: (C (Exp a), Eq a, Elt a) => Exp a -> Exp Bool
instance (C (Exp a), C (Exp b), C (Exp c)) => C (Exp (a, b, c))
instance (C (Exp a), C (Exp b)) => C (Exp (a, b))
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)
instance C (Exp Double)
instance C (Exp Float)
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), C (Exp e), C (Exp f), C (Exp g), C (Exp h), C (Exp i), Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i) => C (Exp (a, b, c, d, e, f, g, h, i))
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), C (Exp e), C (Exp f), C (Exp g), C (Exp h), Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h) => C (Exp (a, b, c, d, e, f, g, h))
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), C (Exp e), C (Exp f), C (Exp g), Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g) => C (Exp (a, b, c, d, e, f, g))
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), C (Exp e), C (Exp f), Elt a, Elt b, Elt c, Elt d, Elt e, Elt f) => C (Exp (a, b, c, d, e, f))
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), C (Exp e), Elt a, Elt b, Elt c, Elt d, Elt e) => C (Exp (a, b, c, d, e))
instance (C (Exp a), C (Exp b), C (Exp c), C (Exp d), Elt a, Elt b, Elt c, Elt d) => C (Exp (a, b, c, d))
instance (C (Exp a), C (Exp b), C (Exp c), Elt a, Elt b, Elt c) => C (Exp (a, b, c))
instance (C (Exp a), C (Exp b), Elt a, Elt b) => C (Exp (a, b))
instance (C (Exp sh), Slice sh) => C (Exp (sh :. Int))
instance C (Exp Z)
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)
instance C (Exp Double)
instance C (Exp Float)


module Data.Array.Accelerate.Algebra.Ring
instance (Elt a, Elt b, C (Exp a), C (Exp b)) => C (Exp (a, b))
instance C (Exp Double)
instance C (Exp Float)
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.Field
instance (C (Exp a), C (Exp b), Elt a, Elt b) => C (Exp (a, b))
instance C (Exp Double)
instance C (Exp Float)


module Data.Array.Accelerate.Algebra.Algebraic
instance C (Exp Double)
instance C (Exp Float)


module Data.Array.Accelerate.Algebra.Transcendental
instance C (Exp Double)
instance C (Exp Float)


module Data.Array.Accelerate.Algebra.IntegralDomain

-- | Allows division by zero. If the denominator is zero, the numerator is
--   returned as the remainder.
divModZero :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp (a, a)

-- | Test if the first argument evenly divides the second
divides :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp Bool
sameResidueClass :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp a -> Exp Bool
even :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp Bool
odd :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp Bool
instance (C (Exp a), C (Exp b), Elt a, Elt b) => C (Exp (a, b))
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.Module
instance C (Exp Double) (Exp Double)
instance C (Exp Float) (Exp Float)
instance C (Exp Int) (Exp Int)


module Data.Array.Accelerate.Algebra.Absolute
instance C (Exp Double)
instance C (Exp Float)
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.Units

-- | This class lets us deal with units in a ring. <a>isUnit</a> tells us
--   whether an element is a unit, while the other operations let us
--   canonically write an element as a unit times another element.
--   
--   This instance shadows <a>C</a> with an instance of <a>isUnit</a>
--   compatible with Accelerate.
class C a => C a where stdAssociate x = x * stdUnitInv x stdUnit x = one `div` stdUnitInv x stdUnitInv x = one `div` stdUnit x
isUnit :: C a => a -> Exp Bool
stdAssociate :: C a => a -> a
stdUnit :: C a => a -> a
stdUnitInv :: C a => a -> a
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.PrincipalIdealDomain
class (C a, C a) => C a
extendedGCD :: C a => a -> a -> (a, (a, a))
gcd :: C a => a -> a -> a
lcm :: C a => a -> a -> a

-- | Two integers <tt>a</tt> and <tt>b</tt> are coprime (aka: relatively
--   prime, mutually prime) if the only positive integer that divides them
--   both is one.
coprime :: (C (Exp a), C (Exp a)) => Exp a -> Exp a -> Exp Bool

-- | An efficient method for computing the greatest common divisor of two
--   numbers.
euclid :: (C (Exp a), C (Exp a), Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Exp a -> Exp a

-- | Implementation of the extended Euclid algorithm which computes,
--   besides the greatest common divisor of integers <tt>a</tt> and
--   <tt>b</tt>, the coefficients of BÃ©zout's identity <tt>x</tt> and
--   <tt>y</tt> such that:
--   
--   <pre>
--   ax + by = gcd(a, b)
--   </pre>
--   
--   
--   <a>https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode</a>
extendedEuclid :: (C (Exp a), C (Exp a), C (Exp a), C (Exp a), Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Exp a -> Exp (a, (a, a))
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.RealIntegral
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.ToRational
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


-- | Vacuous implementation of the numeric-prelude <tt>ToInteger</tt>
--   module. The NP.fromIntegral function is completely untenable for
--   Accelerate, but maybe we can get around that sometimes with rewrite
--   rules.
module Data.Array.Accelerate.Algebra.ToInteger
instance C (Exp Word64)
instance C (Exp Word32)
instance C (Exp Word16)
instance C (Exp Word8)
instance C (Exp Word)
instance C (Exp Int64)
instance C (Exp Int32)
instance C (Exp Int16)
instance C (Exp Int8)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.RealRing
instance C (Exp Double)
instance C (Exp Float)
instance C (Exp Int)


module Data.Array.Accelerate.Algebra.RealField
instance C (Exp Double)
instance C (Exp Float)


module Data.Array.Accelerate.Algebra.RealTranscendental
instance C (Exp Double)
instance C (Exp Float)


-- | Complex numbers
module Data.Array.Accelerate.Number.Complex
data T a :: * -> *

-- | Real part
real :: Elt a => Exp (T a) -> Exp a

-- | Imaginary part
imag :: Elt a => Exp (T a) -> Exp a

-- | Construct a complex number from the real and imaginary parts
(+:) :: Elt a => Exp a -> Exp a -> Exp (T a)

-- | Construct a complex number with negated imaginary part
(-:) :: (Elt a, C (Exp a)) => Exp a -> Exp a -> Exp (T a)

-- | Scale a complex number by a real number.
scale :: (C (Exp a), Elt a) => Exp a -> Exp (T a) -> Exp (T a)

-- | Exponential of a complex number with minimal type class constraints.
exp :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | Turn the point one quarter to the left
quarterLeft :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | Turn the point one quarter to the right.
quarterRight :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | The function <a>toPolar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   non-negative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
toPolar :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp (a, a)

-- | Form a complex number from polar components of magnitude and phase.
fromPolar :: (C (Exp a), Elt a) => Exp a -> Exp a -> Exp (T a)

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: (C (Exp a), Elt a) => Exp a -> Exp (T a)

-- | Scale a complex number to magnitude 1.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
signum :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | The non-negative magnitude of a complex number. This implementation
--   respects the limited range of floating point numbers. The trivial
--   implementation <a>magnitude</a> would overflow for floating point
--   exponents greater than the half of the maximum admissible exponent.
--   
--   floatMagnitude :: (P.RealFloat a, Algebraic.C a) =&gt; T a -&gt; a
--   floatMagnitude (Cons x y) = let k = max (P.exponent x) (P.exponent y)
--   mk = - k in P.scaleFloat k (sqrt (P.scaleFloat mk x ^ 2 + P.scaleFloat
--   mk y ^ 2))
--   
--   The non-negative magnitude of a complex number.
magnitude :: (C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | Like NormedEuc.normSqr with lifted class constraints
magnitudeSqr :: (C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | The conjugate of a complex number.
conjugate :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)
instance Typeable T
instance Elt a => Unlift Exp (T (Exp a))
instance (Lift Exp a, Elt (Plain a)) => Lift Exp (T a)
instance (cst a) => IsProduct cst (T a)
instance Elt a => Elt (T a)
instance (C (Exp a), C (Exp a), C (Exp a), C (Exp a), Ord a, Elt a) => C (Exp (T a))
instance (C (Exp a), C (Exp a), C (Exp a), C (Exp a), C (Exp a), C (Exp a), Ord a, Elt a) => C (Exp (T a))
instance (C (Exp a), Elt a) => C (Exp (T a))
instance (C (Exp a), C (Exp a), C (Exp a), Elt a) => C (Exp (T a))
instance (C (Exp a), Elt a) => C (Exp (T a))
instance (C (Exp a), Elt a) => C (Exp (T a))
instance (C (Exp a), Elt a) => C (Exp (T a))
