-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hedgehog will eat all your bugs.
--   
--   Hedgehog is a modern property-based testing system, in the spirit of
--   QuickCheck. Hedgehog uses integrated shrinking, so shrinks obey the
--   invariants of generated values by construction.
--   
--   To get started quickly, see the examples:
--   <a>https://github.com/hedgehogqa/haskell-hedgehog/tree/master/hedgehog-example</a>
@package hedgehog
@version 0.6.1

module Hedgehog.Internal.Config

-- | Whether to render output using ANSI colors or not.
data UseColor

-- | Disable ANSI colors in report output.
DisableColor :: UseColor

-- | Enable ANSI colors in report output.
EnableColor :: UseColor
resolveColor :: MonadIO m => Maybe UseColor -> m UseColor

-- | How verbose should the report output be.
data Verbosity

-- | Only display the summary of the test run.
Quiet :: Verbosity

-- | Display each property as it is running, as well as the summary.
Normal :: Verbosity
resolveVerbosity :: MonadIO m => Maybe Verbosity -> m Verbosity

-- | The number of workers to use when running properties in parallel.
newtype WorkerCount
WorkerCount :: Int -> WorkerCount
resolveWorkers :: MonadIO m => Maybe WorkerCount -> m WorkerCount
detectMark :: MonadIO m => m Bool
detectColor :: MonadIO m => m UseColor
detectVerbosity :: MonadIO m => m Verbosity
detectWorkers :: MonadIO m => m WorkerCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.WorkerCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.Verbosity
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.UseColor
instance GHC.Real.Integral Hedgehog.Internal.Config.WorkerCount
instance GHC.Real.Real Hedgehog.Internal.Config.WorkerCount
instance GHC.Enum.Enum Hedgehog.Internal.Config.WorkerCount
instance GHC.Num.Num Hedgehog.Internal.Config.WorkerCount
instance GHC.Show.Show Hedgehog.Internal.Config.WorkerCount
instance GHC.Classes.Ord Hedgehog.Internal.Config.WorkerCount
instance GHC.Classes.Eq Hedgehog.Internal.Config.WorkerCount
instance GHC.Show.Show Hedgehog.Internal.Config.Verbosity
instance GHC.Classes.Ord Hedgehog.Internal.Config.Verbosity
instance GHC.Classes.Eq Hedgehog.Internal.Config.Verbosity
instance GHC.Show.Show Hedgehog.Internal.Config.UseColor
instance GHC.Classes.Ord Hedgehog.Internal.Config.UseColor
instance GHC.Classes.Eq Hedgehog.Internal.Config.UseColor

module Hedgehog.Internal.Distributive
class Distributive g where {
    type family Transformer (f :: (* -> *) -> * -> *) (g :: (* -> *) -> * -> *) (m :: * -> *) :: Constraint;
    type Transformer f g m = (Monad m, Monad (f m), Monad (g m), Monad (f (g m)), MonadTrans f, MFunctor f);
}

-- | Distribute one monad transformer over another.
distribute :: (Distributive g, Transformer f g m) => g (f m) a -> f (g m) a
instance Hedgehog.Internal.Distributive.Distributive Control.Monad.Trans.Maybe.MaybeT
instance Hedgehog.Internal.Distributive.Distributive (Control.Monad.Trans.Except.ExceptT x)
instance GHC.Base.Monoid w => Hedgehog.Internal.Distributive.Distributive (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Hedgehog.Internal.Distributive.Distributive (Control.Monad.Trans.Reader.ReaderT r)

module Hedgehog.Internal.Exception
tryAll :: MonadCatch m => m a -> m (Either SomeException a)
tryEvaluate :: a -> Either SomeException a

module Hedgehog.Internal.HTraversable

-- | Higher-order traversable functors.
--   
--   This is used internally to make symbolic variables concrete given an
--   <tt>Environment</tt>.
class HTraversable t
htraverse :: (HTraversable t, Applicative f) => (forall a. g a -> f (h a)) -> t g -> f (t h)

module Hedgehog.Internal.Opaque

-- | Opaque values.
--   
--   Useful if you want to put something without a <a>Show</a> instance
--   inside something which you'd like to be able to display.
--   
--   For example:
--   
--   <pre>
--   data State v =
--     State {
--         stateRefs :: [Var (Opaque (IORef Int)) v]
--       } deriving (Eq, Show)
--   </pre>
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Opaque.Opaque a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Opaque.Opaque a)
instance GHC.Show.Show (Hedgehog.Internal.Opaque.Opaque a)

module Hedgehog.Internal.Queue
newtype TaskIndex
TaskIndex :: Int -> TaskIndex
newtype TasksRemaining
TasksRemaining :: Int -> TasksRemaining
runTasks :: WorkerCount -> [a] -> (TasksRemaining -> TaskIndex -> a -> IO b) -> (b -> IO ()) -> (b -> IO ()) -> (b -> IO c) -> IO [c]
finalizeTask :: MonadIO m => MVar (TaskIndex, Map TaskIndex (IO ())) -> TaskIndex -> IO () -> m ()
runActiveFinalizers :: MonadIO m => MVar (TaskIndex, Map TaskIndex (IO ())) -> m ()
dequeueMVar :: MVar [(TaskIndex, a)] -> (TasksRemaining -> TaskIndex -> a -> IO b) -> IO (Maybe (TaskIndex, b))

-- | Update the number of capabilities but never set it lower than it
--   already is.
updateNumCapabilities :: WorkerCount -> IO ()
instance GHC.Num.Num Hedgehog.Internal.Queue.TaskIndex
instance GHC.Enum.Enum Hedgehog.Internal.Queue.TaskIndex
instance GHC.Classes.Ord Hedgehog.Internal.Queue.TaskIndex
instance GHC.Classes.Eq Hedgehog.Internal.Queue.TaskIndex

module Hedgehog.Internal.Range

-- | Tests are parameterized by the size of the randomly-generated data,
--   the meaning of which depends on the particular generator used.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a
Range :: !a -> (Size -> (a, a)) -> Range a

-- | Get the origin of a range. This might be the mid-point or the lower
--   bound, depending on what the range represents.
--   
--   The <a>bounds</a> of a range are scaled around this value when using
--   the <a>linear</a> family of combinators.
--   
--   When using a <a>Range</a> to generate numbers, the shrinking function
--   will shrink towards the origin.
origin :: Range a -> a

-- | Get the extents of a range, for a given size.
bounds :: Size -> Range a -> (a, a)

-- | Get the lower bound of a range for the given size.
lowerBound :: Ord a => Size -> Range a -> a

-- | Get the upper bound of a range for the given size.
upperBound :: Ord a => Size -> Range a -> a

-- | Construct a range which represents a constant single value.
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ singleton 5
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ singleton 5
--   5
--   </pre>
singleton :: a -> Range a

-- | Construct a range which is unaffected by the size parameter.
--   
--   A range from <tt>0</tt> to <tt>10</tt>, with the origin at <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constant 0 10
--   (0,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constant 0 10
--   0
--   </pre>
constant :: a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter with a
--   origin point which may differ from the bounds.
--   
--   A range from <tt>-10</tt> to <tt>10</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 0 (-10) 10
--   (-10,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 0 (-10) 10
--   0
--   </pre>
--   
--   A range from <tt>1970</tt> to <tt>2100</tt>, with the origin at
--   <tt>2000</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 2000 1970 2100
--   (1970,2100)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 2000 1970 2100
--   2000
--   </pre>
constantFrom :: a -> a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter using the
--   full range of a data type.
--   
--   A range from <tt>-128</tt> to <tt>127</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x (constantBounded :: Range Int8)
--   (-128,127)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin (constantBounded :: Range Int8)
--   0
--   </pre>
constantBounded :: (Bounded a, Num a) => Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linear 0 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linear 0 10
--   (0,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linear 0 10
--   (0,10)
--   </pre>
linear :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linearFrom 0 (-10) 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linearFrom 0 (-10) 20
--   (-5,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linearFrom 0 (-10) 20
--   (-10,20)
--   </pre>
linearFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   This works the same as <a>linear</a>, but for fractional values.
linearFrac :: (Fractional a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   This works the same as <a>linearFrom</a>, but for fractional values.
linearFracFrom :: (Fractional a, Ord a) => a -> a -> a -> Range a

-- | Construct a range which is scaled relative to the size parameter and
--   uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (linearBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (linearBounded :: Range Int8)
--   (-64,64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (linearBounded :: Range Int8)
--   (-128,127)
--   </pre>
linearBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponential 1 512
--   (1,1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 11 $ exponential 1 512
--   (1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 22 $ exponential 1 512
--   (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 77 $ exponential 1 512
--   (1,128)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 88 $ exponential 1 512
--   (1,256)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponential 1 512
--   (1,512)
--   </pre>
exponential :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFrom 0 (-128) 512
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 25 $ exponentialFrom 0 (-128) 512
--   (-2,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFrom 0 (-128) 512
--   (-11,22)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 75 $ exponentialFrom 0 (-128) 512
--   (-39,112)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFrom x (-128) 512
--   (-128,512)
--   </pre>
exponentialFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which is scaled exponentially relative to the size
--   parameter and uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (exponentialBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (exponentialBounded :: Range Int8)
--   (-11,11)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (exponentialBounded :: Range Int8)
--   (-128,127)
--   </pre>
exponentialBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   This works the same as <a>exponential</a>, but for floating-point
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloat 0 10
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloat 0 10
--   (0.0,2.357035250656098)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloat 0 10
--   (0.0,10.0)
--   </pre>
exponentialFloat :: (Floating a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   This works the same as <a>exponentialFrom</a>, but for floating-point
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloatFrom 0 (-10) 20
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloatFrom 0 (-10) 20
--   (-2.357035250656098,3.6535836249197002)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloatFrom x (-10) 20
--   (-10.0,20.0)
--   </pre>
exponentialFloatFrom :: (Floating a, Ord a) => a -> a -> a -> Range a

-- | Truncate a value so it stays within some range.
--   
--   <pre>
--   &gt;&gt;&gt; clamp 5 10 15
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clamp 5 10 0
--   5
--   </pre>
clamp :: Ord a => a -> a -> a -> a

-- | Scale an integral linearly with the size parameter.
scaleLinear :: Integral a => Size -> a -> a -> a

-- | Scale a fractional number linearly with the size parameter.
scaleLinearFrac :: Fractional a => Size -> a -> a -> a

-- | Scale an integral exponentially with the size parameter.
scaleExponential :: Integral a => Size -> a -> a -> a

-- | Scale a floating-point number exponentially with the size parameter.
scaleExponentialFloat :: Floating a => Size -> a -> a -> a
instance GHC.Real.Integral Hedgehog.Internal.Range.Size
instance GHC.Enum.Enum Hedgehog.Internal.Range.Size
instance GHC.Real.Real Hedgehog.Internal.Range.Size
instance GHC.Num.Num Hedgehog.Internal.Range.Size
instance GHC.Classes.Ord Hedgehog.Internal.Range.Size
instance GHC.Classes.Eq Hedgehog.Internal.Range.Size
instance GHC.Base.Functor Hedgehog.Internal.Range.Range
instance GHC.Show.Show Hedgehog.Internal.Range.Size
instance GHC.Read.Read Hedgehog.Internal.Range.Size

module Hedgehog.Internal.Region
newtype Region
Region :: TVar Body -> Region
[unRegion] :: Region -> TVar Body
newEmptyRegion :: LiftRegion m => m Region
newOpenRegion :: LiftRegion m => m Region
openRegion :: LiftRegion m => Region -> String -> m ()
setRegion :: LiftRegion m => Region -> String -> m ()
displayRegions :: (MonadIO m, MonadMask m) => m a -> m a
displayRegion :: MonadIO m => MonadMask m => LiftRegion m => (Region -> m a) -> m a
moveToBottom :: Region -> STM ()
finishRegion :: LiftRegion m => Region -> m ()


-- | This is a port of "Fast Splittable Pseudorandom Number Generators" by
--   Steele et. al. [1].
--   
--   The paper's algorithm provides decent randomness for most purposes but
--   sacrifices cryptographic-quality randomness in favor of speed. The
--   original implementation is tested with DieHarder and BigCrush; see the
--   paper for details.
--   
--   This implementation, originally from [2], is a port from the paper.
--   
--   It also takes in to account the SplittableRandom.java source code in
--   OpenJDK v8u40-b25 as well as splittable_random.ml in Jane Street's
--   standard library overlay (kernel) v113.33.03, and Random.fs in FsCheck
--   v3.
--   
--   Other than the choice of initial seed for <a>from</a> this port should
--   be faithful.
--   
--   <ol>
--   <li>Guy L. Steele, Jr., Doug Lea, Christine H. Flood Fast splittable
--   pseudorandom number generators Comm ACM, 49(10), Oct 2014,
--   pp453-472.</li>
--   <li>Nikos Baxevanis
--   <a>https://github.com/moodmosaic/SplitMix/blob/master/SplitMix.hs</a></li>
--   </ol>
module Hedgehog.Internal.Seed

-- | A splittable random number generator.
data Seed
Seed :: !Word64 -> !Word64 -> Seed
[seedValue] :: Seed -> !Word64

-- | must be an odd number
[seedGamma] :: Seed -> !Word64

-- | Create a random <a>Seed</a> using an effectful source of randomness.
random :: MonadIO m => m Seed

-- | Create a <a>Seed</a> using a <a>Word64</a>.
from :: Word64 -> Seed

-- | Splits a random number generator in to two.
split :: Seed -> (Seed, Seed)

-- | Generate a random <a>Integer</a> in the [inclusive,inclusive] range.
nextInteger :: Integer -> Integer -> Seed -> (Integer, Seed)

-- | Generate a random <a>Double</a> in the [inclusive,exclusive) range.
nextDouble :: Double -> Double -> Seed -> (Double, Seed)

-- | A predefined gamma value's needed for initializing the "root"
--   instances of <a>Seed</a>. That is, instances not produced by splitting
--   an already existing instance.
--   
--   We choose: the odd integer closest to <tt>2^64/φ</tt>, where <tt>φ =
--   (1 + √5)/2</tt> is the golden ratio.
goldenGamma :: Word64

-- | Generate a random <a>Word64</a>.
nextWord64 :: Seed -> (Word64, Seed)

-- | Generate a random <a>Word32</a>.
nextWord32 :: Seed -> (Word32, Seed)
mix64 :: Word64 -> Word64
mix64variant13 :: Word64 -> Word64
mix32 :: Word64 -> Word32
mixGamma :: Word64 -> Word64
instance GHC.Classes.Ord Hedgehog.Internal.Seed.Seed
instance GHC.Classes.Eq Hedgehog.Internal.Seed.Seed
instance GHC.Show.Show Hedgehog.Internal.Seed.Seed
instance GHC.Read.Read Hedgehog.Internal.Seed.Seed
instance System.Random.RandomGen Hedgehog.Internal.Seed.Seed

module Hedgehog.Internal.Show

-- | A name.
type Name = String

-- | Generic Haskell values. <tt>NaN</tt> and <tt>Infinity</tt> are
--   represented as constructors. The <a>Value</a> in the literals is the
--   text for the literals "as is".
--   
--   A chain of infix constructors means that they appeared in the input
--   string without parentheses, i.e
--   
--   <tt>1 :+: 2 :*: 3</tt> is represented with <tt>InfixCons 1
--   [(":+:",2),(":*:",3)]</tt>, whereas
--   
--   <tt>1 :+: (2 :*: 3)</tt> is represented with <tt>InfixCons 1
--   [(":+:",InfixCons 2 [(":*:",3)])]</tt>.
data Value

-- | Data constructor
Con :: Name -> [Value] -> Value

-- | Infix data constructor chain
InfixCons :: Value -> [(Name, Value)] -> Value

-- | Record value
Rec :: Name -> [(Name, Value)] -> Value

-- | Tuple
Tuple :: [Value] -> Value

-- | List
List :: [Value] -> Value

-- | Negated value
Neg :: Value -> Value

-- | Rational
Ratio :: Value -> Value -> Value

-- | Non-negative integer
Integer :: String -> Value

-- | Non-negative floating num.
Float :: String -> Value

-- | Character
Char :: String -> Value

-- | String
String :: String -> Value
data ValueDiff
ValueCon :: Name -> [ValueDiff] -> ValueDiff
ValueRec :: Name -> [(Name, ValueDiff)] -> ValueDiff
ValueTuple :: [ValueDiff] -> ValueDiff
ValueList :: [ValueDiff] -> ValueDiff
ValueSame :: Value -> ValueDiff
ValueDiff :: Value -> Value -> ValueDiff
data LineDiff
LineSame :: String -> LineDiff
LineRemoved :: String -> LineDiff
LineAdded :: String -> LineDiff
mkValue :: Show a => a -> Maybe Value
showPretty :: Show a => a -> String
valueDiff :: Value -> Value -> ValueDiff
lineDiff :: Value -> Value -> [LineDiff]
toLineDiff :: ValueDiff -> [LineDiff]
renderValue :: Value -> String
renderValueDiff :: ValueDiff -> String
renderLineDiff :: LineDiff -> String
takeLeft :: ValueDiff -> Value
takeRight :: ValueDiff -> Value
instance GHC.Show.Show Hedgehog.Internal.Show.DocDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.DocDiff
instance GHC.Show.Show Hedgehog.Internal.Show.LineDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.LineDiff
instance GHC.Show.Show Hedgehog.Internal.Show.ValueDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.ValueDiff

module Hedgehog.Internal.Shrink

-- | Shrink an integral number by edging towards a destination.
--   
--   <pre>
--   &gt;&gt;&gt; towards 0 100
--   [0,50,75,88,94,97,99]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; towards 500 1000
--   [500,750,875,938,969,985,993,997,999]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; towards (-50) (-26)
--   [-50,-38,-32,-29,-27]
--   </pre>
--   
--   <i>Note we always try the destination first, as that is the optimal
--   shrink.</i>
towards :: Integral a => a -> a -> [a]

-- | Shrink a floating-point number by edging towards a destination.
--   
--   <pre>
--   &gt;&gt;&gt; take 7 (towardsFloat 0.0 100)
--   [0.0,50.0,75.0,87.5,93.75,96.875,98.4375]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 7 (towardsFloat 1.0 0.5)
--   [1.0,0.75,0.625,0.5625,0.53125,0.515625,0.5078125]
--   </pre>
--   
--   <i>Note we always try the destination first, as that is the optimal
--   shrink.</i>
towardsFloat :: RealFloat a => a -> a -> [a]

-- | Shrink a list by edging towards the empty list.
--   
--   <pre>
--   &gt;&gt;&gt; list [1,2,3]
--   [[],[2,3],[1,3],[1,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; list "abcd"
--   ["","cd","ab","bcd","acd","abd","abc"]
--   </pre>
--   
--   <i>Note we always try the empty list first, as that is the optimal
--   shrink.</i>
list :: [a] -> [[a]]

-- | Produce a list containing the progressive halving of an integral.
--   
--   <pre>
--   &gt;&gt;&gt; halves 15
--   [15,7,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; halves 100
--   [100,50,25,12,6,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; halves (-26)
--   [-26,-13,-6,-3,-1]
--   </pre>
halves :: Integral a => a -> [a]

-- | Produce all permutations of removing <tt>k</tt> elements from a list.
--   
--   <pre>
--   &gt;&gt;&gt; removes 2 "abcdef"
--   ["cdef","abef","abcd"]
--   </pre>
removes :: Int -> [a] -> [[a]]

-- | Cons an element on to the front of a list unless it is already there.
consNub :: Eq a => a -> [a] -> [a]

module Hedgehog.Internal.Source
newtype LineNo
LineNo :: Int -> LineNo
[unLineNo] :: LineNo -> Int
newtype ColumnNo
ColumnNo :: Int -> ColumnNo
[unColumnNo] :: ColumnNo -> Int
data Span
Span :: !FilePath -> !LineNo -> !ColumnNo -> !LineNo -> !ColumnNo -> Span
[spanFile] :: Span -> !FilePath
[spanStartLine] :: Span -> !LineNo
[spanStartColumn] :: Span -> !ColumnNo
[spanEndLine] :: Span -> !LineNo
[spanEndColumn] :: Span -> !ColumnNo
getCaller :: CallStack -> Maybe Span

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack -> CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack -> a) -> a
instance GHC.Classes.Ord Hedgehog.Internal.Source.Span
instance GHC.Classes.Eq Hedgehog.Internal.Source.Span
instance GHC.Real.Integral Hedgehog.Internal.Source.ColumnNo
instance GHC.Real.Real Hedgehog.Internal.Source.ColumnNo
instance GHC.Enum.Enum Hedgehog.Internal.Source.ColumnNo
instance GHC.Num.Num Hedgehog.Internal.Source.ColumnNo
instance GHC.Classes.Ord Hedgehog.Internal.Source.ColumnNo
instance GHC.Classes.Eq Hedgehog.Internal.Source.ColumnNo
instance GHC.Real.Integral Hedgehog.Internal.Source.LineNo
instance GHC.Real.Real Hedgehog.Internal.Source.LineNo
instance GHC.Enum.Enum Hedgehog.Internal.Source.LineNo
instance GHC.Num.Num Hedgehog.Internal.Source.LineNo
instance GHC.Classes.Ord Hedgehog.Internal.Source.LineNo
instance GHC.Classes.Eq Hedgehog.Internal.Source.LineNo
instance GHC.Show.Show Hedgehog.Internal.Source.Span
instance GHC.Show.Show Hedgehog.Internal.Source.ColumnNo
instance GHC.Show.Show Hedgehog.Internal.Source.LineNo

module Hedgehog.Internal.Tree

-- | An effectful tree, each node in the tree can have an effect before it
--   is produced.
newtype Tree m a
Tree :: m (Node m a) -> Tree m a
[runTree] :: Tree m a -> m (Node m a)

-- | A node in an effectful tree, as well as its unevaluated children.
data Node m a
Node :: a -> [Tree m a] -> Node m a
[nodeValue] :: Node m a -> a
[nodeChildren] :: Node m a -> [Tree m a]

-- | Create a <a>Tree</a> from a <a>Node</a>
fromNode :: Applicative m => Node m a -> Tree m a

-- | Create a tree from a value and an unfolding function.
unfold :: Monad m => (a -> [a]) -> a -> Tree m a

-- | Create a forest from a value and an unfolding function.
unfoldForest :: Monad m => (a -> [a]) -> a -> [Tree m a]

-- | Expand a tree using an unfolding function.
expand :: Monad m => (a -> [a]) -> Tree m a -> Tree m a

-- | Throw away a tree's children.
prune :: Monad m => Tree m a -> Tree m a

-- | Render a tree of strings, note that this forces all the delayed
--   effects in the tree.
render :: Monad m => Tree m String -> m String
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Tree.Node m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Tree.Tree m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Tree.Node m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Tree.Tree m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Tree.Node m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Tree.Tree m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Hedgehog.Internal.Tree.Tree m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Tree.Tree
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Tree.Node
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Tree.Tree
instance Control.Monad.Morph.MMonad Hedgehog.Internal.Tree.Tree
instance Hedgehog.Internal.Distributive.Distributive Hedgehog.Internal.Tree.Tree
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Tree.Tree m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Tree.Tree m)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Hedgehog.Internal.Tree.Node m a)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Hedgehog.Internal.Tree.Tree m a)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Hedgehog.Internal.Tree.Node m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Hedgehog.Internal.Tree.Tree m)

module Hedgehog.Range

-- | Tests are parameterized by the size of the randomly-generated data,
--   the meaning of which depends on the particular generator used.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a

-- | Get the origin of a range. This might be the mid-point or the lower
--   bound, depending on what the range represents.
--   
--   The <a>bounds</a> of a range are scaled around this value when using
--   the <a>linear</a> family of combinators.
--   
--   When using a <a>Range</a> to generate numbers, the shrinking function
--   will shrink towards the origin.
origin :: Range a -> a

-- | Get the extents of a range, for a given size.
bounds :: Size -> Range a -> (a, a)

-- | Get the lower bound of a range for the given size.
lowerBound :: Ord a => Size -> Range a -> a

-- | Get the upper bound of a range for the given size.
upperBound :: Ord a => Size -> Range a -> a

-- | Construct a range which represents a constant single value.
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ singleton 5
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ singleton 5
--   5
--   </pre>
singleton :: a -> Range a

-- | Construct a range which is unaffected by the size parameter.
--   
--   A range from <tt>0</tt> to <tt>10</tt>, with the origin at <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constant 0 10
--   (0,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constant 0 10
--   0
--   </pre>
constant :: a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter with a
--   origin point which may differ from the bounds.
--   
--   A range from <tt>-10</tt> to <tt>10</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 0 (-10) 10
--   (-10,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 0 (-10) 10
--   0
--   </pre>
--   
--   A range from <tt>1970</tt> to <tt>2100</tt>, with the origin at
--   <tt>2000</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 2000 1970 2100
--   (1970,2100)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 2000 1970 2100
--   2000
--   </pre>
constantFrom :: a -> a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter using the
--   full range of a data type.
--   
--   A range from <tt>-128</tt> to <tt>127</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x (constantBounded :: Range Int8)
--   (-128,127)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin (constantBounded :: Range Int8)
--   0
--   </pre>
constantBounded :: (Bounded a, Num a) => Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linear 0 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linear 0 10
--   (0,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linear 0 10
--   (0,10)
--   </pre>
linear :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linearFrom 0 (-10) 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linearFrom 0 (-10) 20
--   (-5,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linearFrom 0 (-10) 20
--   (-10,20)
--   </pre>
linearFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   This works the same as <a>linear</a>, but for fractional values.
linearFrac :: (Fractional a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   This works the same as <a>linearFrom</a>, but for fractional values.
linearFracFrom :: (Fractional a, Ord a) => a -> a -> a -> Range a

-- | Construct a range which is scaled relative to the size parameter and
--   uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (linearBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (linearBounded :: Range Int8)
--   (-64,64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (linearBounded :: Range Int8)
--   (-128,127)
--   </pre>
linearBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponential 1 512
--   (1,1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 11 $ exponential 1 512
--   (1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 22 $ exponential 1 512
--   (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 77 $ exponential 1 512
--   (1,128)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 88 $ exponential 1 512
--   (1,256)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponential 1 512
--   (1,512)
--   </pre>
exponential :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFrom 0 (-128) 512
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 25 $ exponentialFrom 0 (-128) 512
--   (-2,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFrom 0 (-128) 512
--   (-11,22)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 75 $ exponentialFrom 0 (-128) 512
--   (-39,112)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFrom x (-128) 512
--   (-128,512)
--   </pre>
exponentialFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which is scaled exponentially relative to the size
--   parameter and uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (exponentialBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (exponentialBounded :: Range Int8)
--   (-11,11)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (exponentialBounded :: Range Int8)
--   (-128,127)
--   </pre>
exponentialBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   This works the same as <a>exponential</a>, but for floating-point
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloat 0 10
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloat 0 10
--   (0.0,2.357035250656098)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloat 0 10
--   (0.0,10.0)
--   </pre>
exponentialFloat :: (Floating a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   This works the same as <a>exponentialFrom</a>, but for floating-point
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloatFrom 0 (-10) 20
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloatFrom 0 (-10) 20
--   (-2.357035250656098,3.6535836249197002)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloatFrom x (-10) 20
--   (-10.0,20.0)
--   </pre>
exponentialFloatFrom :: (Floating a, Ord a) => a -> a -> a -> Range a

module Hedgehog.Internal.Gen

-- | Generator for random values of <tt>a</tt>.
type Gen = GenT Identity

-- | Monad transformer which can generate random values of <tt>a</tt>.
newtype GenT m a
GenT :: (Size -> Seed -> Tree (MaybeT m) a) -> GenT m a
[unGen] :: GenT m a -> Size -> Seed -> Tree (MaybeT m) a

-- | Class of monads which can generate input data for tests.
--   
--   <i>The functions on this class can, and should, be used without their
--   <tt>Gen</tt></i> <i>suffix by importing <a>Hedgehog.Gen</a>
--   qualified.</i>
class Monad m => MonadGen m

-- | See <tt>Gen.</tt><a>lift</a>
liftGen :: MonadGen m => Gen a -> m a

-- | See <tt>Gen.</tt><a>shrink</a>
shrinkGen :: MonadGen m => (a -> [a]) -> m a -> m a

-- | See <tt>Gen.</tt><a>prune</a>
pruneGen :: MonadGen m => m a -> m a

-- | See <tt>Gen.</tt><a>scale</a>
scaleGen :: MonadGen m => (Size -> Size) -> m a -> m a

-- | See <tt>Gen.</tt><a>freeze</a>
freezeGen :: MonadGen m => m a -> m (a, m a)

-- | Lift a vanilla <a>Gen</a> in to a <a>MonadGen</a>.
lift :: MonadGen m => Gen a -> m a

-- | Apply a shrinking function to a generator.
--   
--   This will give the generator additional shrinking options, while
--   keeping the existing shrinks intact.
shrink :: MonadGen m => (a -> [a]) -> m a -> m a

-- | Throw away a generator's shrink tree.
prune :: MonadGen m => m a -> m a

-- | Make a generator smaller by scaling its size parameter.
small :: MonadGen m => m a -> m a

-- | Adjust the size parameter by transforming it with the given function.
scale :: MonadGen m => (Size -> Size) -> m a -> m a

-- | Override the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: MonadGen m => Size -> m a -> m a

-- | Construct a generator that depends on the size parameter.
sized :: MonadGen m => (Size -> m a) -> m a

-- | Generates a random integral number in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   When the generator tries to shrink, it will shrink towards the
--   <a>origin</a> of the specified <a>Range</a>.
--   
--   For example, the following generator will produce a number between
--   <tt>1970</tt> and <tt>2100</tt>, but will shrink towards
--   <tt>2000</tt>:
--   
--   <pre>
--   integral (Range.<a>constantFrom</a> 2000 1970 2100) :: <a>Gen</a> <a>Int</a>
--   </pre>
--   
--   Some sample outputs from this generator might look like:
--   
--   <pre>
--   === Outcome ===
--   1973
--   === Shrinks ===
--   2000
--   1987
--   1980
--   1976
--   1974
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   2061
--   === Shrinks ===
--   2000
--   2031
--   2046
--   2054
--   2058
--   2060
--   </pre>
integral :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random integral number in the [inclusive,inclusive] range.
--   
--   <i>This generator does not shrink.</i>
integral_ :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random machine integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int :: MonadGen m => Range Int -> m Int

-- | Generates a random 8-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int8 :: MonadGen m => Range Int8 -> m Int8

-- | Generates a random 16-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int16 :: MonadGen m => Range Int16 -> m Int16

-- | Generates a random 32-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int32 :: MonadGen m => Range Int32 -> m Int32

-- | Generates a random 64-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int64 :: MonadGen m => Range Int64 -> m Int64

-- | Generates a random machine word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word :: MonadGen m => Range Word -> m Word

-- | Generates a random byte in the given <tt>[inclusive,inclusive]</tt>
--   range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word8 :: MonadGen m => Range Word8 -> m Word8

-- | Generates a random 16-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word16 :: MonadGen m => Range Word16 -> m Word16

-- | Generates a random 32-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word32 :: MonadGen m => Range Word32 -> m Word32

-- | Generates a random 64-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word64 :: MonadGen m => Range Word64 -> m Word64

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   This generator works the same as <a>integral</a>, but for floating
--   point numbers.
realFloat :: (MonadGen m, RealFloat a) => Range a -> m a

-- | Generates a random fractional number in the [inclusive,exclusive)
--   range.
--   
--   <i>This generator does not shrink.</i>
realFrac_ :: (MonadGen m, RealFrac a) => Range a -> m a

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
float :: MonadGen m => Range Float -> m Float

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
double :: MonadGen m => Range Double -> m Double

-- | Generates an element from an enumeration.
--   
--   This generator shrinks towards the first argument.
--   
--   For example:
--   
--   <pre>
--   enum 'a' 'z' :: <a>Gen</a> <a>Char</a>
--   </pre>
enum :: (MonadGen m, Enum a) => a -> a -> m a

-- | Generates a random value from a bounded enumeration.
--   
--   This generator shrinks towards <a>minBound</a>.
--   
--   For example:
--   
--   <pre>
--   enumBounded :: <a>Gen</a> <a>Bool</a>
--   </pre>
enumBounded :: (MonadGen m, Enum a, Bounded a) => m a

-- | Generates a random boolean.
--   
--   This generator shrinks to <a>False</a>.
--   
--   <i>This is a specialization of <a>enumBounded</a>, offered for
--   convenience.</i>
bool :: MonadGen m => m Bool

-- | Generates a random boolean.
--   
--   <i>This generator does not shrink.</i>
bool_ :: MonadGen m => m Bool

-- | Generates an ASCII binit: <tt>'0'..'1'</tt>
binit :: MonadGen m => m Char

-- | Generates an ASCII octit: <tt>'0'..'7'</tt>
octit :: MonadGen m => m Char

-- | Generates an ASCII digit: <tt>'0'..'9'</tt>
digit :: MonadGen m => m Char

-- | Generates an ASCII hexit: <tt>'0'..'9', 'a'..'f', 'A'..'F'</tt>
hexit :: MonadGen m => m Char

-- | Generates an ASCII lowercase letter: <tt>'a'..'z'</tt>
lower :: MonadGen m => m Char

-- | Generates an ASCII uppercase letter: <tt>'A'..'Z'</tt>
upper :: MonadGen m => m Char

-- | Generates an ASCII letter: <tt>'a'..'z', 'A'..'Z'</tt>
alpha :: MonadGen m => m Char

-- | Generates an ASCII letter or digit: <tt>'a'..'z', 'A'..'Z',
--   '0'..'9'</tt>
alphaNum :: MonadGen m => m Char

-- | Generates an ASCII character: <tt>'\0'..'\127'</tt>
ascii :: MonadGen m => m Char

-- | Generates a Latin-1 character: <tt>'\0'..'\255'</tt>
latin1 :: MonadGen m => m Char

-- | Generates a Unicode character, excluding noncharacters and invalid
--   standalone surrogates: <tt>'\0'..'\1114111' (excluding
--   '\55296'..'\57343')</tt>
unicode :: MonadGen m => m Char

-- | Generates a Unicode character, including noncharacters and invalid
--   standalone surrogates: <tt>'\0'..'\1114111'</tt>
unicodeAll :: MonadGen m => m Char

-- | Generates a string using <a>Range</a> to determine the length.
--   
--   <i>This is a specialization of <a>list</a>, offered for
--   convenience.</i>
string :: MonadGen m => Range Int -> m Char -> m String

-- | Generates a string using <a>Range</a> to determine the length.
text :: MonadGen m => Range Int -> m Char -> m Text

-- | Generates a UTF-8 encoded string, using <a>Range</a> to determine the
--   length.
utf8 :: MonadGen m => Range Int -> m Char -> m ByteString

-- | Generates a random <a>ByteString</a>, using <a>Range</a> to determine
--   the length.
bytes :: MonadGen m => Range Int -> m ByteString

-- | Trivial generator that always produces the same element.
--   
--   <i>This is another name for <a>pure</a> / <a>return</a>.</i>
constant :: MonadGen m => a -> m a

-- | Randomly selects one of the elements in the list.
--   
--   This generator shrinks towards the first element in the list.
--   
--   <i>The input list must be non-empty.</i>
element :: MonadGen m => [a] -> m a

-- | Randomly selects one of the generators in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
choice :: MonadGen m => [m a] -> m a

-- | Uses a weighted distribution to randomly select one of the generators
--   in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
frequency :: MonadGen m => [(Int, m a)] -> m a

-- | Modifies combinators which choose from a list of generators, like
--   <a>choice</a> or <a>frequency</a>, so that they can be used in
--   recursive scenarios.
--   
--   This combinator modifies its target to select one of the generators in
--   either the non-recursive or the recursive list. When a selection is
--   made from the recursive list, the <a>Size</a> is halved. When the
--   <a>Size</a> gets to one or less, selections are no longer made from
--   the recursive list, this ensures termination.
--   
--   A good example of where this might be useful is abstract syntax trees:
--   
--   <pre>
--   data Expr =
--       Var String
--     | Lam String Expr
--     | App Expr Expr
--   
--   -- Assuming we have a name generator
--   genName :: <a>MonadGen</a> m =&gt; m String
--   
--   -- We can write a generator for expressions
--   genExpr :: <a>MonadGen</a> m =&gt; m Expr
--   genExpr =
--     Gen.<a>recursive</a> Gen.<a>choice</a> [
--         -- non-recursive generators
--         Var <a>&lt;$&gt;</a> genName
--       ] [
--         -- recursive generators
--         Gen.<a>subtermM</a> genExpr (x -&gt; Lam <a>&lt;$&gt;</a> genName <a>&lt;*&gt;</a> pure x)
--       , Gen.<a>subterm2</a> genExpr genExpr App
--       ]
--   </pre>
--   
--   If we wrote the above example using only <a>choice</a>, it is likely
--   that it would fail to terminate. This is because for every call to
--   <tt>genExpr</tt>, there is a 2 in 3 chance that we will recurse again.
recursive :: MonadGen m => ([m a] -> m a) -> [m a] -> [m a] -> m a

-- | Discards the whole generator.
discard :: MonadGen m => m a

-- | Discards the generator if the generated value does not satisfy the
--   predicate.
ensure :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Generates a value that satisfies a predicate.
--   
--   This is essentially:
--   
--   <pre>
--   filter p gen = <tt>mfilter</tt> p gen <a>&lt;|&gt;</a> filter p gen
--   </pre>
--   
--   It differs from the above in that we keep some state to avoid looping
--   forever. If we trigger these limits then the whole generator is
--   discarded.
filter :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   This is implemented using <a>filter</a> and has the same caveats.
just :: MonadGen m => m (Maybe a) -> m a

-- | Generates a <a>Nothing</a> some of the time.
maybe :: MonadGen m => m a -> m (Maybe a)

-- | Generates a list using a <a>Range</a> to determine the length.
list :: MonadGen m => Range Int -> m a -> m [a]

-- | Generates a seq using a <a>Range</a> to determine the length.
seq :: MonadGen m => Range Int -> m a -> m (Seq a)

-- | Generates a non-empty list using a <a>Range</a> to determine the
--   length.
nonEmpty :: MonadGen m => Range Int -> m a -> m (NonEmpty a)

-- | Generates a set using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the element generator</i>
--   <i>cannot produce a large enough number of unique items to satify</i>
--   <i>the required set size.</i>
set :: (MonadGen m, Ord a) => Range Int -> m a -> m (Set a)

-- | Generates a map using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the keys produced by the</i>
--   <i>generator do not account for a large enough number of unique</i>
--   <i>items to satify the required map size.</i>
map :: (MonadGen m, Ord k) => Range Int -> m (k, v) -> m (Map k v)

-- | Freeze the size and seed used by a generator, so we can inspect the
--   value which it will produce.
--   
--   This is used for implementing <a>list</a> and <a>subtermMVec</a>. It
--   allows us to shrink the list itself before trying to shrink the values
--   inside the list.
freeze :: MonadGen m => m a -> m (a, m a)

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subterm :: MonadGen m => m a -> (a -> a) -> m a

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subtermM :: MonadGen m => m a -> (a -> m a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm2 :: MonadGen m => m a -> m a -> (a -> a -> a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM2 :: MonadGen m => m a -> m a -> (a -> a -> m a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> m a) -> m a

-- | Generates a random subsequence of a list.
subsequence :: MonadGen m => [a] -> m [a]

-- | Generates a random permutation of a list.
--   
--   This shrinks towards the order of the list being identical to the
--   input list.
shuffle :: MonadGen m => [a] -> m [a]

-- | Generate a sample from a generator.
sample :: MonadIO m => Gen a -> m a

-- | Run a generator with a random seed and print the outcome, and the
--   first level of shrinks.
--   
--   <pre>
--   Gen.print (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   'd'
--   === Shrinks ===
--   'a'
--   'b'
--   'c'
--   </pre>
print :: (MonadIO m, Show a) => Gen a -> m ()

-- | Run a generator with a random seed and print the resulting shrink
--   tree.
--   
--   <pre>
--   Gen.printTree (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   'd'
--    ├╼'a'
--    ├╼'b'
--    │  └╼'a'
--    └╼'c'
--       ├╼'a'
--       └╼'b'
--          └╼'a'
--   </pre>
--   
--   <i>This may not terminate when the tree is very large.</i>
printTree :: (MonadIO m, Show a) => Gen a -> m ()

-- | Print the value produced by a generator, and the first level of
--   shrinks, for the given size and seed.
--   
--   Use <a>print</a> to generate a value from a random seed.
printWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Print the shrink tree produced by a generator, for the given size and
--   seed.
--   
--   Use <a>printTree</a> to generate a value from a random seed.
printTreeWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Runs a generator, producing its shrink tree.
runGenT :: Size -> Seed -> GenT m a -> Tree (MaybeT m) a

-- | Map over a generator's shrink tree.
mapGenT :: (Tree (MaybeT m) a -> Tree (MaybeT n) b) -> GenT m a -> GenT n b

-- | Generate a value with no shrinks from a <a>Size</a> and a <a>Seed</a>.
generate :: MonadGen m => (Size -> Seed -> a) -> m a

-- | Lift a predefined shrink tree in to a generator, ignoring the seed and
--   the size.
liftTree :: Tree (MaybeT m) a -> GenT m a

-- | Run the discard effects through the tree and reify them as
--   <a>Maybe</a> values at the nodes. <a>Nothing</a> means discarded,
--   <a>Just</a> means we have a value.
runDiscardEffect :: Monad m => Tree (MaybeT m) a -> Tree m (Maybe a)

-- | Scale a size using the golden ratio.
--   
--   <pre>
--   golden x = x / φ
--   golden x = x / 1.61803..
--   </pre>
golden :: Size -> Size

-- | Check that list contains at least a certain number of elements.
atLeast :: Int -> [a] -> Bool

-- | Check if a character is in the surrogate category.
isSurrogate :: Char -> Bool

-- | Check if a character is one of the noncharacters '\65534', '\65535'.
isNoncharacter :: Char -> Bool
data Vec n a
[Nil] :: Vec  'Z a
[:.] :: a -> Vec n a -> Vec ( 'S n) a
infixr 5 :.
data Nat
Z :: Nat
S :: Nat -> Nat

-- | Constructs a generator from a number of sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermMVec :: MonadGen m => Vec n (m a) -> (Vec n a -> m a) -> m a

-- | Render a generator as a tree of strings.
renderNodes :: (Monad m, Show a) => Size -> Seed -> Gen a -> Tree m String
instance Data.Traversable.Traversable (Hedgehog.Internal.Gen.Subterms n)
instance Data.Foldable.Foldable (Hedgehog.Internal.Gen.Subterms n)
instance GHC.Base.Functor (Hedgehog.Internal.Gen.Subterms n)
instance GHC.Base.Functor (Hedgehog.Internal.Gen.Vec n)
instance Data.Foldable.Foldable (Hedgehog.Internal.Gen.Vec n)
instance Data.Traversable.Traversable (Hedgehog.Internal.Gen.Vec n)
instance GHC.Base.Monad m => Hedgehog.Internal.Gen.MonadGen (Hedgehog.Internal.Gen.GenT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Identity.IdentityT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Maybe.MaybeT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Except.ExceptT x m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Reader.ReaderT r m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.State.Lazy.StateT s m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.State.Strict.StateT s m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Hedgehog.Internal.Gen.GenT m a)
instance (GHC.Base.Monad m, GHC.Base.Monoid a) => GHC.Base.Monoid (Hedgehog.Internal.Gen.GenT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Gen.GenT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Gen.GenT
instance Control.Monad.Morph.MMonad Hedgehog.Internal.Gen.GenT
instance Hedgehog.Internal.Distributive.Distributive Hedgehog.Internal.Gen.GenT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Gen.GenT m)

module Hedgehog.Internal.Property

-- | A property test, along with some configurable limits like how many
--   times to run the test.
data Property
Property :: !PropertyConfig -> PropertyT IO () -> Property
[propertyConfig] :: Property -> !PropertyConfig
[propertyTest] :: Property -> PropertyT IO ()

-- | The property monad transformer allows both the generation of test
--   inputs and the assertion of expectations.
newtype PropertyT m a
PropertyT :: TestT (GenT m) a -> PropertyT m a
[unPropertyT] :: PropertyT m a -> TestT (GenT m) a

-- | The name of a property.
--   
--   Can be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: PropertyName
--   </pre>
newtype PropertyName
PropertyName :: String -> PropertyName
[unPropertyName] :: PropertyName -> String

-- | Configuration for a property test.
data PropertyConfig
PropertyConfig :: !TestLimit -> !DiscardLimit -> !ShrinkLimit -> !ShrinkRetries -> PropertyConfig
[propertyTestLimit] :: PropertyConfig -> !TestLimit
[propertyDiscardLimit] :: PropertyConfig -> !DiscardLimit
[propertyShrinkLimit] :: PropertyConfig -> !ShrinkLimit
[propertyShrinkRetries] :: PropertyConfig -> !ShrinkRetries

-- | The number of successful tests that need to be run before a property
--   test is considered successful.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   200 :: TestLimit
--   </pre>
newtype TestLimit
TestLimit :: Int -> TestLimit

-- | The number of discards to allow before giving up.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   10000 :: DiscardLimit
--   </pre>
newtype DiscardLimit
DiscardLimit :: Int -> DiscardLimit

-- | The number of shrinks to try before giving up on shrinking.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   1000 :: ShrinkLimit
--   </pre>
newtype ShrinkLimit
ShrinkLimit :: Int -> ShrinkLimit

-- | The number of times to re-run a test during shrinking. This is useful
--   if you are testing something which fails non-deterministically and you
--   want to increase the change of getting a good shrink.
--   
--   If you are doing parallel state machine testing, you should probably
--   set shrink retries to something like <tt>10</tt>. This will mean that
--   during shrinking, a parallel test case requires 10 successful runs
--   before it is passes and we try a different shrink.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   0 :: ShrinkRetries
--   </pre>
newtype ShrinkRetries
ShrinkRetries :: Int -> ShrinkRetries

-- | Set the number of times a property should be executed before it is
--   considered successful.
--   
--   If you have a test that does not involve any generators and thus does
--   not need to run repeatedly, you can use <tt>withTests 1</tt> to define
--   a property that will only be checked once.
withTests :: TestLimit -> Property -> Property

-- | Set the number of times a property is allowed to discard before the
--   test runner gives up.
withDiscards :: DiscardLimit -> Property -> Property

-- | Set the number of times a property is allowed to shrink before the
--   test runner gives up and prints the counterexample.
withShrinks :: ShrinkLimit -> Property -> Property

-- | Set the number of times a property will be executed for each shrink
--   before the test runner gives up and tries a different shrink. See
--   <a>ShrinkRetries</a> for more information.
withRetries :: ShrinkRetries -> Property -> Property

-- | Creates a property with the default configuration.
property :: HasCallStack => PropertyT IO () -> Property

-- | Lift a test in to a property.
--   
--   Because both <a>TestT</a> and <a>PropertyT</a> have <a>MonadTest</a>
--   instances, this function is not often required. It can however be
--   useful for writing functions directly in <a>TestT</a> and thus gaining
--   a <a>MonadTransControl</a> instance at the expense of not being able
--   to generate additional inputs using <a>forAll</a>.
--   
--   One use case for this is writing tests which use <a>ResourceT</a>:
--   
--   <pre>
--   property $ do
--     n &lt;- forAll $ Gen.int64 Range.linearBounded
--     test . runResourceT $ do
--       -- test with resource usage here
--   </pre>
test :: Monad m => TestT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAll :: (Monad m, Show a, HasCallStack) => Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAllT :: (Monad m, Show a, HasCallStack) => GenT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAll</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWith :: (Monad m, HasCallStack) => (a -> String) -> Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAllT</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWithT :: (Monad m, HasCallStack) => (a -> String) -> GenT m a -> PropertyT m a

-- | Discards the current test entirely.
discard :: Monad m => PropertyT m a

-- | A named collection of property tests.
data Group
Group :: !GroupName -> ![(PropertyName, Property)] -> Group
[groupName] :: Group -> !GroupName
[groupProperties] :: Group -> ![(PropertyName, Property)]

-- | The name of a group of properties.
--   
--   Can be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "fruit" :: GroupName
--   </pre>
newtype GroupName
GroupName :: String -> GroupName
[unGroupName] :: GroupName -> String
class Monad m => MonadTest m
liftTest :: MonadTest m => Test a -> m a

-- | A test monad allows the assertion of expectations.
type Test = TestT Identity

-- | A test monad transformer allows the assertion of expectations.
newtype TestT m a
TestT :: ExceptT Failure (WriterT [Log] m) a -> TestT m a
[unTest] :: TestT m a -> ExceptT Failure (WriterT [Log] m) a

-- | Log messages which are recorded during a test run.
data Log
Annotation :: Maybe Span -> String -> Log
Footnote :: String -> Log

-- | Details on where and why a test failed.
data Failure
Failure :: Maybe Span -> String -> Maybe Diff -> Failure

-- | The difference between some expected and actual value.
data Diff
Diff :: String -> String -> String -> String -> String -> ValueDiff -> Diff
[diffPrefix] :: Diff -> String
[diffRemoved] :: Diff -> String
[diffInfix] :: Diff -> String
[diffAdded] :: Diff -> String
[diffSuffix] :: Diff -> String
[diffValue] :: Diff -> ValueDiff

-- | Annotates the source code with a message that might be useful for
--   debugging a test failure.
annotate :: (MonadTest m, HasCallStack) => String -> m ()

-- | Annotates the source code with a value that might be useful for
--   debugging a test failure.
annotateShow :: (MonadTest m, Show a, HasCallStack) => a -> m ()

-- | Logs a message to be displayed as additional information in the footer
--   of the failure report.
footnote :: MonadTest m => String -> m ()

-- | Logs a value to be displayed as additional information in the footer
--   of the failure report.
footnoteShow :: (MonadTest m, Show a) => a -> m ()

-- | Causes a test to fail.
failure :: (MonadTest m, HasCallStack) => m a

-- | Another name for <tt>pure ()</tt>.
success :: MonadTest m => m ()

-- | Fails the test if the condition provided is <a>False</a>.
assert :: (MonadTest m, HasCallStack) => Bool -> m ()

-- | Fails the test if the two arguments provided are not equal.
(===) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 ===

-- | Fails the test if the two arguments provided are equal.
(/==) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 /==

-- | Fails the test if the value throws an exception when evaluated to weak
--   head normal form (WHNF).
eval :: (MonadTest m, HasCallStack) => a -> m a

-- | Fails the test if the action throws an exception.
--   
--   <i>The benefit of using this over simply letting the exception bubble
--   up is</i> <i>that the location of the closest <a>evalM</a> will be
--   shown in the output.</i>
evalM :: (MonadTest m, MonadCatch m, HasCallStack) => m a -> m a

-- | Fails the test if the <a>IO</a> action throws an exception.
--   
--   <i>The benefit of using this over <a>liftIO</a> is that the location
--   of the</i> <i>exception will be shown in the output.</i>
evalIO :: (MonadTest m, MonadIO m, HasCallStack) => IO a -> m a

-- | Fails the test if the <a>Either</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalEither :: (MonadTest m, Show x, HasCallStack) => Either x a -> m a

-- | Fails the test if the <a>ExceptT</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalExceptT :: (MonadTest m, Show x, HasCallStack) => ExceptT x m a -> m a

-- | The default configuration for a property test.
defaultConfig :: PropertyConfig

-- | Map a config modification function over a property.
mapConfig :: (PropertyConfig -> PropertyConfig) -> Property -> Property

-- | Fails with an error which shows the difference between two values.
failDiff :: (MonadTest m, Show a, Show b, HasCallStack) => a -> b -> m ()

-- | Fails with an error which renders the type of an exception and its
--   error message.
failException :: (MonadTest m, HasCallStack) => SomeException -> m a

-- | Fail the test with an error message, useful for building other failure
--   combinators.
failWith :: (MonadTest m, HasCallStack) => Maybe Diff -> String -> m a

-- | Log some information which might be relevant to a potential test
--   failure.
writeLog :: MonadTest m => Log -> m ()
mkTest :: (Either Failure a, [Log]) -> Test a
mkTestT :: m (Either Failure a, [Log]) -> TestT m a
runTest :: Test a -> (Either Failure a, [Log])
runTestT :: TestT m a -> m (Either Failure a, [Log])
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.ShrinkRetries
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.ShrinkLimit
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.DiscardLimit
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.TestLimit
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.PropertyConfig
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.PropertyName
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.GroupName
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Property.TestT m)
instance GHC.Show.Show Hedgehog.Internal.Property.Failure
instance GHC.Classes.Eq Hedgehog.Internal.Property.Failure
instance GHC.Show.Show Hedgehog.Internal.Property.Diff
instance GHC.Classes.Eq Hedgehog.Internal.Property.Diff
instance GHC.Show.Show Hedgehog.Internal.Property.Log
instance GHC.Classes.Eq Hedgehog.Internal.Property.Log
instance GHC.Base.Semigroup Hedgehog.Internal.Property.GroupName
instance Data.String.IsString Hedgehog.Internal.Property.GroupName
instance GHC.Show.Show Hedgehog.Internal.Property.GroupName
instance GHC.Classes.Ord Hedgehog.Internal.Property.GroupName
instance GHC.Classes.Eq Hedgehog.Internal.Property.GroupName
instance GHC.Show.Show Hedgehog.Internal.Property.PropertyConfig
instance GHC.Classes.Ord Hedgehog.Internal.Property.PropertyConfig
instance GHC.Classes.Eq Hedgehog.Internal.Property.PropertyConfig
instance GHC.Real.Integral Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Real.Real Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Enum.Enum Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Num.Num Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Real.Integral Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Real.Real Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Num.Num Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.DiscardLimit
instance GHC.Real.Real Hedgehog.Internal.Property.DiscardLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.DiscardLimit
instance GHC.Num.Num Hedgehog.Internal.Property.DiscardLimit
instance GHC.Show.Show Hedgehog.Internal.Property.DiscardLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.DiscardLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.DiscardLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.TestLimit
instance GHC.Real.Real Hedgehog.Internal.Property.TestLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.TestLimit
instance GHC.Num.Num Hedgehog.Internal.Property.TestLimit
instance GHC.Show.Show Hedgehog.Internal.Property.TestLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.TestLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.TestLimit
instance GHC.Base.Semigroup Hedgehog.Internal.Property.PropertyName
instance Data.String.IsString Hedgehog.Internal.Property.PropertyName
instance GHC.Show.Show Hedgehog.Internal.Property.PropertyName
instance GHC.Classes.Ord Hedgehog.Internal.Property.PropertyName
instance GHC.Classes.Eq Hedgehog.Internal.Property.PropertyName
instance GHC.Base.Monad m => Hedgehog.Internal.Property.MonadTest (Hedgehog.Internal.Property.TestT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Identity.IdentityT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Maybe.MaybeT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Except.ExceptT x m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Reader.ReaderT r m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.State.Lazy.StateT s m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.State.Strict.StateT s m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Cont.ContT r m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.Monad m => Hedgehog.Internal.Property.MonadTest (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Property.PropertyT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Property.PropertyT
instance Hedgehog.Internal.Distributive.Distributive Hedgehog.Internal.Property.PropertyT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Property.TestT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Property.TestT
instance Hedgehog.Internal.Distributive.Distributive Hedgehog.Internal.Property.TestT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Control.MonadTransControl Hedgehog.Internal.Property.TestT
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hedgehog.Internal.Property.TestT m)

module Hedgehog.Internal.Tripping

-- | Test that a pair of encode / decode functions are compatible.
tripping :: (MonadTest m, Applicative f, Show b, Show (f a), Eq (f a), HasCallStack) => a -> (a -> b) -> (b -> f a) -> m ()

module Hedgehog.Internal.State

-- | Variables are the potential or actual result of executing an action.
--   They are parameterised by either <a>Symbolic</a> or <a>Concrete</a>
--   depending on the phase of the test.
--   
--   <a>Symbolic</a> variables are the potential results of actions. These
--   are used when generating the sequence of actions to execute. They
--   allow actions which occur later in the sequence to make use of the
--   result of an action which came earlier in the sequence.
--   
--   <a>Concrete</a> variables are the actual results of actions. These are
--   used during test execution. They provide access to the actual runtime
--   value of a variable.
--   
--   The state update <a>Callback</a> for a command needs to be polymorphic
--   in the type of variable because it is used in both the generation and
--   the execution phase.
data Var a v
Var :: v a -> Var a v

-- | Take the value from a concrete variable.
concrete :: Var a Concrete -> a

-- | Take the value from an opaque concrete variable.
opaque :: Var (Opaque a) Concrete -> a

-- | Concrete values.
newtype Concrete a
[Concrete] :: a -> Concrete a

-- | Symbolic values.
data Symbolic a
[Symbolic] :: Typeable a => Name -> Symbolic a

-- | Symbolic variable names.
newtype Name
Name :: Int -> Name

-- | A mapping of symbolic values to concrete values.
newtype Environment
Environment :: Map Name Dynamic -> Environment
[unEnvironment] :: Environment -> Map Name Dynamic

-- | Environment errors.
data EnvironmentError
EnvironmentValueNotFound :: !Name -> EnvironmentError
EnvironmentTypeError :: !TypeRep -> !TypeRep -> EnvironmentError

-- | Create an empty environment.
emptyEnvironment :: Environment

-- | Insert a symbolic / concrete pairing in to the environment.
insertConcrete :: Symbolic a -> Concrete a -> Environment -> Environment

-- | Cast a <a>Dynamic</a> in to a concrete value.
reifyDynamic :: forall a. Typeable a => Dynamic -> Either EnvironmentError (Concrete a)

-- | Turns an environment in to a function for looking up a concrete value
--   from a symbolic one.
reifyEnvironment :: Environment -> forall a. Symbolic a -> Either EnvironmentError (Concrete a)

-- | Convert a symbolic structure to a concrete one, using the provided
--   environment.
reify :: HTraversable t => Environment -> t Symbolic -> Either EnvironmentError (t Concrete)

-- | The specification for the expected behaviour of an <a>Action</a>.
data Command n m (state :: (* -> *) -> *)
Command :: (state Symbolic -> Maybe (n (input Symbolic))) -> (input Concrete -> m output) -> [Callback input output state] -> Command n m

-- | A generator which provides random arguments for a command. If the
--   command cannot be executed in the current state, it should return
--   <a>Nothing</a>.
[commandGen] :: Command n m -> state Symbolic -> Maybe (n (input Symbolic))

-- | Executes a command using the arguments generated by <a>commandGen</a>.
[commandExecute] :: Command n m -> input Concrete -> m output

-- | A set of callbacks which provide optional command configuration such
--   as pre-condtions, post-conditions and state updates.
[commandCallbacks] :: Command n m -> [Callback input output state]

-- | Optional command configuration.
data Callback input output state

-- | A pre-condition for a command that must be verified before the command
--   can be executed. This is mainly used during shrinking to ensure that
--   it is still OK to run a command despite the fact that some previously
--   executed commands may have been removed from the sequence.
Require :: (state Symbolic -> input Symbolic -> Bool) -> Callback input output state

-- | Updates the model state, given the input and output of the command.
--   Note that this function is polymorphic in the type of values. This is
--   because it must work over <a>Symbolic</a> values when we are
--   generating actions, and <a>Concrete</a> values when we are executing
--   them.
Update :: (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> Callback input output state

-- | A post-condition for a command that must be verified for the command
--   to be considered a success.
--   
--   This callback receives the state prior to execution as the first
--   argument, and the state after execution as the second argument.
Ensure :: (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Callback input output state

-- | Checks that input for a command can be executed in the given state.
commandGenOK :: Command n m state -> state Symbolic -> Bool

-- | An instantiation of a <a>Command</a> which can be executed, and its
--   effect evaluated.
data Action m (state :: (* -> *) -> *)
Action :: input Symbolic -> Symbolic output -> (input Concrete -> m output) -> (state Symbolic -> input Symbolic -> Bool) -> (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Action m
[actionInput] :: Action m -> input Symbolic
[actionOutput] :: Action m -> Symbolic output
[actionExecute] :: Action m -> input Concrete -> m output
[actionRequire] :: Action m -> state Symbolic -> input Symbolic -> Bool
[actionUpdate] :: Action m -> forall v. Ord1 v => state v -> input v -> Var output v -> state v
[actionEnsure] :: Action m -> state Concrete -> state Concrete -> input Concrete -> output -> Test ()

-- | A sequence of actions to execute.
data Sequential m state
Sequential :: [Action m state] -> Sequential m state

-- | The sequence of actions.
[sequentialActions] :: Sequential m state -> [Action m state]

-- | A sequential prefix of actions to execute, with two branches to
--   execute in parallel.
data Parallel m state
Parallel :: [Action m state] -> [Action m state] -> [Action m state] -> Parallel m state

-- | The sequential prefix.
[parallelPrefix] :: Parallel m state -> [Action m state]

-- | The first branch.
[parallelBranch1] :: Parallel m state -> [Action m state]

-- | The second branch.
[parallelBranch2] :: Parallel m state -> [Action m state]

-- | Collects all the symbolic values in a data structure and produces a
--   set of all the variables they refer to.
takeVariables :: forall t. HTraversable t => t Symbolic -> Map Name TypeRep

-- | Checks that the symbolic values in the data structure refer only to
--   the variables in the provided set, and that they are of the correct
--   type.
variablesOK :: HTraversable t => t Symbolic -> Map Name TypeRep -> Bool

-- | Drops invalid actions from the sequence.
dropInvalid :: [Action m state] -> State (Context state) [Action m state]

-- | Generates a single action from a set of possible commands.
action :: (MonadGen n, MonadTest m) => [Command n m state] -> StateT (Context state) n (Action m state)

-- | Generates a sequence of actions from an initial model state and set of
--   commands.
sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- | Given the initial model state and set of commands, generates prefix
--   actions to be run sequentially, followed by two branches to be run in
--   parallel.
parallel :: (MonadGen n, MonadTest m) => Range Int -> Range Int -> (forall v. state v) -> [Command n m state] -> n (Parallel m state)

-- | Executes a list of actions sequentially, verifying that all
--   post-conditions are met and no exceptions are thrown.
--   
--   To generate a sequence of actions to execute, see the
--   <a>sequential</a> combinator in the <a>Hedgehog.Gen</a> module.
executeSequential :: (MonadTest m, MonadCatch m, HasCallStack) => (forall v. state v) -> Sequential m state -> m ()

-- | Executes the prefix actions sequentially, then executes the two
--   branches in parallel, verifying that no exceptions are thrown and that
--   there is at least one sequential interleaving where all the
--   post-conditions are met.
--   
--   To generate parallel actions to execute, see the <a>parallel</a>
--   combinator in the <a>Hedgehog.Gen</a> module.
executeParallel :: (MonadTest m, MonadCatch m, MonadBaseControl IO m, HasCallStack) => (forall v. state v) -> Parallel m state -> m ()
instance GHC.Show.Show Hedgehog.Internal.State.EnvironmentError
instance GHC.Classes.Ord Hedgehog.Internal.State.EnvironmentError
instance GHC.Classes.Eq Hedgehog.Internal.State.EnvironmentError
instance GHC.Show.Show Hedgehog.Internal.State.Environment
instance Data.Traversable.Traversable Hedgehog.Internal.State.Concrete
instance Data.Foldable.Foldable Hedgehog.Internal.State.Concrete
instance GHC.Base.Functor Hedgehog.Internal.State.Concrete
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.State.Concrete a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.State.Concrete a)
instance GHC.Num.Num Hedgehog.Internal.State.Name
instance GHC.Classes.Ord Hedgehog.Internal.State.Name
instance GHC.Classes.Eq Hedgehog.Internal.State.Name
instance GHC.Classes.Eq (Hedgehog.Internal.State.Symbolic a)
instance GHC.Classes.Ord (Hedgehog.Internal.State.Symbolic a)
instance GHC.Show.Show (Hedgehog.Internal.State.Parallel m state)
instance GHC.Show.Show (Hedgehog.Internal.State.Sequential m state)
instance GHC.Show.Show (Hedgehog.Internal.State.Action m state)
instance (GHC.Classes.Eq a, Data.Functor.Classes.Eq1 v) => GHC.Classes.Eq (Hedgehog.Internal.State.Var a v)
instance (GHC.Classes.Ord a, Data.Functor.Classes.Ord1 v) => GHC.Classes.Ord (Hedgehog.Internal.State.Var a v)
instance (GHC.Show.Show a, Data.Functor.Classes.Show1 v) => GHC.Show.Show (Hedgehog.Internal.State.Var a v)
instance Hedgehog.Internal.HTraversable.HTraversable (Hedgehog.Internal.State.Var a)
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.State.Concrete a)
instance Data.Functor.Classes.Show1 Hedgehog.Internal.State.Concrete
instance Data.Functor.Classes.Eq1 Hedgehog.Internal.State.Concrete
instance Data.Functor.Classes.Ord1 Hedgehog.Internal.State.Concrete
instance GHC.Show.Show (Hedgehog.Internal.State.Symbolic a)
instance Data.Functor.Classes.Show1 Hedgehog.Internal.State.Symbolic
instance Data.Functor.Classes.Eq1 Hedgehog.Internal.State.Symbolic
instance Data.Functor.Classes.Ord1 Hedgehog.Internal.State.Symbolic
instance GHC.Show.Show Hedgehog.Internal.State.Name

module Hedgehog.Internal.Discovery
newtype PropertySource
PropertySource :: Pos String -> PropertySource
[propertySource] :: PropertySource -> Pos String
readProperties :: MonadIO m => FilePath -> m (Map PropertyName PropertySource)
findProperties :: FilePath -> String -> Map PropertyName PropertySource
readDeclaration :: MonadIO m => FilePath -> LineNo -> m (Maybe (String, Pos String))
data Pos a
Pos :: !Position -> a -> Pos a
[posPostion] :: Pos a -> !Position
[posValue] :: Pos a -> a
data Position
Position :: !FilePath -> !LineNo -> !ColumnNo -> Position
[_posPath] :: Position -> !FilePath
[posLine] :: Position -> !LineNo
[posColumn] :: Position -> !ColumnNo
instance GHC.Show.Show Hedgehog.Internal.Discovery.PropertySource
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.PropertySource
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.PropertySource
instance GHC.Base.Functor Hedgehog.Internal.Discovery.Pos
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Show.Show Hedgehog.Internal.Discovery.Position
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.Position
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.Position
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Show.Show Hedgehog.Internal.Discovery.Class
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.Class
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.Class
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Hedgehog.Internal.Discovery.Pos a)

module Hedgehog.Internal.TH
type TExpQ a = Q (TExp a)

-- | Discover all the properties in a module.
--   
--   Functions starting with <tt>prop_</tt> are assumed to be properties.
discover :: TExpQ Group

module Hedgehog.Internal.Report

-- | A summary of all the properties executed.
data Summary
Summary :: !PropertyCount -> !PropertyCount -> !PropertyCount -> !PropertyCount -> !PropertyCount -> Summary
[summaryWaiting] :: Summary -> !PropertyCount
[summaryRunning] :: Summary -> !PropertyCount
[summaryFailed] :: Summary -> !PropertyCount
[summaryGaveUp] :: Summary -> !PropertyCount
[summaryOK] :: Summary -> !PropertyCount

-- | A report on a running or completed property test.
data Report a
Report :: !TestCount -> !DiscardCount -> !a -> Report a
[reportTests] :: Report a -> !TestCount
[reportDiscards] :: Report a -> !DiscardCount
[reportStatus] :: Report a -> !a

-- | The status of a running property test.
data Progress
Running :: Progress
Shrinking :: !FailureReport -> Progress

-- | The status of a completed property test.
--   
--   In the case of a failure it provides the seed used for the test, the
--   number of shrinks, and the execution log.
data Result
Failed :: !FailureReport -> Result
GaveUp :: Result
OK :: Result
data FailureReport
FailureReport :: !Size -> !Seed -> !ShrinkCount -> ![FailedAnnotation] -> !Maybe Span -> !String -> !Maybe Diff -> ![String] -> FailureReport
[failureSize] :: FailureReport -> !Size
[failureSeed] :: FailureReport -> !Seed
[failureShrinks] :: FailureReport -> !ShrinkCount
[failureAnnotations] :: FailureReport -> ![FailedAnnotation]
[failureLocation] :: FailureReport -> !Maybe Span
[failureMessage] :: FailureReport -> !String
[failureDiff] :: FailureReport -> !Maybe Diff
[failureFootnotes] :: FailureReport -> ![String]
data FailedAnnotation
FailedAnnotation :: !Maybe Span -> !String -> FailedAnnotation
[failedSpan] :: FailedAnnotation -> !Maybe Span
[failedValue] :: FailedAnnotation -> !String

-- | The numbers of times a property was able to shrink after a failing
--   test.
newtype ShrinkCount
ShrinkCount :: Int -> ShrinkCount

-- | The number of tests a property ran successfully.
newtype TestCount
TestCount :: Int -> TestCount

-- | The number of tests a property had to discard.
newtype DiscardCount
DiscardCount :: Int -> DiscardCount

-- | The number of properties in a group.
newtype PropertyCount
PropertyCount :: Int -> PropertyCount
data Style
StyleDefault :: Style
StyleAnnotation :: Style
StyleFailure :: Style
data Markup
WaitingIcon :: Markup
WaitingHeader :: Markup
RunningIcon :: Markup
RunningHeader :: Markup
ShrinkingIcon :: Markup
ShrinkingHeader :: Markup
FailedIcon :: Markup
FailedHeader :: Markup
GaveUpIcon :: Markup
GaveUpHeader :: Markup
SuccessIcon :: Markup
SuccessHeader :: Markup
DeclarationLocation :: Markup
StyledLineNo :: !Style -> Markup
StyledBorder :: !Style -> Markup
StyledSource :: !Style -> Markup
AnnotationGutter :: Markup
AnnotationValue :: Markup
FailureArrows :: Markup
FailureGutter :: Markup
FailureMessage :: Markup
DiffPrefix :: Markup
DiffInfix :: Markup
DiffSuffix :: Markup
DiffSame :: Markup
DiffRemoved :: Markup
DiffAdded :: Markup
ReproduceHeader :: Markup
ReproduceGutter :: Markup
ReproduceSource :: Markup
renderProgress :: MonadIO m => Maybe UseColor -> Maybe PropertyName -> Report Progress -> m String
renderResult :: MonadIO m => Maybe UseColor -> Maybe PropertyName -> Report Result -> m String
renderSummary :: MonadIO m => Maybe UseColor -> Summary -> m String
renderDoc :: MonadIO m => Maybe UseColor -> Doc Markup -> m String
ppProgress :: MonadIO m => Maybe PropertyName -> Report Progress -> m (Doc Markup)
ppResult :: MonadIO m => Maybe PropertyName -> Report Result -> m (Doc Markup)
ppSummary :: MonadIO m => Summary -> m (Doc Markup)

-- | Construct a summary from a single result.
fromResult :: Result -> Summary
mkFailure :: Size -> Seed -> ShrinkCount -> Maybe Span -> String -> Maybe Diff -> [Log] -> FailureReport
instance GHC.Show.Show Hedgehog.Internal.Report.Markup
instance GHC.Classes.Ord Hedgehog.Internal.Report.Markup
instance GHC.Classes.Eq Hedgehog.Internal.Report.Markup
instance GHC.Show.Show Hedgehog.Internal.Report.Style
instance GHC.Classes.Ord Hedgehog.Internal.Report.Style
instance GHC.Classes.Eq Hedgehog.Internal.Report.Style
instance GHC.Base.Functor Hedgehog.Internal.Report.Declaration
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Declaration a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Report.Declaration a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Report.Declaration a)
instance GHC.Base.Functor Hedgehog.Internal.Report.Line
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Line a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Report.Line a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Report.Line a)
instance GHC.Show.Show Hedgehog.Internal.Report.Summary
instance Data.Traversable.Traversable Hedgehog.Internal.Report.Report
instance Data.Foldable.Foldable Hedgehog.Internal.Report.Report
instance GHC.Base.Functor Hedgehog.Internal.Report.Report
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Report a)
instance GHC.Show.Show Hedgehog.Internal.Report.Result
instance GHC.Classes.Eq Hedgehog.Internal.Report.Result
instance GHC.Show.Show Hedgehog.Internal.Report.Progress
instance GHC.Classes.Eq Hedgehog.Internal.Report.Progress
instance GHC.Show.Show Hedgehog.Internal.Report.FailureReport
instance GHC.Classes.Eq Hedgehog.Internal.Report.FailureReport
instance GHC.Show.Show Hedgehog.Internal.Report.FailedAnnotation
instance GHC.Classes.Eq Hedgehog.Internal.Report.FailedAnnotation
instance GHC.Real.Integral Hedgehog.Internal.Report.PropertyCount
instance GHC.Real.Real Hedgehog.Internal.Report.PropertyCount
instance GHC.Enum.Enum Hedgehog.Internal.Report.PropertyCount
instance GHC.Num.Num Hedgehog.Internal.Report.PropertyCount
instance GHC.Show.Show Hedgehog.Internal.Report.PropertyCount
instance GHC.Classes.Ord Hedgehog.Internal.Report.PropertyCount
instance GHC.Classes.Eq Hedgehog.Internal.Report.PropertyCount
instance GHC.Real.Integral Hedgehog.Internal.Report.DiscardCount
instance GHC.Real.Real Hedgehog.Internal.Report.DiscardCount
instance GHC.Enum.Enum Hedgehog.Internal.Report.DiscardCount
instance GHC.Num.Num Hedgehog.Internal.Report.DiscardCount
instance GHC.Show.Show Hedgehog.Internal.Report.DiscardCount
instance GHC.Classes.Ord Hedgehog.Internal.Report.DiscardCount
instance GHC.Classes.Eq Hedgehog.Internal.Report.DiscardCount
instance GHC.Real.Integral Hedgehog.Internal.Report.TestCount
instance GHC.Real.Real Hedgehog.Internal.Report.TestCount
instance GHC.Enum.Enum Hedgehog.Internal.Report.TestCount
instance GHC.Num.Num Hedgehog.Internal.Report.TestCount
instance GHC.Show.Show Hedgehog.Internal.Report.TestCount
instance GHC.Classes.Ord Hedgehog.Internal.Report.TestCount
instance GHC.Classes.Eq Hedgehog.Internal.Report.TestCount
instance GHC.Real.Integral Hedgehog.Internal.Report.ShrinkCount
instance GHC.Real.Real Hedgehog.Internal.Report.ShrinkCount
instance GHC.Enum.Enum Hedgehog.Internal.Report.ShrinkCount
instance GHC.Num.Num Hedgehog.Internal.Report.ShrinkCount
instance GHC.Show.Show Hedgehog.Internal.Report.ShrinkCount
instance GHC.Classes.Ord Hedgehog.Internal.Report.ShrinkCount
instance GHC.Classes.Eq Hedgehog.Internal.Report.ShrinkCount
instance GHC.Base.Semigroup Hedgehog.Internal.Report.Style
instance GHC.Base.Monoid Hedgehog.Internal.Report.Summary
instance GHC.Base.Semigroup Hedgehog.Internal.Report.Summary

module Hedgehog.Internal.Runner

-- | Check a property.
check :: MonadIO m => Property -> m Bool

-- | Check a property using a specific size and seed.
recheck :: MonadIO m => Size -> Seed -> Property -> m ()

-- | Configuration for a property test run.
data RunnerConfig
RunnerConfig :: !Maybe WorkerCount -> !Maybe UseColor -> !Maybe Verbosity -> RunnerConfig

-- | The number of property tests to run concurrently. <a>Nothing</a> means
--   use one worker per processor.
[runnerWorkers] :: RunnerConfig -> !Maybe WorkerCount

-- | Whether to use colored output or not. <a>Nothing</a> means detect from
--   the environment.
[runnerColor] :: RunnerConfig -> !Maybe UseColor

-- | How verbose to be in the runner output. <a>Nothing</a> means detect
--   from the environment.
[runnerVerbosity] :: RunnerConfig -> !Maybe Verbosity

-- | Check a group of properties in parallel.
--   
--   <i>Warning: although this check function runs tests faster than</i>
--   <i><a>checkSequential</a>, it should be noted that it may cause
--   problems with</i> <i>properties that are not self-contained. For
--   example, if you have a group</i> <i>of tests which all use the same
--   database table, you may find that they</i> <i>interfere with each
--   other when being run in parallel.</i>
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkParallel :: MonadIO m => Group -> m Bool

-- | Check a group of properties sequentially.
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkSequential :: MonadIO m => Group -> m Bool

-- | Check a group of properties using the specified runner config.
checkGroup :: MonadIO m => RunnerConfig -> Group -> m Bool
checkReport :: forall m. MonadIO m => MonadCatch m => PropertyConfig -> Size -> Seed -> PropertyT m () -> (Report Progress -> m ()) -> m (Report Result)
checkRegion :: MonadIO m => Region -> Maybe UseColor -> Maybe PropertyName -> Size -> Seed -> Property -> m (Report Result)
checkNamed :: MonadIO m => Region -> Maybe UseColor -> Maybe PropertyName -> Property -> m (Report Result)
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Show.Show Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Classes.Ord Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Classes.Eq Hedgehog.Internal.Runner.RunnerConfig

module Hedgehog.Gen

-- | Lift a vanilla <a>Gen</a> in to a <a>MonadGen</a>.
lift :: MonadGen m => Gen a -> m a

-- | Apply a shrinking function to a generator.
--   
--   This will give the generator additional shrinking options, while
--   keeping the existing shrinks intact.
shrink :: MonadGen m => (a -> [a]) -> m a -> m a

-- | Throw away a generator's shrink tree.
prune :: MonadGen m => m a -> m a

-- | Make a generator smaller by scaling its size parameter.
small :: MonadGen m => m a -> m a

-- | Adjust the size parameter by transforming it with the given function.
scale :: MonadGen m => (Size -> Size) -> m a -> m a

-- | Override the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: MonadGen m => Size -> m a -> m a

-- | Construct a generator that depends on the size parameter.
sized :: MonadGen m => (Size -> m a) -> m a

-- | Generates a random integral number in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   When the generator tries to shrink, it will shrink towards the
--   <a>origin</a> of the specified <a>Range</a>.
--   
--   For example, the following generator will produce a number between
--   <tt>1970</tt> and <tt>2100</tt>, but will shrink towards
--   <tt>2000</tt>:
--   
--   <pre>
--   integral (Range.<a>constantFrom</a> 2000 1970 2100) :: <a>Gen</a> <a>Int</a>
--   </pre>
--   
--   Some sample outputs from this generator might look like:
--   
--   <pre>
--   === Outcome ===
--   1973
--   === Shrinks ===
--   2000
--   1987
--   1980
--   1976
--   1974
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   2061
--   === Shrinks ===
--   2000
--   2031
--   2046
--   2054
--   2058
--   2060
--   </pre>
integral :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random integral number in the [inclusive,inclusive] range.
--   
--   <i>This generator does not shrink.</i>
integral_ :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random machine integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int :: MonadGen m => Range Int -> m Int

-- | Generates a random 8-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int8 :: MonadGen m => Range Int8 -> m Int8

-- | Generates a random 16-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int16 :: MonadGen m => Range Int16 -> m Int16

-- | Generates a random 32-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int32 :: MonadGen m => Range Int32 -> m Int32

-- | Generates a random 64-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int64 :: MonadGen m => Range Int64 -> m Int64

-- | Generates a random machine word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word :: MonadGen m => Range Word -> m Word

-- | Generates a random byte in the given <tt>[inclusive,inclusive]</tt>
--   range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word8 :: MonadGen m => Range Word8 -> m Word8

-- | Generates a random 16-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word16 :: MonadGen m => Range Word16 -> m Word16

-- | Generates a random 32-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word32 :: MonadGen m => Range Word32 -> m Word32

-- | Generates a random 64-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word64 :: MonadGen m => Range Word64 -> m Word64

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   This generator works the same as <a>integral</a>, but for floating
--   point numbers.
realFloat :: (MonadGen m, RealFloat a) => Range a -> m a

-- | Generates a random fractional number in the [inclusive,exclusive)
--   range.
--   
--   <i>This generator does not shrink.</i>
realFrac_ :: (MonadGen m, RealFrac a) => Range a -> m a

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
float :: MonadGen m => Range Float -> m Float

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
double :: MonadGen m => Range Double -> m Double

-- | Generates an element from an enumeration.
--   
--   This generator shrinks towards the first argument.
--   
--   For example:
--   
--   <pre>
--   enum 'a' 'z' :: <a>Gen</a> <a>Char</a>
--   </pre>
enum :: (MonadGen m, Enum a) => a -> a -> m a

-- | Generates a random value from a bounded enumeration.
--   
--   This generator shrinks towards <a>minBound</a>.
--   
--   For example:
--   
--   <pre>
--   enumBounded :: <a>Gen</a> <a>Bool</a>
--   </pre>
enumBounded :: (MonadGen m, Enum a, Bounded a) => m a

-- | Generates a random boolean.
--   
--   This generator shrinks to <a>False</a>.
--   
--   <i>This is a specialization of <a>enumBounded</a>, offered for
--   convenience.</i>
bool :: MonadGen m => m Bool

-- | Generates a random boolean.
--   
--   <i>This generator does not shrink.</i>
bool_ :: MonadGen m => m Bool

-- | Generates an ASCII binit: <tt>'0'..'1'</tt>
binit :: MonadGen m => m Char

-- | Generates an ASCII octit: <tt>'0'..'7'</tt>
octit :: MonadGen m => m Char

-- | Generates an ASCII digit: <tt>'0'..'9'</tt>
digit :: MonadGen m => m Char

-- | Generates an ASCII hexit: <tt>'0'..'9', 'a'..'f', 'A'..'F'</tt>
hexit :: MonadGen m => m Char

-- | Generates an ASCII lowercase letter: <tt>'a'..'z'</tt>
lower :: MonadGen m => m Char

-- | Generates an ASCII uppercase letter: <tt>'A'..'Z'</tt>
upper :: MonadGen m => m Char

-- | Generates an ASCII letter: <tt>'a'..'z', 'A'..'Z'</tt>
alpha :: MonadGen m => m Char

-- | Generates an ASCII letter or digit: <tt>'a'..'z', 'A'..'Z',
--   '0'..'9'</tt>
alphaNum :: MonadGen m => m Char

-- | Generates an ASCII character: <tt>'\0'..'\127'</tt>
ascii :: MonadGen m => m Char

-- | Generates a Latin-1 character: <tt>'\0'..'\255'</tt>
latin1 :: MonadGen m => m Char

-- | Generates a Unicode character, excluding noncharacters and invalid
--   standalone surrogates: <tt>'\0'..'\1114111' (excluding
--   '\55296'..'\57343')</tt>
unicode :: MonadGen m => m Char

-- | Generates a Unicode character, including noncharacters and invalid
--   standalone surrogates: <tt>'\0'..'\1114111'</tt>
unicodeAll :: MonadGen m => m Char

-- | Generates a string using <a>Range</a> to determine the length.
--   
--   <i>This is a specialization of <a>list</a>, offered for
--   convenience.</i>
string :: MonadGen m => Range Int -> m Char -> m String

-- | Generates a string using <a>Range</a> to determine the length.
text :: MonadGen m => Range Int -> m Char -> m Text

-- | Generates a UTF-8 encoded string, using <a>Range</a> to determine the
--   length.
utf8 :: MonadGen m => Range Int -> m Char -> m ByteString

-- | Generates a random <a>ByteString</a>, using <a>Range</a> to determine
--   the length.
bytes :: MonadGen m => Range Int -> m ByteString

-- | Trivial generator that always produces the same element.
--   
--   <i>This is another name for <a>pure</a> / <a>return</a>.</i>
constant :: MonadGen m => a -> m a

-- | Randomly selects one of the elements in the list.
--   
--   This generator shrinks towards the first element in the list.
--   
--   <i>The input list must be non-empty.</i>
element :: MonadGen m => [a] -> m a

-- | Randomly selects one of the generators in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
choice :: MonadGen m => [m a] -> m a

-- | Uses a weighted distribution to randomly select one of the generators
--   in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
frequency :: MonadGen m => [(Int, m a)] -> m a

-- | Modifies combinators which choose from a list of generators, like
--   <a>choice</a> or <a>frequency</a>, so that they can be used in
--   recursive scenarios.
--   
--   This combinator modifies its target to select one of the generators in
--   either the non-recursive or the recursive list. When a selection is
--   made from the recursive list, the <a>Size</a> is halved. When the
--   <a>Size</a> gets to one or less, selections are no longer made from
--   the recursive list, this ensures termination.
--   
--   A good example of where this might be useful is abstract syntax trees:
--   
--   <pre>
--   data Expr =
--       Var String
--     | Lam String Expr
--     | App Expr Expr
--   
--   -- Assuming we have a name generator
--   genName :: <a>MonadGen</a> m =&gt; m String
--   
--   -- We can write a generator for expressions
--   genExpr :: <a>MonadGen</a> m =&gt; m Expr
--   genExpr =
--     Gen.<a>recursive</a> Gen.<a>choice</a> [
--         -- non-recursive generators
--         Var <a>&lt;$&gt;</a> genName
--       ] [
--         -- recursive generators
--         Gen.<a>subtermM</a> genExpr (x -&gt; Lam <a>&lt;$&gt;</a> genName <a>&lt;*&gt;</a> pure x)
--       , Gen.<a>subterm2</a> genExpr genExpr App
--       ]
--   </pre>
--   
--   If we wrote the above example using only <a>choice</a>, it is likely
--   that it would fail to terminate. This is because for every call to
--   <tt>genExpr</tt>, there is a 2 in 3 chance that we will recurse again.
recursive :: MonadGen m => ([m a] -> m a) -> [m a] -> [m a] -> m a

-- | Discards the whole generator.
discard :: MonadGen m => m a

-- | Generates a value that satisfies a predicate.
--   
--   This is essentially:
--   
--   <pre>
--   filter p gen = <tt>mfilter</tt> p gen <a>&lt;|&gt;</a> filter p gen
--   </pre>
--   
--   It differs from the above in that we keep some state to avoid looping
--   forever. If we trigger these limits then the whole generator is
--   discarded.
filter :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   This is implemented using <a>filter</a> and has the same caveats.
just :: MonadGen m => m (Maybe a) -> m a

-- | Generates a <a>Nothing</a> some of the time.
maybe :: MonadGen m => m a -> m (Maybe a)

-- | Generates a list using a <a>Range</a> to determine the length.
list :: MonadGen m => Range Int -> m a -> m [a]

-- | Generates a seq using a <a>Range</a> to determine the length.
seq :: MonadGen m => Range Int -> m a -> m (Seq a)

-- | Generates a non-empty list using a <a>Range</a> to determine the
--   length.
nonEmpty :: MonadGen m => Range Int -> m a -> m (NonEmpty a)

-- | Generates a set using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the element generator</i>
--   <i>cannot produce a large enough number of unique items to satify</i>
--   <i>the required set size.</i>
set :: (MonadGen m, Ord a) => Range Int -> m a -> m (Set a)

-- | Generates a map using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the keys produced by the</i>
--   <i>generator do not account for a large enough number of unique</i>
--   <i>items to satify the required map size.</i>
map :: (MonadGen m, Ord k) => Range Int -> m (k, v) -> m (Map k v)

-- | Freeze the size and seed used by a generator, so we can inspect the
--   value which it will produce.
--   
--   This is used for implementing <a>list</a> and <a>subtermMVec</a>. It
--   allows us to shrink the list itself before trying to shrink the values
--   inside the list.
freeze :: MonadGen m => m a -> m (a, m a)

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subterm :: MonadGen m => m a -> (a -> a) -> m a

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subtermM :: MonadGen m => m a -> (a -> m a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm2 :: MonadGen m => m a -> m a -> (a -> a -> a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM2 :: MonadGen m => m a -> m a -> (a -> a -> m a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> m a) -> m a

-- | Generates a random subsequence of a list.
subsequence :: MonadGen m => [a] -> m [a]

-- | Generates a random permutation of a list.
--   
--   This shrinks towards the order of the list being identical to the
--   input list.
shuffle :: MonadGen m => [a] -> m [a]

-- | Generates a sequence of actions from an initial model state and set of
--   commands.
sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- | Given the initial model state and set of commands, generates prefix
--   actions to be run sequentially, followed by two branches to be run in
--   parallel.
parallel :: (MonadGen n, MonadTest m) => Range Int -> Range Int -> (forall v. state v) -> [Command n m state] -> n (Parallel m state)

-- | Generate a sample from a generator.
sample :: MonadIO m => Gen a -> m a

-- | Run a generator with a random seed and print the outcome, and the
--   first level of shrinks.
--   
--   <pre>
--   Gen.print (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   'd'
--   === Shrinks ===
--   'a'
--   'b'
--   'c'
--   </pre>
print :: (MonadIO m, Show a) => Gen a -> m ()

-- | Run a generator with a random seed and print the resulting shrink
--   tree.
--   
--   <pre>
--   Gen.printTree (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   'd'
--    ├╼'a'
--    ├╼'b'
--    │  └╼'a'
--    └╼'c'
--       ├╼'a'
--       └╼'b'
--          └╼'a'
--   </pre>
--   
--   <i>This may not terminate when the tree is very large.</i>
printTree :: (MonadIO m, Show a) => Gen a -> m ()

-- | Print the value produced by a generator, and the first level of
--   shrinks, for the given size and seed.
--   
--   Use <a>print</a> to generate a value from a random seed.
printWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Print the shrink tree produced by a generator, for the given size and
--   seed.
--   
--   Use <a>printTree</a> to generate a value from a random seed.
printTreeWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()


-- | This module includes almost everything you need to get started writing
--   property tests with Hedgehog.
--   
--   It is designed to be used alongside <a>Hedgehog.Gen</a> and
--   <a>Hedgehog.Range</a>, which should be imported qualified. You also
--   need to enable Template Haskell so the Hedgehog test runner can find
--   your properties.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   import           Hedgehog
--   import qualified Hedgehog.Gen as Gen
--   import qualified Hedgehog.Range as Range
--   </pre>
--   
--   Once you have your imports set up, you can write a simple property:
--   
--   <pre>
--   prop_reverse :: Property
--   prop_reverse =
--     property $ do
--       xs &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha
--       reverse (reverse xs) === xs
--   </pre>
--   
--   And add the Template Haskell splice which will discover your
--   properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   If you prefer to avoid macros, you can specify the group of properties
--   to run manually instead:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
--   
--   You can then load the module in GHCi, and run it:
--   
--   <pre>
--   λ tests
--   ━━━ Test.Example ━━━
--     ✓ prop_reverse passed 100 tests.
--   </pre>
module Hedgehog

-- | A property test, along with some configurable limits like how many
--   times to run the test.
data Property

-- | The property monad transformer allows both the generation of test
--   inputs and the assertion of expectations.
data PropertyT m a

-- | A named collection of property tests.
data Group
Group :: !GroupName -> ![(PropertyName, Property)] -> Group
[groupName] :: Group -> !GroupName
[groupProperties] :: Group -> ![(PropertyName, Property)]

-- | The name of a property.
--   
--   Can be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: PropertyName
--   </pre>
data PropertyName

-- | The name of a group of properties.
--   
--   Can be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "fruit" :: GroupName
--   </pre>
data GroupName

-- | Creates a property with the default configuration.
property :: HasCallStack => PropertyT IO () -> Property

-- | Lift a test in to a property.
--   
--   Because both <a>TestT</a> and <a>PropertyT</a> have <a>MonadTest</a>
--   instances, this function is not often required. It can however be
--   useful for writing functions directly in <a>TestT</a> and thus gaining
--   a <a>MonadTransControl</a> instance at the expense of not being able
--   to generate additional inputs using <a>forAll</a>.
--   
--   One use case for this is writing tests which use <a>ResourceT</a>:
--   
--   <pre>
--   property $ do
--     n &lt;- forAll $ Gen.int64 Range.linearBounded
--     test . runResourceT $ do
--       -- test with resource usage here
--   </pre>
test :: Monad m => TestT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAll :: (Monad m, Show a, HasCallStack) => Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAll</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWith :: (Monad m, HasCallStack) => (a -> String) -> Gen a -> PropertyT m a

-- | Discards the current test entirely.
discard :: Monad m => PropertyT m a

-- | Check a property.
check :: MonadIO m => Property -> m Bool

-- | Check a property using a specific size and seed.
recheck :: MonadIO m => Size -> Seed -> Property -> m ()

-- | Discover all the properties in a module.
--   
--   Functions starting with <tt>prop_</tt> are assumed to be properties.
discover :: TExpQ Group

-- | Check a group of properties in parallel.
--   
--   <i>Warning: although this check function runs tests faster than</i>
--   <i><a>checkSequential</a>, it should be noted that it may cause
--   problems with</i> <i>properties that are not self-contained. For
--   example, if you have a group</i> <i>of tests which all use the same
--   database table, you may find that they</i> <i>interfere with each
--   other when being run in parallel.</i>
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkParallel :: MonadIO m => Group -> m Bool

-- | Check a group of properties sequentially.
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkSequential :: MonadIO m => Group -> m Bool

-- | Set the number of times a property should be executed before it is
--   considered successful.
--   
--   If you have a test that does not involve any generators and thus does
--   not need to run repeatedly, you can use <tt>withTests 1</tt> to define
--   a property that will only be checked once.
withTests :: TestLimit -> Property -> Property

-- | The number of successful tests that need to be run before a property
--   test is considered successful.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   200 :: TestLimit
--   </pre>
data TestLimit

-- | Set the number of times a property is allowed to discard before the
--   test runner gives up.
withDiscards :: DiscardLimit -> Property -> Property

-- | The number of discards to allow before giving up.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   10000 :: DiscardLimit
--   </pre>
data DiscardLimit

-- | Set the number of times a property is allowed to shrink before the
--   test runner gives up and prints the counterexample.
withShrinks :: ShrinkLimit -> Property -> Property

-- | The number of shrinks to try before giving up on shrinking.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   1000 :: ShrinkLimit
--   </pre>
data ShrinkLimit

-- | Set the number of times a property will be executed for each shrink
--   before the test runner gives up and tries a different shrink. See
--   <a>ShrinkRetries</a> for more information.
withRetries :: ShrinkRetries -> Property -> Property

-- | The number of times to re-run a test during shrinking. This is useful
--   if you are testing something which fails non-deterministically and you
--   want to increase the change of getting a good shrink.
--   
--   If you are doing parallel state machine testing, you should probably
--   set shrink retries to something like <tt>10</tt>. This will mean that
--   during shrinking, a parallel test case requires 10 successful runs
--   before it is passes and we try a different shrink.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   0 :: ShrinkRetries
--   </pre>
data ShrinkRetries

-- | Generator for random values of <tt>a</tt>.
type Gen = GenT Identity

-- | Monad transformer which can generate random values of <tt>a</tt>.
data GenT m a

-- | Class of monads which can generate input data for tests.
--   
--   <i>The functions on this class can, and should, be used without their
--   <tt>Gen</tt></i> <i>suffix by importing <a>Hedgehog.Gen</a>
--   qualified.</i>
class Monad m => MonadGen m

-- | See <tt>Gen.</tt><a>lift</a>
liftGen :: MonadGen m => Gen a -> m a

-- | See <tt>Gen.</tt><a>shrink</a>
shrinkGen :: MonadGen m => (a -> [a]) -> m a -> m a

-- | See <tt>Gen.</tt><a>prune</a>
pruneGen :: MonadGen m => m a -> m a

-- | See <tt>Gen.</tt><a>scale</a>
scaleGen :: MonadGen m => (Size -> Size) -> m a -> m a

-- | See <tt>Gen.</tt><a>freeze</a>
freezeGen :: MonadGen m => m a -> m (a, m a)

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a

-- | Tests are parameterized by the size of the randomly-generated data,
--   the meaning of which depends on the particular generator used.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A splittable random number generator.
data Seed
Seed :: !Word64 -> !Word64 -> Seed
[seedValue] :: Seed -> !Word64

-- | must be an odd number
[seedGamma] :: Seed -> !Word64

-- | A test monad allows the assertion of expectations.
type Test = TestT Identity

-- | A test monad transformer allows the assertion of expectations.
data TestT m a
class Monad m => MonadTest m
liftTest :: MonadTest m => Test a -> m a

-- | Annotates the source code with a message that might be useful for
--   debugging a test failure.
annotate :: (MonadTest m, HasCallStack) => String -> m ()

-- | Annotates the source code with a value that might be useful for
--   debugging a test failure.
annotateShow :: (MonadTest m, Show a, HasCallStack) => a -> m ()

-- | Logs a message to be displayed as additional information in the footer
--   of the failure report.
footnote :: MonadTest m => String -> m ()

-- | Logs a value to be displayed as additional information in the footer
--   of the failure report.
footnoteShow :: (MonadTest m, Show a) => a -> m ()

-- | Another name for <tt>pure ()</tt>.
success :: MonadTest m => m ()

-- | Causes a test to fail.
failure :: (MonadTest m, HasCallStack) => m a

-- | Fails the test if the condition provided is <a>False</a>.
assert :: (MonadTest m, HasCallStack) => Bool -> m ()

-- | Fails the test if the two arguments provided are not equal.
(===) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 ===

-- | Fails the test if the two arguments provided are equal.
(/==) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 /==

-- | Test that a pair of encode / decode functions are compatible.
tripping :: (MonadTest m, Applicative f, Show b, Show (f a), Eq (f a), HasCallStack) => a -> (a -> b) -> (b -> f a) -> m ()

-- | Fails the test if the value throws an exception when evaluated to weak
--   head normal form (WHNF).
eval :: (MonadTest m, HasCallStack) => a -> m a

-- | Fails the test if the action throws an exception.
--   
--   <i>The benefit of using this over simply letting the exception bubble
--   up is</i> <i>that the location of the closest <a>evalM</a> will be
--   shown in the output.</i>
evalM :: (MonadTest m, MonadCatch m, HasCallStack) => m a -> m a

-- | Fails the test if the <a>IO</a> action throws an exception.
--   
--   <i>The benefit of using this over <a>liftIO</a> is that the location
--   of the</i> <i>exception will be shown in the output.</i>
evalIO :: (MonadTest m, MonadIO m, HasCallStack) => IO a -> m a

-- | Fails the test if the <a>Either</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalEither :: (MonadTest m, Show x, HasCallStack) => Either x a -> m a

-- | Fails the test if the <a>ExceptT</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalExceptT :: (MonadTest m, Show x, HasCallStack) => ExceptT x m a -> m a

-- | The specification for the expected behaviour of an <a>Action</a>.
data Command n m (state :: (* -> *) -> *)
Command :: (state Symbolic -> Maybe (n (input Symbolic))) -> (input Concrete -> m output) -> [Callback input output state] -> Command n m

-- | A generator which provides random arguments for a command. If the
--   command cannot be executed in the current state, it should return
--   <a>Nothing</a>.
[commandGen] :: Command n m -> state Symbolic -> Maybe (n (input Symbolic))

-- | Executes a command using the arguments generated by <a>commandGen</a>.
[commandExecute] :: Command n m -> input Concrete -> m output

-- | A set of callbacks which provide optional command configuration such
--   as pre-condtions, post-conditions and state updates.
[commandCallbacks] :: Command n m -> [Callback input output state]

-- | Optional command configuration.
data Callback input output state

-- | A pre-condition for a command that must be verified before the command
--   can be executed. This is mainly used during shrinking to ensure that
--   it is still OK to run a command despite the fact that some previously
--   executed commands may have been removed from the sequence.
Require :: (state Symbolic -> input Symbolic -> Bool) -> Callback input output state

-- | Updates the model state, given the input and output of the command.
--   Note that this function is polymorphic in the type of values. This is
--   because it must work over <a>Symbolic</a> values when we are
--   generating actions, and <a>Concrete</a> values when we are executing
--   them.
Update :: (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> Callback input output state

-- | A post-condition for a command that must be verified for the command
--   to be considered a success.
--   
--   This callback receives the state prior to execution as the first
--   argument, and the state after execution as the second argument.
Ensure :: (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Callback input output state

-- | An instantiation of a <a>Command</a> which can be executed, and its
--   effect evaluated.
data Action m (state :: (* -> *) -> *)

-- | A sequence of actions to execute.
data Sequential m state
Sequential :: [Action m state] -> Sequential m state

-- | The sequence of actions.
[sequentialActions] :: Sequential m state -> [Action m state]

-- | A sequential prefix of actions to execute, with two branches to
--   execute in parallel.
data Parallel m state
Parallel :: [Action m state] -> [Action m state] -> [Action m state] -> Parallel m state

-- | The sequential prefix.
[parallelPrefix] :: Parallel m state -> [Action m state]

-- | The first branch.
[parallelBranch1] :: Parallel m state -> [Action m state]

-- | The second branch.
[parallelBranch2] :: Parallel m state -> [Action m state]

-- | Executes a list of actions sequentially, verifying that all
--   post-conditions are met and no exceptions are thrown.
--   
--   To generate a sequence of actions to execute, see the
--   <a>sequential</a> combinator in the <a>Hedgehog.Gen</a> module.
executeSequential :: (MonadTest m, MonadCatch m, HasCallStack) => (forall v. state v) -> Sequential m state -> m ()

-- | Executes the prefix actions sequentially, then executes the two
--   branches in parallel, verifying that no exceptions are thrown and that
--   there is at least one sequential interleaving where all the
--   post-conditions are met.
--   
--   To generate parallel actions to execute, see the <a>parallel</a>
--   combinator in the <a>Hedgehog.Gen</a> module.
executeParallel :: (MonadTest m, MonadCatch m, MonadBaseControl IO m, HasCallStack) => (forall v. state v) -> Parallel m state -> m ()

-- | Variables are the potential or actual result of executing an action.
--   They are parameterised by either <a>Symbolic</a> or <a>Concrete</a>
--   depending on the phase of the test.
--   
--   <a>Symbolic</a> variables are the potential results of actions. These
--   are used when generating the sequence of actions to execute. They
--   allow actions which occur later in the sequence to make use of the
--   result of an action which came earlier in the sequence.
--   
--   <a>Concrete</a> variables are the actual results of actions. These are
--   used during test execution. They provide access to the actual runtime
--   value of a variable.
--   
--   The state update <a>Callback</a> for a command needs to be polymorphic
--   in the type of variable because it is used in both the generation and
--   the execution phase.
data Var a v
Var :: v a -> Var a v

-- | Take the value from a concrete variable.
concrete :: Var a Concrete -> a

-- | Take the value from an opaque concrete variable.
opaque :: Var (Opaque a) Concrete -> a

-- | Symbolic values.
data Symbolic a

-- | Concrete values.
newtype Concrete a
[Concrete] :: a -> Concrete a

-- | Opaque values.
--   
--   Useful if you want to put something without a <a>Show</a> instance
--   inside something which you'd like to be able to display.
--   
--   For example:
--   
--   <pre>
--   data State v =
--     State {
--         stateRefs :: [Var (Opaque (IORef Int)) v]
--       } deriving (Eq, Show)
--   </pre>
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a

-- | Distribute one monad transformer over another.
distribute :: (Distributive g, Transformer f g m) => g (f m) a -> f (g m) a

-- | Higher-order traversable functors.
--   
--   This is used internally to make symbolic variables concrete given an
--   <tt>Environment</tt>.
class HTraversable t
htraverse :: (HTraversable t, Applicative f) => (forall a. g a -> f (h a)) -> t g -> f (t h)

-- | Lifting of the <a>Eq</a> class to unary type constructors.
class Eq1 (f :: Type -> Type)

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
class Eq1 f => Ord1 (f :: Type -> Type)

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Show</a> class to unary type constructors.
class Show1 (f :: Type -> Type)

-- | Lift the standard <a>showsPrec</a> and <a>showList</a> functions
--   through the type constructor.
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS
