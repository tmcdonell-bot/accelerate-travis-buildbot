-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lifting linear vector spaces into Accelerate
--   
--   Lifting linear vector spaces into Accelerate
@package linear-accelerate
@version 0.7.0.0


-- | Involutive rings
module Data.Array.Accelerate.Linear.Conjugate

-- | An involutive ring
class Num a => Conjugate a

-- | Conjugate a value. This defaults to the trivial involution.
--   
--   <pre>
--   &gt;&gt;&gt; conjugate (1 :+ 2)
--   1.0 :+ (-2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conjugate 1
--   1
--   </pre>
conjugate :: Conjugate a => a -> a

-- | Requires and provides a default definition such that
--   
--   <pre>
--   <a>conjugate</a> = <a>id</a>
--   </pre>
class Conjugate a => TrivialConjugate a
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp Numeric.Half.Half)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat)
instance Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble)
instance (Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Classes.RealFloat.RealFloat a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)) => Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp Numeric.Half.Half)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat)
instance Linear.Conjugate.TrivialConjugate (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble)


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Epsilon

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Exp Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Exp Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Exp Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Exp Float)
--   True
--   </pre>
class Num a => Epsilon a

-- | Determine if a quantity is near zero.
nearZero :: Epsilon a => Exp a -> Exp Bool
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon GHC.Types.Float
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon GHC.Types.Double
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon Foreign.C.Types.CFloat
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon Foreign.C.Types.CDouble


module Data.Array.Accelerate.Linear.Type
type Box f a = (Unlift Exp (f (Exp a)), Plain (f (Exp a)) ~ f a)
type Box2 f g a = (Box f (g a), Box g a, Lift Exp (f (g (Exp a))), Plain (f (g (Exp a))) ~ f (g a))


-- | Operations on free vector spaces
module Data.Array.Accelerate.Linear.Vector

-- | A vector is an additive group with additional structure.
--   
--   TODO: Support both <a>Exp</a> and <a>Acc</a>
class Additive f => Additive f

-- | The zero vector
zero :: (Additive f, Elt (f a), Num a) => Exp (f a)

-- | Compute the sum of two vectors
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^+^ lift (V2 3 4 :: V2 Int)
--   V2 4 6
--   </pre>
(^+^) :: forall a. (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)

-- | Compute the difference between two vectors
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 4 5 :: V2 Int) ^-^ lift (V2 3 1 :: V2 Int)
--   V2 1 4
--   </pre>
(^-^) :: forall a. (Additive f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp (f a)

-- | Linearly interpolate between two vectors
lerp :: forall a. (Additive f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a) -> Exp (f a)
infixl 6 ^-^
infixl 6 ^+^

-- | Basis element
newtype E t
E :: (forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)) -> E t
[el] :: E t -> forall a. (Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | Compute the negation of a vector
--   
--   <pre>
--   &gt;&gt;&gt; test $ negated (lift (V2 2 4 :: V2 Int))
--   V2 (-2) (-4)
--   </pre>
negated :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp (f a)

-- | Compute the left scalar product
--   
--   <pre>
--   &gt;&gt;&gt; test $ 2 *^ lift (V2 3 4 :: V2 Int)
--   V2 6 8
--   </pre>
(*^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 7 *^

-- | Compute the right scalar product
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 3 4 :: V2 Int) ^* 2
--   V2 6 8
--   </pre>
(^*) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 7 ^*

-- | Compute division by a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 4 6 :: V2 Double) ^/ 2
--   V2 2.0 3.0
--   </pre>
(^/) :: forall f a. (Functor f, Fractional a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 7 ^/

-- | Compute division of a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; test $ 4 /^ lift (V2 2 4 :: V2 Double)
--   V2 2.0 1.0
--   </pre>
(/^) :: forall f a. (Functor f, Fractional a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 7 /^

-- | Addition with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; test $ 2 +^ lift (V2 3 4 :: V2 Int)
--   V2 5 6
--   </pre>
(+^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 6 +^

-- | Addition with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^+ 3
--   V2 4 5
--   </pre>
(^+) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 6 ^+

-- | Subtraction with a scalar on the left
--   
--   <pre>
--   &gt;&gt;&gt; test $ 2 -^ lift (V2 3 4 :: V2 Int)
--   V2 (-1) (-2)
--   </pre>
(-^) :: forall f a. (Functor f, Num a, Box f a) => Exp a -> Exp (f a) -> Exp (f a)
infixl 6 -^

-- | Subtraction with a scalar on the right
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^- 3
--   V2 (-2) (-1)
--   </pre>
(^-) :: forall f a. (Functor f, Num a, Box f a) => Exp (f a) -> Exp a -> Exp (f a)
infixl 6 ^-


-- | Free metric spaces
module Data.Array.Accelerate.Linear.Metric

-- | Free and sparse inner product/metric spaces.
class Metric f => Metric f

-- | Compute the inner product of two vectors or (equivalently) convert a
--   vector <tt>f a</tt> into a covector <tt>f a -&gt; a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; lift (V2 1 2 :: V2 Int) `dot` lift (V2 3 4 :: V2 Int)
--   11
--   </pre>
dot :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the squared norm. The name quadrance arises from Norman J.
--   Wildberger's rational trigonometry.
quadrance :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp a

-- | Compute the <a>quadrance</a> of the difference
qd :: forall a. (Metric f, Num a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the distance between two vectors in a metric space
distance :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a) -> Exp a

-- | Compute the norm of a vector in a metric space
norm :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp a

-- | Convert a non-zero vector to unit vector.
signorm :: forall a. (Metric f, Floating a, Box f a) => Exp (f a) -> Exp (f a)
type IsMetric f a = (Metric f, Box f a)

-- | Normalize a <a>Metric</a> functor to have unit <a>norm</a>. This
--   function does not change the functor if its <a>norm</a> is 0 or 1.
normalize :: (Elt (f a), Floating a, IsMetric f a, Epsilon a) => Exp (f a) -> Exp (f a)

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: forall f a. (Floating a, IsMetric f a) => Exp (f a) -> Exp (f a) -> Exp (f a)


-- | 1-D Vectors
module Data.Array.Accelerate.Linear.V1

-- | A 1-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V1 Int
--   V1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 + V1 3
--   V1 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 * V1 3
--   V1 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V1 2)
--   2
--   </pre>
newtype V1 a
V1 :: a -> V1 a
pattern V1_ :: Elt a => Exp a -> Exp (V1 a)

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
ex :: R1 t => E t
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V1.V1
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V1.V1
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V1.V1
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V1.V1 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.V1.V1 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.V1.V1 a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.V1.V1 a)
instance Data.Array.Accelerate.Classes.Bounded.Bounded a => GHC.Enum.Bounded (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V1.V1 a))
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon a => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.V1.V1 a)
instance Data.Array.Accelerate.Data.Functor.Functor Linear.V1.V1


-- | 2-D Vectors
module Data.Array.Accelerate.Linear.V2

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a
V2 :: !a -> !a -> V2 a
pattern V2_ :: Elt a => Exp a -> Exp a -> Exp (V2 a)

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^. _yx
--   V2 2 1
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
ex :: R1 t => E t
ey :: R2 t => E t

-- | the counter-clockwise perpendicular vector
--   
--   <pre>
--   &gt;&gt;&gt; test $ perp $ lift (V2 10 20 :: V2 Int)
--   V2 (-20) 10
--   </pre>
perp :: forall a. Num a => Exp (V2 a) -> Exp (V2 a)

-- | Unit vector with given phase angle (modulo 2*<a>pi</a>)
angle :: Floating a => Exp a -> Exp (V2 a)
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V2.V2
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V2.V2
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V2.V2
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V2.V2
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V2.V2 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.V2.V2 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.V2.V2 a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.V2.V2 a)
instance Data.Array.Accelerate.Classes.Bounded.Bounded a => GHC.Enum.Bounded (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V2.V2 a))
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon a => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.V2.V2 a)
instance Data.Array.Accelerate.Data.Functor.Functor Linear.V2.V2


-- | 3-D Vectors
module Data.Array.Accelerate.Linear.V3

-- | A 3-dimensional vector
data V3 a
V3 :: !a -> !a -> !a -> V3 a
pattern V3_ :: Elt a => Exp a -> Exp a -> Exp a -> Exp (V3 a)

-- | cross product
cross :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a)

-- | scalar triple product
triple :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a) -> Exp a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^. _yx
--   V2 2 1
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V3 1 2 3 :: V3 Int) ^. _z
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V3 1 2 3 :: V3 Int) &amp; _z .~ 42
--   V3 1 2 42
--   </pre>
_z :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
instance Data.Array.Accelerate.Linear.V3.R3 Linear.V3.V3
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V3.V3
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V3.V3
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V3.V3
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V3.V3
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V3.V3 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.V3.V3 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.V3.V3 a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.V3.V3 a)
instance Data.Array.Accelerate.Classes.Bounded.Bounded a => GHC.Enum.Bounded (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V3.V3 a))
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon a => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.V3.V3 a)
instance Data.Array.Accelerate.Data.Functor.Functor Linear.V3.V3


-- | 4-D Vectors
module Data.Array.Accelerate.Linear.V4

-- | A 4-dimensional vector.
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a
pattern V4_ :: Elt a => Exp a -> Exp a -> Exp a -> Exp a -> Exp (V4 a)

-- | Convert a 3-dimensional affine vector into a 4-dimensional homogeneous
--   vector.
vector :: forall a. Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert a 3-dimensional affine point into a 4-dimensional homogeneous
--   vector.
point :: forall a. Num a => Exp (V3 a) -> Exp (V4 a)

-- | Convert 4-dimensional projective coordinates to a 3-dimensional point.
--   This operation may be denoted, <tt>euclidean [x:y:z:w] = (x/w, y/w,
--   z/w)</tt> where the projective, homogenous, coordinate
--   <tt>[x:y:z:w]</tt> is one of many associated with a single point
--   <tt>(x/w, y/w, z/w)</tt>.
normalizePoint :: forall a. Fractional a => Exp (V4 a) -> Exp (V3 a)

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t => R1 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V1 2 :: V1 Int) &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: (R1 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class (R2 t, R1 t) => R2 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xy :: (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) ^. _yx
--   V2 2 1
--   </pre>
_yx :: forall t a. (R2 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (Although it may have more)
class (R3 t, R2 t) => R3 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V3 1 2 3 :: V3 Int) ^. _z
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V3 1 2 3 :: V3 Int) &amp; _z .~ 42
--   V3 1 2 42
--   </pre>
_z :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyz :: forall a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xzy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxz :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxy :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyx :: forall t a. (R3 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, and <a>_w</a>. (Although it may have more.)
class (R4 t, R3 t) => R4 t

-- | <pre>
--   &gt;&gt;&gt; test $ lift (V4 1 2 3 4 :: V4 Int) ^._w
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V4 1 2 3 4 :: V4 Int) &amp; _w .~ 42
--   V4 1 2 3 42
--   </pre>
_w :: forall a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp a)
_xyzw :: forall a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_yw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_zw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_wz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V2 a))
_xyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xwz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_yzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_ywz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_zwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_wzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V3 a))
_xywz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xzwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_xwzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxzw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yxwz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_yzwx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_ywzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxyw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zxwy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zyxw :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zywx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_zwyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxyz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wxzy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyxz :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wyzx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzxy :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
_wzyx :: forall t a. (R4 t, Elt a, Box t a) => Lens' (Exp (t a)) (Exp (V4 a))
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
ew :: R4 t => E t
instance Data.Array.Accelerate.Linear.V4.R4 Linear.V4.V4
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V4.V4
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V4.V4
instance Data.Array.Accelerate.Linear.V1.R1 Linear.V4.V4
instance Data.Array.Accelerate.Linear.V2.R2 Linear.V4.V4
instance Data.Array.Accelerate.Linear.V3.R3 Linear.V4.V4
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V4.V4 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.V4.V4 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.V4.V4 a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.V4.V4 a)
instance Data.Array.Accelerate.Classes.Bounded.Bounded a => GHC.Enum.Bounded (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.V4.V4 a))
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon a => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.V4.V4 a)
instance Data.Array.Accelerate.Data.Functor.Functor Linear.V4.V4


-- | 0-D Vectors
module Data.Array.Accelerate.Linear.V0

-- | A 0-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V0 Int
--   V0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V0 + V0
--   V0
--   </pre>
data V0 a
V0 :: V0 a
pattern V0_ :: Elt a => Exp (V0 a)
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.V0.V0
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.V0.V0
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.V0.V0 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.V0.V0 a)
instance Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)
instance Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a)) (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a))
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.V0.V0 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.V0.V0 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => GHC.Enum.Bounded (Data.Array.Accelerate.Smart.Exp (Linear.V0.V0 a))
instance Data.Array.Accelerate.Data.Functor.Functor Linear.V0.V0


-- | Quaternions
module Data.Array.Accelerate.Linear.Quaternion

-- | Quaternions
data Quaternion a
Quaternion :: !a -> {-# UNPACK #-} !V3 a -> Quaternion a
pattern Quaternion_ :: Elt a => Exp a -> Exp (V3 a) -> Exp (Quaternion a)

-- | Spherical linear interpolation between two quaternions
slerp :: RealFloat a => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp a -> Exp (Quaternion a)

-- | <a>asin</a> with a specified branch cut
asinq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | <a>acos</a> with a specified branch cut
acosq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | <a>atan</a> with a specified branch cut
atanq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | <a>asinh</a> with a specified branch cut
asinhq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | <a>acosh</a> with a specified branch cut
acoshq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | <a>atanh</a> with a specified branch cut
atanhq :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp (Quaternion a) -> Exp (Quaternion a)

-- | norm of the imaginary component
absi :: Floating a => Exp (Quaternion a) -> Exp a

-- | raise a <a>Quaternion</a> to a scalar power
pow :: (RealFloat a, Elt (Complex a)) => Exp (Quaternion a) -> Exp a -> Exp (Quaternion a)

-- | Apply a rotation to a vector
rotate :: forall a. (Conjugate (Exp a), RealFloat a) => Exp (Quaternion a) -> Exp (V3 a) -> Exp (V3 a)

-- | <tt><a>axisAngle</a> axis theta</tt> builds a <a>Quaternion</a>
--   representing a rotation of <tt>theta</tt> radians about <tt>axis</tt>.
axisAngle :: (Epsilon a, Floating a) => Exp (V3 a) -> Exp a -> Exp (Quaternion a)
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.Quaternion.Quaternion
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.Quaternion.Quaternion
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.Quaternion.Quaternion a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.Quaternion.Quaternion a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a)) (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.Quaternion.Quaternion a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.Quaternion.Quaternion a)
instance Data.Array.Accelerate.Classes.RealFloat.RealFloat a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a))
instance Data.Array.Accelerate.Classes.RealFloat.RealFloat a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a))
instance (Data.Array.Accelerate.Classes.RealFloat.RealFloat a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)) => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a))
instance (Data.Array.Accelerate.Classes.RealFloat.RealFloat a, Data.Array.Accelerate.Linear.Epsilon.Epsilon a) => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.Quaternion.Quaternion a)
instance (Data.Array.Accelerate.Classes.RealFloat.RealFloat a, Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp a)) => Linear.Conjugate.Conjugate (Data.Array.Accelerate.Smart.Exp (Linear.Quaternion.Quaternion a))
instance Data.Array.Accelerate.Data.Functor.Functor Linear.Quaternion.Quaternion


-- | Plücker coordinates for lines in 3d homogeneous space.
module Data.Array.Accelerate.Linear.Plucker

-- | Plücker coordinates for lines in a 3-dimensional space.
data Plucker a
Plucker :: !a -> !a -> !a -> !a -> !a -> !a -> Plucker a
pattern Plucker_ :: Elt a => Exp a -> Exp a -> Exp a -> Exp a -> Exp a -> Exp a -> Exp (Plucker a)

-- | Valid Plücker coordinates <tt>p</tt> will have <tt><a>squaredError</a>
--   p <a>==</a> 0</tt>
--   
--   That said, floating point makes a mockery of this claim, so you may
--   want to use <a>nearZero</a>.
squaredError :: forall a. Num a => Exp (Plucker a) -> Exp a

-- | Checks if the line is near-isotropic (isotropic vectors in this
--   quadratic space represent lines in real 3D space).
isotropic :: Epsilon a => Exp (Plucker a) -> Exp Bool

-- | This isn't the actual metric because this bilinear form gives rise to
--   an isotropic quadratic space.
(><) :: forall a. Num a => Exp (Plucker a) -> Exp (Plucker a) -> Exp a
infixl 5 ><

-- | Given a pair of points represented by homogeneous coordinates generate
--   Plücker coordinates for the line through them, directed from the
--   second towards the first.
plucker :: forall a. Num a => Exp (V4 a) -> Exp (V4 a) -> Exp (Plucker a)

-- | Given a pair of 3D points, generate Plücker coordinates for the line
--   through them, directed from the second towards the first.
plucker3D :: forall a. Num a => Exp (V3 a) -> Exp (V3 a) -> Exp (Plucker a)

-- | Describe how two lines pass each other.
data LinePass

-- | The lines are coplanar (parallel or intersecting).
Coplanar :: LinePass

-- | The lines pass each other clockwise (right-handed screw)
Clockwise :: LinePass

-- | The lines pass each other counterclockwise (left-handed screw).
Counterclockwise :: LinePass

-- | Checks if two lines are parallel.
parallel :: Epsilon a => Exp (Plucker a) -> Exp (Plucker a) -> Exp Bool

-- | Checks if two lines intersect (or nearly intersect).
intersects :: (Epsilon a, Ord a) => Exp (Plucker a) -> Exp (Plucker a) -> Exp Bool

-- | Check how two lines pass each other. <tt>passes l1 l2</tt> describes
--   <tt>l2</tt> when looking down <tt>l1</tt>.
passes :: (Epsilon a, Ord a) => Exp (Plucker a) -> Exp (Plucker a) -> Exp LinePass

-- | The minimum squared distance of a line from the origin.
quadranceToOrigin :: Fractional a => Exp (Plucker a) -> Exp a

-- | The point where a line is closest to the origin.
closestToOrigin :: Fractional a => Exp (Plucker a) -> Exp (V3 a)

-- | Not all 6-dimensional points correspond to a line in 3D. This
--   predicate tests that a Plücker coordinate lies on the Grassmann
--   manifold, and does indeed represent a 3D line.
isLine :: Epsilon a => Exp (Plucker a) -> Exp Bool

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p01 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p02 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p03 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p10 :: Num a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p12 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p13 :: Num a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p20 :: Num a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p21 :: Num a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p23 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p30 :: Num a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p31 :: Elt a => Lens' (Exp (Plucker a)) (Exp a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p32 :: Num a => Lens' (Exp (Plucker a)) (Exp a)
instance Data.Array.Accelerate.Linear.Metric.Metric Linear.Plucker.Plucker
instance Data.Array.Accelerate.Linear.Vector.Additive Linear.Plucker.Plucker
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Linear.Plucker.Plucker a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker (Data.Array.Accelerate.Smart.Exp a))
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Control.Lens.Each.Each (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a)) (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker b)) (Data.Array.Accelerate.Smart.Exp a) (Data.Array.Accelerate.Smart.Exp b)
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Classes.Ord.Ord a => Data.Array.Accelerate.Classes.Ord.Ord (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Classes.Num.Num a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a))
instance Data.Array.Accelerate.Classes.Fractional.Fractional a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a))
instance Data.Array.Accelerate.Classes.Floating.Floating a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Linear.Plucker.Plucker a))
instance Data.Array.Accelerate.Linear.Epsilon.Epsilon a => Data.Array.Accelerate.Linear.Epsilon.Epsilon (Linear.Plucker.Plucker a)
instance Data.Array.Accelerate.Data.Functor.Functor Linear.Plucker.Plucker
instance Data.Array.Accelerate.Array.Sugar.Elt Linear.Plucker.LinePass
instance Data.Array.Accelerate.Classes.Eq.Eq Linear.Plucker.LinePass


-- | Simple matrix operations for low-dimensional primitives
module Data.Array.Accelerate.Linear.Trace
class Trace m => Trace m

-- | Compute the trace of a matrix
trace :: (Trace m, Num a, Box2 m m a) => Exp (m (m a)) -> Exp a

-- | Compute the diagonal of a matrix
diagonal :: (Trace m, Box2 m m a) => Exp (m (m a)) -> Exp (m a)
instance Data.Array.Accelerate.Linear.Trace.Trace Data.Complex.Complex
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.V0.V0
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.V1.V1
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.V2.V2
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.V3.V3
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.V4.V4
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.Plucker.Plucker
instance Data.Array.Accelerate.Linear.Trace.Trace Linear.Quaternion.Quaternion


-- | Simple matrix operations for low-dimensional primitives
module Data.Array.Accelerate.Linear.Matrix

-- | Matrix product. This can compute any combination of sparse and dense
--   multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !*! lift (V3 (V2 1 2) (V2 3 4) (V2 4 5) :: M32 Int)
--   V2 (V2 19 25) (V2 43 58)
--   </pre>
(!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a, Box2 m t a, Box2 t n a, Box2 m n a) => Exp (m (t a)) -> Exp (t (n a)) -> Exp (m (n a))
infixl 7 !*!

-- | Entry-wise matrix addition.
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !+! lift (V2 (V3 7 8 9) (V3 1 2 3) :: M23 Int)
--   V2 (V3 8 10 12) (V3 5 7 9)
--   </pre>
(!+!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))
infixl 6 !+!

-- | Entry-wise matrix subtraction.
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !-! lift (V2 (V3 7 8 9) (V3 1 2 3) :: M23 Int)
--   V2 (V3 (-6) (-6) (-6)) (V3 3 3 3)
--   </pre>
(!-!) :: (Additive m, Additive n, Num a, Box2 m n a) => Exp (m (n a)) -> Exp (m (n a)) -> Exp (m (n a))
infixl 6 !-!

-- | Matrix * column vector
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 (V3 1 2 3) (V3 4 5 6) :: M23 Int) !* lift (V3 7 8 9 :: V3 Int)
--   V2 50 122
--   </pre>
(!*) :: (Functor m, Foldable r, Additive r, Num a, Box2 m r a, Box m a) => Exp (m (r a)) -> Exp (r a) -> Exp (m a)
infixl 7 !*

-- | Row vector * matrix
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 1 2 :: V2 Int) *! lift (V2 (V3 3 4 5) (V3 6 7 8) :: M23 Int)
--   V3 15 18 21
--   </pre>
(*!) :: (Foldable t, Additive f, Additive t, Num a, Box t a, Box f a, Box2 t f a) => Exp (t a) -> Exp (t (f a)) -> Exp (f a)
infixl 7 *!

-- | Matrix-scalar product
--   
--   <pre>
--   &gt;&gt;&gt; test $ lift (V2 (V2 1 2) (V2 3 4) :: M22 Int) !!* 5
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(!!*) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))
infixl 7 !!*

-- | Scalar-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; test $ 5 *!! lift (V2 (V2 1 2) (V2 3 4) :: M22 Int)
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(*!!) :: (Functor m, Functor r, Num a, Box2 m r a) => Exp a -> Exp (m (r a)) -> Exp (m (r a))
infixl 7 *!!

-- | Matrix-scalar division
(!!/) :: (Functor m, Functor r, Floating a, Box2 m r a) => Exp (m (r a)) -> Exp a -> Exp (m (r a))
infixl 7 !!/

-- | A 2x2 matrix with row-major representation
type M22 a = V2 V2 a

-- | A 2x3 matrix with row-major representation
type M23 a = V2 V3 a

-- | A 2x4 matrix with row-major representation
type M24 a = V2 V4 a

-- | A 3x2 matrix with row-major representation
type M32 a = V3 V2 a

-- | A 3x3 matrix with row-major representation
type M33 a = V3 V3 a

-- | A 3x4 matrix with row-major representation
type M34 a = V3 V4 a

-- | A 4x2 matrix with row-major representation
type M42 a = V4 V2 a

-- | A 4x3 matrix with row-major representation
type M43 a = V4 V3 a

-- | A 4x4 matrix with row-major representation
type M44 a = V4 V4 a

-- | Convert a 3x3 matrix to a 4x4 matrix extending it with zeros in the
--   new row and column.
m33_to_m44 :: Num a => Exp (M33 a) -> Exp (M44 a)

-- | Convert a 4x3 matrix to a 4x4 matrix, extending it with <tt>[ 0 0 0 1
--   ]</tt> column vector
m43_to_m44 :: Num a => Exp (M43 a) -> Exp (M44 a)

-- | 2x2 matrix determinant
det22 :: Num a => Exp (M22 a) -> Exp a

-- | 3x3 matrix determinant
det33 :: Num a => Exp (M33 a) -> Exp a

-- | 4x4 matrix determinant
det44 :: Num a => Exp (M44 a) -> Exp a

-- | 2x2 matrix inverse
inv22 :: Fractional a => Exp (M22 a) -> Exp (M22 a)

-- | 3x3 matrix inverse
inv33 :: Fractional a => Exp (M33 a) -> Exp (M33 a)

-- | 4x4 matrix inverse
inv44 :: Fractional a => Exp (M44 a) -> Exp (M44 a)

-- | The identity matrix for any dimension vector.
--   
--   <pre>
--   &gt;&gt;&gt; test $ (identity :: Exp (M44 Int))
--   V4 (V4 1 0 0 0) (V4 0 1 0 0) (V4 0 0 1 0) (V4 0 0 0 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ (identity :: Exp (V3 (V3 Int)))
--   V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   </pre>
identity :: forall t a. (Traversable t, Applicative t, Num a, Box2 t t a) => Exp (t (t a))

-- | <a>transpose</a> is just an alias for <a>distribute</a>
--   
--   <pre>
--   &gt;&gt;&gt; test $ transpose $ lift (V3 (V2 1 2) (V2 3 4) (V2 5 6) :: M32 Int)
--   V2 (V3 1 3 5) (V3 2 4 6)
--   </pre>
transpose :: (Distributive g, Functor f, Box2 f g a, Box2 g f a) => Exp (f (g a)) -> Exp (g (f a))
class Trace m => Trace m

-- | Compute the trace of a matrix
trace :: (Trace m, Num a, Box2 m m a) => Exp (m (m a)) -> Exp a

-- | Compute the diagonal of a matrix
diagonal :: (Trace m, Box2 m m a) => Exp (m (m a)) -> Exp (m a)

-- | Build a rotation matrix from a unit <a>Quaternion</a>
fromQuaternion :: forall a. Num a => Exp (Quaternion a) -> Exp (M33 a)

-- | Build a transformation matrix from a rotation expressed as a
--   <a>Quaternion</a> and a translation vector.
mkTransformation :: forall a. Num a => Exp (Quaternion a) -> Exp (V3 a) -> Exp (M44 a)

-- | Build a transformation matrix from a rotation matrix and a translation
--   vector.
mkTransformationMat :: Num a => Exp (M33 a) -> Exp (V3 a) -> Exp (M44 a)


-- | Common projection matrices; for example perspective and orthographic
--   transformation matrices.
module Data.Array.Accelerate.Linear.Projection

-- | Build a look at view matrix
lookAt :: (Epsilon a, Floating a) => Exp (V3 a) -> Exp (V3 a) -> Exp (V3 a) -> Exp (M44 a)

-- | Build a matrix for a symmetric perspective-view frustum
perspective :: Floating a => Exp a -> Exp a -> Exp a -> Exp a -> Exp (M44 a)

-- | Build a matrix for a symmetric perspective-view frustum with a far
--   plane at infinite
infinitePerspective :: Floating a => Exp a -> Exp a -> Exp a -> Exp (M44 a)

-- | Build an orthographic perspective matrix from 6 clipping planes
ortho :: Floating a => Exp a -> Exp a -> Exp a -> Exp a -> Exp a -> Exp a -> Exp (M44 a)
($$$$$$) :: (b -> a) -> (c -> d -> e -> f -> g -> h -> b) -> c -> d -> e -> f -> g -> h -> a
infixr 0 $$$$$$


-- | This module simply re-exports everything from the various modules that
--   make up the linear package, lifted to Accelerate.
module Data.Array.Accelerate.Linear
