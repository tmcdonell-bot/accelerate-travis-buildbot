-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple ANSI terminal support, with Windows compatibility
--   
--   ANSI terminal support for Haskell: allows cursor movement, screen
--   clearing, color output, showing or hiding the cursor, and changing the
--   title. Works on UNIX and Windows.
@package ansi-terminal
@version 0.7.1.1


-- | Types used to represent SELECT GRAPHIC RENDITION (SGR) aspects.
module System.Console.ANSI.Types

-- | ANSI Select Graphic Rendition command
data SGR
Reset :: SGR
SetConsoleIntensity :: ConsoleIntensity -> SGR

-- | Not widely supported: sometimes treated as swapping foreground and
--   background
SetItalicized :: Bool -> SGR
SetUnderlining :: Underlining -> SGR
SetBlinkSpeed :: BlinkSpeed -> SGR

-- | Not widely supported
SetVisible :: Bool -> SGR
SetSwapForegroundBackground :: Bool -> SGR
SetColor :: ConsoleLayer -> ColorIntensity -> Color -> SGR

-- | Supported from Windows 10 Creators Update
SetRGBColor :: ConsoleLayer -> (Colour Float) -> SGR

-- | ANSI colors can be set on two different layers
data ConsoleLayer
Foreground :: ConsoleLayer
Background :: ConsoleLayer

-- | ANSI colors: come in various intensities, which are controlled by
--   <a>ColorIntensity</a>
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | ANSI colors come in two intensities
data ColorIntensity
Dull :: ColorIntensity
Vivid :: ColorIntensity

-- | ANSI general console intensity: usually treated as setting the font
--   style (e.g. <a>BoldIntensity</a> causes text to be bold)
data ConsoleIntensity
BoldIntensity :: ConsoleIntensity

-- | Not widely supported: sometimes treated as concealing text
FaintIntensity :: ConsoleIntensity
NormalIntensity :: ConsoleIntensity

-- | ANSI text underlining
data Underlining
SingleUnderline :: Underlining

-- | Not widely supported
DoubleUnderline :: Underlining
NoUnderline :: Underlining

-- | ANSI blink speeds: values other than <a>NoBlink</a> are not widely
--   supported
data BlinkSpeed

-- | Less than 150 blinks per minute
SlowBlink :: BlinkSpeed

-- | More than 150 blinks per minute
RapidBlink :: BlinkSpeed
NoBlink :: BlinkSpeed
instance GHC.Read.Read System.Console.ANSI.Types.SGR
instance GHC.Show.Show System.Console.ANSI.Types.SGR
instance GHC.Classes.Eq System.Console.ANSI.Types.SGR
instance GHC.Arr.Ix System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Read.Read System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Show.Show System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Enum.Enum System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Enum.Bounded System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Classes.Ord System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Classes.Eq System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Arr.Ix System.Console.ANSI.Types.Underlining
instance GHC.Read.Read System.Console.ANSI.Types.Underlining
instance GHC.Show.Show System.Console.ANSI.Types.Underlining
instance GHC.Enum.Enum System.Console.ANSI.Types.Underlining
instance GHC.Enum.Bounded System.Console.ANSI.Types.Underlining
instance GHC.Classes.Ord System.Console.ANSI.Types.Underlining
instance GHC.Classes.Eq System.Console.ANSI.Types.Underlining
instance GHC.Arr.Ix System.Console.ANSI.Types.BlinkSpeed
instance GHC.Read.Read System.Console.ANSI.Types.BlinkSpeed
instance GHC.Show.Show System.Console.ANSI.Types.BlinkSpeed
instance GHC.Enum.Enum System.Console.ANSI.Types.BlinkSpeed
instance GHC.Enum.Bounded System.Console.ANSI.Types.BlinkSpeed
instance GHC.Classes.Ord System.Console.ANSI.Types.BlinkSpeed
instance GHC.Classes.Eq System.Console.ANSI.Types.BlinkSpeed
instance GHC.Arr.Ix System.Console.ANSI.Types.ConsoleLayer
instance GHC.Read.Read System.Console.ANSI.Types.ConsoleLayer
instance GHC.Show.Show System.Console.ANSI.Types.ConsoleLayer
instance GHC.Enum.Enum System.Console.ANSI.Types.ConsoleLayer
instance GHC.Enum.Bounded System.Console.ANSI.Types.ConsoleLayer
instance GHC.Classes.Ord System.Console.ANSI.Types.ConsoleLayer
instance GHC.Classes.Eq System.Console.ANSI.Types.ConsoleLayer
instance GHC.Arr.Ix System.Console.ANSI.Types.ColorIntensity
instance GHC.Read.Read System.Console.ANSI.Types.ColorIntensity
instance GHC.Show.Show System.Console.ANSI.Types.ColorIntensity
instance GHC.Enum.Enum System.Console.ANSI.Types.ColorIntensity
instance GHC.Enum.Bounded System.Console.ANSI.Types.ColorIntensity
instance GHC.Classes.Ord System.Console.ANSI.Types.ColorIntensity
instance GHC.Classes.Eq System.Console.ANSI.Types.ColorIntensity
instance GHC.Arr.Ix System.Console.ANSI.Types.Color
instance GHC.Read.Read System.Console.ANSI.Types.Color
instance GHC.Show.Show System.Console.ANSI.Types.Color
instance GHC.Enum.Enum System.Console.ANSI.Types.Color
instance GHC.Enum.Bounded System.Console.ANSI.Types.Color
instance GHC.Classes.Ord System.Console.ANSI.Types.Color
instance GHC.Classes.Eq System.Console.ANSI.Types.Color


-- | Functions that return <a>String</a> values containing codes in
--   accordance with: (1) standard ECMA-48 Control Functions for Coded
--   Character Sets (5th edition, 1991); or (2) in the case of
--   <a>setTitleCode</a>, the XTerm control sequence.
--   
--   The reference used for the codes in this module was
--   <a>http://en.wikipedia.org/wiki/ANSI_escape_sequences</a>.
--   
--   If module <a>System.Console.ANSI</a> is also imported, this module is
--   intended to be imported qualified, to avoid name clashes with
--   functions which return "" when Windows ANSI terminal support is
--   emulated. e.g.
--   
--   <pre>
--   import qualified System.Console.ANSI.Codes as ANSI
--   </pre>
module System.Console.ANSI.Codes
cursorUpCode :: Int -> String
cursorDownCode :: Int -> String
cursorForwardCode :: Int -> String
cursorBackwardCode :: Int -> String
cursorUpLineCode :: Int -> String
cursorDownLineCode :: Int -> String
setCursorColumnCode :: Int -> String
setCursorPositionCode :: Int -> Int -> String
saveCursorCode :: String
restoreCursorCode :: String
reportCursorPositionCode :: String
clearFromCursorToScreenEndCode :: String
clearFromCursorToScreenBeginningCode :: String
clearScreenCode :: String
clearFromCursorToLineEndCode :: String
clearFromCursorToLineBeginningCode :: String
clearLineCode :: String
scrollPageUpCode :: Int -> String
scrollPageDownCode :: Int -> String
setSGRCode :: [SGR] -> String
hideCursorCode :: String
showCursorCode :: String

-- | XTerm control sequence to set the Icon Name and Window Title.
setTitleCode :: String -> String

-- | <a>colorToCode</a> <tt>color</tt> returns the 0-based index of the
--   color (one of the eight colors in the standard).
colorToCode :: Color -> Int

-- | <a>csi</a> <tt>parameters controlFunction</tt>, where
--   <tt>parameters</tt> is a list of <a>Int</a>, returns the control
--   sequence comprising the control function CONTROL SEQUENCE INTRODUCER
--   (CSI) followed by the parameter(s) (separated by ';') and ending with
--   the <tt>controlFunction</tt> character(s) that identifies the control
--   function.
csi :: [Int] -> String -> String

-- | <a>sgrToCode</a> <tt>sgr</tt> returns the parameter of the SELECT
--   GRAPHIC RENDITION (SGR) aspect identified by <tt>sgr</tt>.
sgrToCode :: SGR -> [Int]


-- | Provides ANSI terminal support for ANSI terminal software running on a
--   Unix-like operating system or on a Windows operating system (where
--   supported) or on other Windows operating systems where the terminal in
--   use is not ANSI-enabled.
--   
--   The ANSI escape codes are described at
--   <a>http://en.wikipedia.org/wiki/ANSI_escape_code</a> and provide a
--   rich range of functionality for terminal control, which includes:
--   
--   <ul>
--   <li>Colored text output, with control over both foreground and
--   background colors</li>
--   <li>Hiding or showing the cursor</li>
--   <li>Moving the cursor around</li>
--   <li>Clearing parts of the screen</li>
--   </ul>
--   
--   The most frequently used parts of this ANSI command set are exposed
--   with a platform independent interface by this module. Every function
--   exported comes in three flavours:
--   
--   <ul>
--   <li>Vanilla: has an <tt>IO ()</tt> type and doesn't take a
--   <tt>Handle</tt>. This just outputs the ANSI command directly on to the
--   terminal corresponding to stdout. Commands issued like this should
--   work as you expect on both Windows and Unix.</li>
--   <li>Chocolate: has an <tt>IO ()</tt> type but takes a <tt>Handle</tt>.
--   This outputs the ANSI command on the terminal corresponding to the
--   supplied handle. Commands issued like this should also work as you
--   expect on both Windows and Unix.</li>
--   <li>Strawberry: has a <tt>String</tt> type and just consists of an
--   escape code which can be added to any other bit of text before being
--   output. The use of these codes is generally discouraged because they
--   will not work on Windows operating systems where the terminal in use
--   is not ANSI-enabled (such as those before Windows 10 Threshold 2). On
--   versions of Windows where the terminal in use is not ANSI-enabled,
--   these codes will always be the empty string, so it is possible to use
--   them portably for e.g. coloring console output on the understanding
--   that you will only see colors if you are running on an operating
--   system that is Unix-like or is a version of Windows where the terminal
--   in use is ANSI- enabled.</li>
--   </ul>
--   
--   Example:
--   
--   <pre>
--   -- Set colors and write some text in those colors.
--   sgrExample :: IO ()
--   sgrExample = do
--       setSGR [SetColor Foreground Vivid Red]
--       setSGR [SetColor Background Vivid Blue]
--       putStr "Red-On-Blue"
--       setSGR [Reset]
--       putStr "White-On-Black"
--   </pre>
--   
--   For many more examples, see the project's extensive <a>Example.hs</a>
--   file.
module System.Console.ANSI
cursorUp :: Int -> IO ()
cursorDown :: Int -> IO ()
cursorForward :: Int -> IO ()
cursorBackward :: Int -> IO ()
hCursorUp :: Handle -> Int -> IO ()
hCursorDown :: Handle -> Int -> IO ()
hCursorForward :: Handle -> Int -> IO ()
hCursorBackward :: Handle -> Int -> IO ()
cursorUpCode :: Int -> String
cursorDownCode :: Int -> String
cursorForwardCode :: Int -> String
cursorBackwardCode :: Int -> String
cursorUpLine :: Int -> IO ()
cursorDownLine :: Int -> IO ()
hCursorUpLine :: Handle -> Int -> IO ()
hCursorDownLine :: Handle -> Int -> IO ()
cursorUpLineCode :: Int -> String
cursorDownLineCode :: Int -> String
setCursorColumn :: Int -> IO ()
hSetCursorColumn :: Handle -> Int -> IO ()
setCursorColumnCode :: Int -> String
setCursorPosition :: Int -> Int -> IO ()
hSetCursorPosition :: Handle -> Int -> Int -> IO ()
setCursorPositionCode :: Int -> Int -> String

-- | Save the cursor position in memory. The only way to access the saved
--   value is with the <a>restoreCursor</a> command.
saveCursor :: IO ()
hSaveCursor :: Handle -> IO ()
saveCursorCode :: String

-- | Restore the cursor position from memory. There will be no value saved
--   in memory until the first use of the <a>saveCursor</a> command.
restoreCursor :: IO ()
hRestoreCursor :: Handle -> IO ()
restoreCursorCode :: String

-- | Looking for a way to get the cursors position? See
--   <a>getCursorPosition</a>.
--   
--   Emit the cursor position into the console input stream, immediately
--   after being recognised on the output stream, as: <tt>ESC [ &lt;cursor
--   row&gt; ; &lt;cursor column&gt; R</tt>
--   
--   In isolation of <a>getReportedCursorPosition</a> or
--   <a>getCursorPosition</a>, this function may be of limited use on
--   Windows operating systems because of difficulties in obtaining the
--   data emitted into the console input stream. The function
--   <tt>hGetBufNonBlocking</tt> in module <a>System.IO</a> does not work
--   on Windows. This has been attributed to the lack of non-blocking
--   primatives in the operating system (see the GHC bug report #806 at
--   <a>https://ghc.haskell.org/trac/ghc/ticket/806</a>).
reportCursorPosition :: IO ()
hReportCursorPosition :: Handle -> IO ()
reportCursorPositionCode :: String
clearFromCursorToScreenEnd :: IO ()
clearFromCursorToScreenBeginning :: IO ()
clearScreen :: IO ()
hClearFromCursorToScreenEnd :: Handle -> IO ()
hClearFromCursorToScreenBeginning :: Handle -> IO ()
hClearScreen :: Handle -> IO ()
clearFromCursorToScreenEndCode :: String
clearFromCursorToScreenBeginningCode :: String
clearScreenCode :: String
clearFromCursorToLineEnd :: IO ()
clearFromCursorToLineBeginning :: IO ()
clearLine :: IO ()
hClearFromCursorToLineEnd :: Handle -> IO ()
hClearFromCursorToLineBeginning :: Handle -> IO ()
hClearLine :: Handle -> IO ()
clearFromCursorToLineEndCode :: String
clearFromCursorToLineBeginningCode :: String
clearLineCode :: String

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
scrollPageUp :: Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
scrollPageDown :: Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
hScrollPageUp :: Handle -> Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
hScrollPageDown :: Handle -> Int -> IO ()
scrollPageUpCode :: Int -> String
scrollPageDownCode :: Int -> String

-- | Set the Select Graphic Rendition mode
setSGR :: [SGR] -> IO ()

-- | Set the Select Graphic Rendition mode
hSetSGR :: Handle -> [SGR] -> IO ()
setSGRCode :: [SGR] -> String
hideCursor :: IO ()
showCursor :: IO ()
hHideCursor :: Handle -> IO ()
hShowCursor :: Handle -> IO ()
hideCursorCode :: String
showCursorCode :: String

-- | Set the terminal window title
setTitle :: String -> IO ()

-- | Set the terminal window title
hSetTitle :: Handle -> String -> IO ()

-- | XTerm control sequence to set the Icon Name and Window Title.
setTitleCode :: String -> String

-- | Use heuristics to determine whether the functions defined in this
--   package will work with a given handle.
--   
--   The current implementation checks that the handle is a terminal, and
--   that the <tt>TERM</tt> environment variable doesn't say <tt>dumb</tt>
--   (which is what Emacs sets for its own terminal).
hSupportsANSI :: Handle -> IO Bool

-- | Attempts to get the reported cursor position, combining the functions
--   <a>reportCursorPosition</a>, <a>getReportedCursorPosition</a> and
--   <a>cursorPosition</a>. Returns <a>Nothing</a> if any data emitted by
--   <a>reportCursorPosition</a>, obtained by
--   <a>getReportedCursorPosition</a>, cannot be parsed by
--   <a>cursorPosition</a>.
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
getCursorPosition :: IO (Maybe (Int, Int))

-- | Attempts to get the reported cursor position data from the console
--   input stream. The function is intended to be called immediately after
--   <a>reportCursorPosition</a> (or related functions) have caused
--   characters to be emitted into the stream.
--   
--   For example, on a Unix-like operating system:
--   
--   <pre>
--   hSetBuffering stdin NoBuffering -- set no buffering (the contents of the
--                                   -- buffer will be discarded, so this needs
--                                   -- to be done before the cursor positon is
--                                   -- emitted)
--   reportCursorPosition
--   hFlush stdout -- ensure the report cursor position code is sent to the
--                 -- operating system
--   input &lt;- getReportedCursorPosition
--   </pre>
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
getReportedCursorPosition :: IO String

-- | Parses the characters emitted by <a>reportCursorPosition</a> into the
--   console input stream. Returns the cursor row and column as a tuple.
--   
--   For example, if the characters emitted by <a>reportCursorPosition</a>
--   are in <a>String</a> <tt>input</tt> then the parser could be applied
--   like this:
--   
--   <pre>
--   let result = readP_to_S cursorPosition input
--   case result of
--       [] -&gt; putStrLn $ "Error: could not parse " ++ show input
--       [((row, column), _)] -&gt; putStrLn $ "The cursor was at row " ++ show row
--           ++ " and column" ++ show column ++ "."
--       (_:_) -&gt; putStrLn $ "Error: parse not unique"
--   </pre>
cursorPosition :: ReadP (Int, Int)
