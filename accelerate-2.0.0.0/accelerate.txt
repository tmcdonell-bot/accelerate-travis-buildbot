-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An embedded language for accelerated array processing
--   
--   <tt>Data.Array.Accelerate</tt> defines an embedded array language for
--   computations for high-performance computing in Haskell. Computations
--   on multi-dimensional, regular arrays are expressed in the form of
--   parameterised collective operations, such as maps, reductions, and
--   permutations. These computations may then be online compiled and
--   executed on a range of architectures.
--   
--   <ul>
--   <li><i><i>A simple example</i></i></li>
--   </ul>
--   
--   As a simple example, consider the computation of a dot product of two
--   vectors of floating point numbers:
--   
--   <pre>
--   dotp :: Acc (Vector Float) -&gt; Acc (Vector Float) -&gt; Acc (Scalar Float)
--   dotp xs ys = fold (+) 0 (zipWith (*) xs ys)
--   </pre>
--   
--   Except for the type, this code is almost the same as the corresponding
--   Haskell code on lists of floats. The types indicate that the
--   computation may be online-compiled for performance - for example,
--   using <tt>Data.Array.Accelerate.CUDA</tt> it may be on-the-fly
--   off-loaded to the GPU.
--   
--   <ul>
--   <li><i><i>Additional components</i></i></li>
--   </ul>
--   
--   The following supported add-ons are available as separate packages.
--   Install them from Hackage with <tt>cabal install &lt;package&gt;</tt>
--   
--   <ul>
--   <li><tt>accelerate-cuda</tt>: Backend targeting CUDA-enabled NVIDIA
--   GPUs. Requires the NVIDIA CUDA SDK and, for full functionality,
--   hardware with compute compatibility 1.1 or greater. See the following
--   table for supported GPUs:
--   <a>http://en.wikipedia.org/wiki/CUDA#Supported_GPUs</a></li>
--   <li><tt>accelerate-examples</tt>: Computational kernels and
--   applications showcasing the use of Accelerate as well as a regression
--   test suite, supporting function and performance testing.</li>
--   <li><tt>accelerate-io</tt>: Fast conversions between Accelerate arrays
--   and other array formats (including vector and repa).</li>
--   <li><tt>accelerate-fft</tt>: Discrete Fourier transforms, with
--   optimised implementation for the CUDA backend.</li>
--   </ul>
--   
--   The following components are experimental and/or incomplete. Please
--   contact us if you are interested in helping to work on or test them!
--   
--   <ul>
--   <li><tt>accelerate-llvm</tt>: A framework for constructing backends
--   targeting LLVM IR, with concrete backends for multicore CPUs and
--   NVIDIA GPUs.</li>
--   </ul>
--   
--   Additionally, the following libraries can be used with Accelerate:
--   
--   <ul>
--   <li><tt>colour-accelerate</tt>: Colour representations in Accelerate
--   (RGB, sRGB, HSV, and HSL).</li>
--   <li><tt>gloss-accelerate</tt>: Generate gloss pictures from
--   Accelerate.</li>
--   <li><tt>gloss-raster-accelerate</tt>: Parallel rendering of raster
--   images and animations.</li>
--   <li><tt>lens-accelerate</tt>: Lens operators for Accelerate
--   types.</li>
--   <li><tt>linear-accelerate</tt>: Linear vector spaces in
--   Accelerate.</li>
--   <li><tt>mwc-random-accelerate</tt>: Generate Accelerate arrays filled
--   with high quality pseudorandom numbers.</li>
--   <li><tt>numeric-prelude-accelerate</tt>: Lifting numeric-prelude to
--   Accelerate.</li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Examples and documentation</i></i></li>
--   </ul>
--   
--   Haddock documentation is included in the package, and a tutorial is
--   available on the GitHub wiki:
--   <a>https://github.com/AccelerateHS/accelerate/wiki</a>
--   
--   The <tt>accelerate-examples</tt> package demonstrates a range of
--   computational kernels and several complete applications, including:
--   
--   <ul>
--   <li>An implementation of the Canny edge detection algorithm</li>
--   <li>An interactive Mandelbrot set generator</li>
--   <li>A particle-based simulation of stable fluid flows</li>
--   <li>An <i>n</i>-body simulation of gravitational attraction between
--   solid particles</li>
--   <li>A cellular automata simulation</li>
--   <li>A "password recovery" tool, for dictionary lookup of MD5
--   hashes</li>
--   <li>A simple interactive ray tracer</li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Mailing list and contacts</i></i></li>
--   </ul>
--   
--   <ul>
--   <li>Mailing list: <a>accelerate-haskell@googlegroups.com</a>
--   (discussion of both use and development welcome).</li>
--   <li>Sign up for the mailing list here:
--   <a>http://groups.google.com/group/accelerate-haskell</a></li>
--   <li>Bug reports and issue tracking:
--   <a>https://github.com/AccelerateHS/accelerate/issues</a></li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Hackage note</i></i></li>
--   </ul>
--   
--   The module documentation list generated by Hackage is incorrect. The
--   only exposed modules should be:
--   
--   <ul>
--   <li><a>Data.Array.Accelerate</a></li>
--   <li><a>Data.Array.Accelerate.Interpreter</a></li>
--   <li><a>Data.Array.Accelerate.Data.Bits</a></li>
--   <li><a>Data.Array.Accelerate.Data.Complex</a></li>
--   </ul>
@package accelerate
@version 2.0.0.0


-- | Bitwise operations for signed and unsigned integer expressions.
module Data.Array.Accelerate.Data.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral scalar
--   expression types. As usual, bits are numbered from zero, with zero
--   being the least significant bit.
class Eq a => Bits a where shift x i = cond (i <* 0) (x `shiftR` (- i)) $ cond (i >* 0) (x `shiftL` i) $ x rotate x i = cond (i <* 0) (x `rotateR` (- i)) $ cond (i >* 0) (x `rotateL` i) $ x zeroBits = clearBit (bit 0) 0 setBit x i = x .|. bit i clearBit x i = x .&. complement (bit i) complementBit x i = x `xor` bit i shiftL x i = x `shift` i unsafeShiftL = shiftL shiftR x i = x `shift` (- i) unsafeShiftR = shiftR rotateL x i = x `rotate` i rotateR x i = x `rotate` (- i)

-- | Bitwise "and"
(.&.) :: Bits a => Exp a -> Exp a -> Exp a

-- | Bitwise "or"
(.|.) :: Bits a => Exp a -> Exp a -> Exp a

-- | Bitwise "xor"
xor :: Bits a => Exp a -> Exp a -> Exp a

-- | Reverse all bits in the argument
complement :: Bits a => Exp a -> Exp a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
shift :: Bits a => Exp a -> Exp Int -> Exp a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
rotate :: Bits a => Exp a -> Exp Int -> Exp a

-- | The value with all bits unset
zeroBits :: Bits a => Exp a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
bit :: Bits a => Exp Int -> Exp a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => Exp a -> Exp Int -> Exp a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => Exp a -> Exp Int -> Exp a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => Exp a -> Exp Int -> Exp a

-- | Return <a>True</a> if the <tt>n</tt>th bit of the argument is 1
testBit :: Bits a => Exp a -> Exp Int -> Exp Bool

-- | Return <a>True</a> if the argument is a signed type.
isSigned :: Bits a => Exp a -> Exp Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL :: Bits a => Exp a -> Exp Int -> Exp a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>finiteBitSize</a>.
unsafeShiftL :: Bits a => Exp a -> Exp Int -> Exp a

-- | Shift the first argument right by the specified number of bits (which
--   must be non-negative).
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if <tt>x</tt> is negative and with 0
--   otherwise.
shiftR :: Bits a => Exp a -> Exp Int -> Exp a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>finiteBitSize</a>.
unsafeShiftR :: Bits a => Exp a -> Exp Int -> Exp a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
rotateL :: Bits a => Exp a -> Exp Int -> Exp a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
rotateR :: Bits a => Exp a -> Exp Int -> Exp a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
popCount :: Bits a => Exp a -> Exp Int
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument.
finiteBitSize :: FiniteBits b => Exp b -> Exp Int
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Types.Bool
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Types.Int
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Int.Int8
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Int.Int16
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Int.Int32
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Int.Int64
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Types.Word
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Word.Word8
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Word.Word16
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Word.Word32
instance Data.Array.Accelerate.Data.Bits.Bits GHC.Word.Word64
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CInt
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CUInt
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CLong
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CULong
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CLLong
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CULLong
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CShort
instance Data.Array.Accelerate.Data.Bits.Bits Foreign.C.Types.CUShort
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Types.Bool
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Types.Int
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Int.Int8
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Int.Int16
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Int.Int32
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Int.Int64
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Types.Word
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Word.Word8
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Word.Word16
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Word.Word32
instance Data.Array.Accelerate.Data.Bits.FiniteBits GHC.Word.Word64
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CInt
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CUInt
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CLong
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CULong
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CLLong
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CULLong
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CShort
instance Data.Array.Accelerate.Data.Bits.FiniteBits Foreign.C.Types.CUShort


-- | Complex numbers
module Data.Array.Accelerate.Data.Complex

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
data Complex a :: * -> *

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: SrictNotUnpackeda -> SrictNotUnpackeda -> Complex a

-- | Return the real part of a complex number
real :: Elt a => Exp (Complex a) -> Exp a

-- | Return the imaginary part of a complex number
imag :: Elt a => Exp (Complex a) -> Exp a

-- | Form a complex number from polar components of magnitude and phase.
mkPolar :: (Elt a, RealFloat a) => Exp a -> Exp a -> Exp (Complex a)

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: (Elt a, RealFloat a) => Exp a -> Exp (Complex a)

-- | The function <a>polar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   non-negative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
polar :: (Elt a, RealFloat a) => Exp (Complex a) -> Exp (a, a)

-- | The non-negative magnitude of a complex number
magnitude :: (Elt a, RealFloat a) => Exp (Complex a) -> Exp a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: (Elt a, RealFloat a) => Exp (Complex a) -> Exp a

-- | Return the complex conjugate of a complex number, defined as
--   
--   <pre>
--   conjugate(Z) = X - iY
--   </pre>
conjugate :: (Elt a, Num a) => Exp (Complex a) -> Exp (Complex a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Data.Complex.Complex a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Classes.Eq.Eq a => Data.Array.Accelerate.Classes.Eq.Eq (Data.Complex.Complex a)
instance Data.Array.Accelerate.Classes.RealFloat.RealFloat a => GHC.Num.Num (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
instance Data.Array.Accelerate.Classes.RealFloat.RealFloat a => GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
instance Data.Array.Accelerate.Classes.RealFloat.RealFloat a => GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
instance (Data.Array.Accelerate.Classes.FromIntegral.FromIntegral a b, Data.Array.Accelerate.Classes.Num.Num b) => Data.Array.Accelerate.Classes.FromIntegral.FromIntegral a (Data.Complex.Complex b)


-- | This interpreter is meant to be a reference implementation of the
--   semantics of the embedded array language. The emphasis is on defining
--   the semantics clearly, not on performance.
--   
--   <i>Surface types versus representation types</i>
--   
--   As a general rule, we perform all computations on representation types
--   and we store all data as values of representation types. To guarantee
--   the type safety of the interpreter, this currently implies a lot of
--   conversions between surface and representation types. Optimising the
--   code by eliminating back and forth conversions is fine, but only where
--   it doesn't negatively affects clarity — after all, the main purpose of
--   the interpreter is to serve as an executable specification.
module Data.Array.Accelerate.Interpreter

-- | Run a complete embedded array program using the reference interpreter.
run :: Arrays a => Acc a -> a

-- | Prepare and run an embedded array program of one argument
run1 :: (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b

-- | Stream a lazily read list of input arrays through the given program,
--   collecting results as we go
streamOut :: Arrays a => Seq [a] -> [a]


-- | This module defines an embedded language of array computations for
--   high-performance computing. Computations on multi-dimensional, regular
--   arrays are expressed in the form of parameterised collective
--   operations (such as maps, reductions, and permutations). These
--   computations are online compiled and executed on a range of
--   architectures.
--   
--   <ul>
--   <li><i><i>Abstract interface:</i></i></li>
--   </ul>
--   
--   The types representing array computations are only exported abstractly
--   — i.e., client code can generate array computations and submit them
--   for execution, but it cannot inspect these computations. This is to
--   allow for more flexibility for future extensions of this library.
--   
--   <ul>
--   <li><i><i>Code execution:</i></i></li>
--   </ul>
--   
--   Access to the various backends is via a <tt>run</tt> function in
--   backend-specific top level modules. Currently, we have the following:
--   
--   <ul>
--   <li><a>Data.Array.Accelerate.Interpreter</a>: simple interpreter in
--   Haskell as a reference implementation defining the semantics of the
--   Accelerate language</li>
--   <li><a>Data.Array.Accelerate.CUDA</a>: an implementation supporting
--   parallel execution on CUDA-capable NVIDIA GPUs</li>
--   </ul>
--   
--   <ul>
--   <li><i><i>Examples and documentation:</i></i></li>
--   </ul>
--   
--   <ul>
--   <li>A (draft) tutorial is available on the GitHub wiki:
--   <a>https://github.com/AccelerateHS/accelerate/wiki</a></li>
--   <li>The <tt>accelerate-examples</tt> package demonstrates a range of
--   computational kernels and several complete applications:
--   <a>http://hackage.haskell.org/package/accelerate-examples</a></li>
--   </ul>
module Data.Array.Accelerate

-- | Array-valued collective computations
data Acc a

-- | Array-valued sequence computations
data Seq a
class (Typeable a, Typeable (ArrRepr a)) => Arrays a

-- | Multi-dimensional arrays for array processing.
--   
--   If device and host memory are separate, arrays will be transferred to
--   the device when necessary (if possible asynchronously and in parallel
--   with other tasks) and cached on the device if sufficient memory is
--   available.
data Array sh e

-- | Scalars arrays hold a single element
type Scalar e = Array DIM0 e

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e

-- | Segment descriptor (vector of segment lengths).
--   
--   To represent nested one-dimensional arrays, we use a flat array of
--   data values in conjunction with a <i>segment descriptor</i>, which
--   stores the lengths of the subarrays.
type Segments i = Vector i

-- | Accelerate supports as array elements only simple atomic types, and
--   tuples thereof. These element types are stored efficiently in memory,
--   unpacked as consecutive elements without pointers.
--   
--   This class characterises the types of values that can be array
--   elements, and hence, appear in scalar Accelerate expressions.
class (Show a, Typeable a, Typeable (EltRepr a), ArrayElt (EltRepr a)) => Elt a

-- | Rank-0 index
data Z
Z :: Z

-- | Increase an index rank by one dimension. The <a>:.</a> operator is
--   used to construct both values and types.
data (:.) tail head
(:.) :: tail -> head -> (:.) tail head

-- | Shapes and indices of multi-dimensional arrays
class (Elt sh, Elt (Any sh), Shape (EltRepr sh), FullShape sh ~ sh, CoSliceShape sh ~ sh, SliceShape sh ~ Z) => Shape sh where rank = rank . fromElt size = size . fromElt empty = toElt empty ignore = toElt ignore intersect sh1 sh2 = toElt (intersect (fromElt sh1) (fromElt sh2)) union sh1 sh2 = toElt (union (fromElt sh1) (fromElt sh2)) fromIndex sh ix = toElt (fromIndex (fromElt sh) ix) toIndex sh ix = toIndex (fromElt sh) (fromElt ix) bound sh ix bndy = case bound (fromElt sh) (fromElt ix) bndy of { Left v -> Left v Right ix' -> Right $ toElt ix' } iter sh f c r = iter (fromElt sh) (f . toElt) c r iter1 sh f r = iter1 (fromElt sh) (f . toElt) r rangeToShape (low, high) = toElt (rangeToShape (fromElt low, fromElt high)) shapeToRange ix = let (low, high) = shapeToRange (fromElt ix) in (toElt low, toElt high) shapeToList = shapeToList . fromElt listToShape = toElt . listToShape

-- | Marker for entire dimensions in slice and division descriptors.
--   
--   For example, when used in slices passed to <a>replicate</a>, the
--   occurrences of <a>All</a> indicate the dimensions into which the
--   array's existing extent will be placed, rather than the new dimensions
--   introduced by replication.
data All
All :: All

-- | Marker for arbitrary shapes in slice and division descriptors. Such
--   arbitrary shapes may include an unknown number of dimensions.
--   
--   <a>Any</a> can be used in the leftmost position of a slice instead of
--   <a>Z</a>, for example <tt>(Any :. _ :. _)</tt>. In the following
--   definition <a>Any</a> is used to match against whatever shape the type
--   variable <tt>sh</tt> takes:
--   
--   <pre>
--   repN :: (Shape sh, Elt e) =&gt; Int -&gt; Acc (Array sh e) -&gt; Acc (Array (sh:.Int) e)
--   repN n a = replicate (constant $ Any :. n) a
--   </pre>
data Any sh
Any :: Any sh

-- | Marker for splitting along an entire dimension in division
--   descriptors.
--   
--   For example, when used in a division descriptor passed to
--   <a>toSeq</a>, a <a>Split</a> indicates that the array should be
--   divided along this dimension forming the elements of the output
--   sequence.
data Split
Split :: Split

-- | Marker for arbitrary shapes in slices descriptors, where it is desired
--   to split along an unknown number of dimensions.
--   
--   For example, in the following definition, <a>Divide</a> matches
--   against any shape and flattens everything but the innermost dimension.
--   
--   <pre>
--   vectors :: (Shape sh, Elt e) =&gt; Acc (Array (sh:.Int) e) -&gt; Seq [Vector e]
--   vectors = toSeq (Divide :. All)
--   </pre>
data Divide sh
Divide :: Divide sh

-- | Slices, aka generalised indices, as <i>n</i>-tuples and mappings of
--   slice indices to slices, co-slices, and slice dimensions
class (Elt sl, Shape (SliceShape sl), Shape (CoSliceShape sl), Shape (FullShape sl)) => Slice sl where type family SliceShape sl :: * type family CoSliceShape sl :: * type family FullShape sl :: *
sliceIndex :: Slice sl => sl -> SliceIndex (EltRepr sl) (EltRepr (SliceShape sl)) (EltRepr (CoSliceShape sl)) (EltRepr (FullShape sl))

-- | Generalised array division, like above but use for splitting an array
--   into many subarrays, as opposed to extracting a single subarray.
class (Slice (DivisionSlice sl)) => Division sl where type family DivisionSlice sl :: *
slicesIndex :: (Division sl, slix ~ DivisionSlice sl) => sl -> SliceIndex (EltRepr slix) (EltRepr (SliceShape slix)) (EltRepr (CoSliceShape slix)) (EltRepr (FullShape slix))
type DIM0 = Z
type DIM1 = DIM0 :. Int
type DIM2 = DIM1 :. Int
type DIM3 = DIM2 :. Int
type DIM4 = DIM3 :. Int
type DIM5 = DIM4 :. Int
type DIM6 = DIM5 :. Int
type DIM7 = DIM6 :. Int
type DIM8 = DIM7 :. Int
type DIM9 = DIM8 :. Int

-- | Expression form that extracts a scalar from an array
(!) :: (Shape ix, Elt e) => Acc (Array ix e) -> Exp ix -> Exp e

-- | Expression form that extracts a scalar from an array at a linear index
(!!) :: (Shape ix, Elt e) => Acc (Array ix e) -> Exp Int -> Exp e

-- | Extraction of the element in a singleton array
the :: Elt e => Acc (Scalar e) -> Exp e

-- | Test whether an array is empty
null :: (Shape ix, Elt e) => Acc (Array ix e) -> Exp Bool

-- | Get the length of a vector
length :: Elt e => Acc (Vector e) -> Exp Int

-- | Expression form that yields the shape of an array
shape :: (Shape ix, Elt e) => Acc (Array ix e) -> Exp ix

-- | Expression form that yields the size of an array
size :: (Shape ix, Elt e) => Acc (Array ix e) -> Exp Int

-- | The total number of elements in an array of the given <a>Shape</a>
shapeSize :: Shape ix => Exp ix -> Exp Int

-- | Index an array with a <i>generalised</i> array index, supplied as the
--   second argument. The result is a new array (possibly a singleton)
--   containing the selected dimensions (<a>All</a>s) in their entirety.
--   
--   This can be used to <i>cut out</i> entire dimensions. The opposite of
--   <a>replicate</a>. For example, if <tt>mat</tt> is a two dimensional
--   array, the following will select a specific row and yield a one
--   dimensional result:
--   
--   <pre>
--   slice mat (lift (Z :. (2::Int) :. All))
--   </pre>
--   
--   A fully specified index (with no <a>All</a>s) would return a single
--   element (zero dimensional array).
slice :: (Slice slix, Elt e) => Acc (Array (FullShape slix) e) -> Exp slix -> Acc (Array (SliceShape slix) e)

-- | Yield all but the elements in the last index of the outermost
--   dimension.
init :: (Slice sh, Shape sh, Elt e) => Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Yield all but the first element of the input vector. The vector must
--   not be empty.
tail :: (Slice sh, Shape sh, Elt e) => Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Yield the first <tt>n</tt> elements in the outermost dimension of the
--   array (plus all lower dimensional elements).
take :: (Slice sh, Shape sh, Elt e) => Exp Int -> Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Yield all but the first <tt>n</tt> elements along the outermost
--   dimension of the array (plus all lower dimensional elements).
drop :: (Slice sh, Shape sh, Elt e) => Exp Int -> Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Yield a slit (slice) of the outermost indices of an array.
--   Denotationally, we have:
--   
--   <pre>
--   slit i n = take n . drop i
--   </pre>
slit :: (Slice sh, Shape sh, Elt e) => Exp Int -> Exp Int -> Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Array inlet: makes an array available for processing using the
--   Accelerate language.
--   
--   Depending upon the backend used to execute array computations, this
--   may trigger (asynchronous) data transfer.
use :: Arrays arrays => arrays -> Acc arrays

-- | Scalar inlet: injects a scalar (or a tuple of scalars) into a
--   singleton array for use in the Accelerate language.
unit :: Elt e => Exp e -> Acc (Scalar e)

-- | Construct a new array by applying a function to each index.
--   
--   For example, the following will generate a one-dimensional array
--   (<a>Vector</a>) of three floating point numbers:
--   
--   <pre>
--   generate (index1 3) (\_ -&gt; 1.2)
--   </pre>
--   
--   Or, equivalently:
--   
--   <pre>
--   generate (constant (Z :. (3::Int))) (\_ -&gt; 1.2)
--   </pre>
--   
--   Finally, the following will create an array equivalent to '[1..10]':
--   
--   <pre>
--   generate (index1 10) $ \ ix -&gt;
--            let (Z :. i) = unlift ix
--            in fromIntegral i
--   </pre>
--   
--   <ul>
--   <li><i><i>NOTE:</i></i></li>
--   </ul>
--   
--   Using <a>generate</a>, it is possible to introduce nested data
--   parallelism, which will cause the program to fail.
--   
--   If the index given by the scalar function is then used to dispatch
--   further parallel work, whose result is returned into <a>Exp</a> terms
--   by array indexing operations such as (<a>!</a>) or <tt>the</tt>, the
--   program will fail with the error:
--   './Data/Array/Accelerate/Trafo/Sharing.hs:447 (convertSharingExp):
--   inconsistent valuation @ shared 'Exp' tree ...'.
generate :: (Shape ix, Elt a) => Exp ix -> (Exp ix -> Exp a) -> Acc (Array ix a)

-- | Replicate an array across one or more dimensions as specified by the
--   <i>generalised</i> array index provided as the first argument.
--   
--   For example, assuming <tt>arr</tt> is a vector (one-dimensional
--   array),
--   
--   <pre>
--   replicate (lift (Z :. (2::Int) :. All :. (3::Int))) arr
--   </pre>
--   
--   yields a three dimensional array, where <tt>arr</tt> is replicated
--   twice across the first and three times across the third dimension.
replicate :: (Slice slix, Elt e) => Exp slix -> Acc (Array (SliceShape slix) e) -> Acc (Array (FullShape slix) e)

-- | Create an array where all elements are the same value.
fill :: (Shape sh, Elt e) => Exp sh -> Exp e -> Acc (Array sh e)

-- | Create an array of the given shape containing the values x, x+1, etc
--   (in row-major order).
enumFromN :: (Shape sh, Elt e, Num e, FromIntegral Int e) => Exp sh -> Exp e -> Acc (Array sh e)

-- | Create an array of the given shape containing the values <tt>x</tt>,
--   <tt>x+y</tt>, <tt>x+y+y</tt> etc. (in row-major order).
enumFromStepN :: (Shape sh, Elt e, Num e, FromIntegral Int e) => Exp sh -> Exp e -> Exp e -> Acc (Array sh e)

-- | Concatenate outermost component of two arrays. The extent of the lower
--   dimensional component is the intersection of the two arrays.
(++) :: (Slice sh, Shape sh, Elt e) => Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e) -> Acc (Array (sh :. Int) e)

-- | Infix version of <a>acond</a>. If the predicate evaluates to
--   <a>True</a>, the first component of the tuple is returned, else the
--   second.
--   
--   See also: <a>ifThenElse</a>.
(?|) :: Arrays a => Exp Bool -> (Acc a, Acc a) -> Acc a

-- | An array-level if-then-else construct.
acond :: Arrays a => Exp Bool -> Acc a -> Acc a -> Acc a

-- | An array-level <a>while</a> construct. Continue to apply the given
--   function, starting with the initial value, until the test function
--   evaluates to <a>False</a>.
awhile :: Arrays a => (Acc a -> Acc (Scalar Bool)) -> (Acc a -> Acc a) -> Acc a -> Acc a

-- | For use with <tt>-XRebindableSyntax</tt>, this class provides
--   <a>ifThenElse</a> lifted to both scalar and array types.
class IfThenElse t where type family EltT t a :: Constraint
ifThenElse :: (IfThenElse t, EltT t a) => Exp Bool -> t a -> t a -> t a

-- | Pipelining of two array computations.
--   
--   Denotationally, we have
--   
--   <pre>
--   (acc1 &gt;-&gt; acc2) arrs = let tmp = acc1 arrs in acc2 tmp
--   </pre>
(>->) :: (Arrays a, Arrays b, Arrays c) => (Acc a -> Acc b) -> (Acc b -> Acc c) -> (Acc a -> Acc c)

-- | Force an array expression to be evaluated, preventing it from fusing
--   with other operations.
--   
--   In the case of GPU execution, this also means that the operation is
--   available to be executed concurrently with other kernels. In
--   particular, consider using this if you have a series of operations
--   that are compute bound rather than memory bound.
--   
--   Here is the synthetic example:
--   
--   <pre>
--   loop :: Exp Int -&gt; Exp Int
--   loop ticks =
--     let clockRate = 900000   -- kHz
--     in  A.while (\i -&gt; i &lt;* clockRate * ticks) (+1) 0
--   
--   test :: Acc (Vector Int)
--   test =
--     A.zip3
--       (compute $ A.map loop (use $ A.fromList (Z:.1) [10]))
--       (compute $ A.map loop (use $ A.fromList (Z:.1) [10]))
--       (compute $ A.map loop (use $ A.fromList (Z:.1) [10]))
--   </pre>
--   
--   Without the use of <a>compute</a>, the operations are fused together
--   and the three long-running loops are executed sequentially in a single
--   kernel. Instead, the individual kernels can now be executed
--   concurrently, reducing overall runtime (on hardware that supports
--   concurrent kernel execution).
compute :: Arrays a => Acc a -> Acc a

-- | Change the shape of an array without altering its contents. The
--   <a>size</a> of the source and result arrays must be identical.
--   
--   <pre>
--   precondition: size ix == size ix'
--   </pre>
reshape :: (Shape ix, Shape ix', Elt e) => Exp ix -> Acc (Array ix' e) -> Acc (Array ix e)

-- | Flattens a given array of arbitrary dimension.
flatten :: (Shape ix, Elt a) => Acc (Array ix a) -> Acc (Vector a)

-- | Forward permutation specified by an index mapping. The result array is
--   initialised with the given defaults and any further values that are
--   permuted into the result array are added to the current value using
--   the given combination function.
--   
--   The combination function must be <i>associative</i> and
--   <i>commutative</i>. Elements that are mapped to the magic value
--   <a>ignore</a> by the permutation function are dropped.
permute :: (Shape ix, Shape ix', Elt a) => (Exp a -> Exp a -> Exp a) -> Acc (Array ix' a) -> (Exp ix -> Exp ix') -> Acc (Array ix a) -> Acc (Array ix' a)

-- | Backward permutation specified by an index mapping from the
--   destination array specifying which element of the source array to
--   read.
backpermute :: (Shape ix, Shape ix', Elt a) => Exp ix' -> (Exp ix' -> Exp ix) -> Acc (Array ix a) -> Acc (Array ix' a)

-- | Magic value identifying elements that are ignored in a forward
--   permutation. Note that this currently does not work for singleton
--   arrays.
ignore :: Shape ix => Exp ix

-- | Reverse the elements of a vector.
reverse :: Elt e => Acc (Vector e) -> Acc (Vector e)

-- | Transpose the rows and columns of a matrix.
transpose :: Elt e => Acc (Array DIM2 e) -> Acc (Array DIM2 e)

-- | Pair each element with its index
indexed :: (Shape sh, Elt a) => Acc (Array sh a) -> Acc (Array sh (sh, a))

-- | Apply the given function element-wise to the given array.
map :: (Shape ix, Elt a, Elt b) => (Exp a -> Exp b) -> Acc (Array ix a) -> Acc (Array ix b)

-- | Apply a function to every element of an array and its index
imap :: (Shape sh, Elt a, Elt b) => (Exp sh -> Exp a -> Exp b) -> Acc (Array sh a) -> Acc (Array sh b)

-- | Apply the given binary function element-wise to the two arrays. The
--   extent of the resulting array is the intersection of the extents of
--   the two source arrays.
zipWith :: (Shape ix, Elt a, Elt b, Elt c) => (Exp a -> Exp b -> Exp c) -> Acc (Array ix a) -> Acc (Array ix b) -> Acc (Array ix c)

-- | Zip three arrays with the given function, analogous to <a>zipWith</a>.
zipWith3 :: (Shape sh, Elt a, Elt b, Elt c, Elt d) => (Exp a -> Exp b -> Exp c -> Exp d) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d)

-- | Zip four arrays with the given function, analogous to <a>zipWith</a>.
zipWith4 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e)

-- | Zip five arrays with the given function, analogous to <a>zipWith</a>.
zipWith5 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f)

-- | Zip six arrays with the given function, analogous to <a>zipWith</a>.
zipWith6 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g)

-- | Zip seven arrays with the given function, analogous to <a>zipWith</a>.
zipWith7 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h)

-- | Zip eight arrays with the given function, analogous to <a>zipWith</a>.
zipWith8 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h -> Exp i) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh i)

-- | Zip nine arrays with the given function, analogous to <a>zipWith</a>.
zipWith9 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i, Elt j) => (Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h -> Exp i -> Exp j) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh i) -> Acc (Array sh j)

-- | Zip two arrays with a function that also takes the elements' index
izipWith :: (Shape sh, Elt a, Elt b, Elt c) => (Exp sh -> Exp a -> Exp b -> Exp c) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c)

-- | Zip three arrays with a function that also takes the elements index,
--   analogous to <a>izipWith</a>.
izipWith3 :: (Shape sh, Elt a, Elt b, Elt c, Elt d) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d)

-- | Zip four arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith4 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e)

-- | Zip five arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith5 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f)

-- | Zip six arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith6 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g)

-- | Zip seven arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith7 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h)

-- | Zip eight arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith8 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h -> Exp i) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh i)

-- | Zip nine arrays with the given function that also takes the elements
--   index, analogous to <a>zipWith</a>.
izipWith9 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i, Elt j) => (Exp sh -> Exp a -> Exp b -> Exp c -> Exp d -> Exp e -> Exp f -> Exp g -> Exp h -> Exp i -> Exp j) -> Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh i) -> Acc (Array sh j)

-- | Combine the elements of two arrays pairwise. The shape of the result
--   is the intersection of the two argument shapes.
zip :: (Shape sh, Elt a, Elt b) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh (a, b))

-- | Take three arrays and return an array of triples, analogous to zip.
zip3 :: (Shape sh, Elt a, Elt b, Elt c) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh (a, b, c))

-- | Take four arrays and return an array of quadruples, analogous to zip.
zip4 :: (Shape sh, Elt a, Elt b, Elt c, Elt d) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh (a, b, c, d))

-- | Take five arrays and return an array of five-tuples, analogous to zip.
zip5 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh (a, b, c, d, e))

-- | Take six arrays and return an array of six-tuples, analogous to zip.
zip6 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh (a, b, c, d, e, f))

-- | Take seven arrays and return an array of seven-tuples, analogous to
--   zip.
zip7 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh (a, b, c, d, e, f, g))

-- | Take seven arrays and return an array of seven-tuples, analogous to
--   zip.
zip8 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh (a, b, c, d, e, f, g, h))

-- | Take seven arrays and return an array of seven-tuples, analogous to
--   zip.
zip9 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i) => Acc (Array sh a) -> Acc (Array sh b) -> Acc (Array sh c) -> Acc (Array sh d) -> Acc (Array sh e) -> Acc (Array sh f) -> Acc (Array sh g) -> Acc (Array sh h) -> Acc (Array sh i) -> Acc (Array sh (a, b, c, d, e, f, g, h, i))

-- | The converse of <a>zip</a>, but the shape of the two results is
--   identical to the shape of the argument.
unzip :: (Shape sh, Elt a, Elt b) => Acc (Array sh (a, b)) -> (Acc (Array sh a), Acc (Array sh b))

-- | Take an array of triples and return three arrays, analogous to unzip.
unzip3 :: (Shape sh, Elt a, Elt b, Elt c) => Acc (Array sh (a, b, c)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c))

-- | Take an array of quadruples and return four arrays, analogous to
--   unzip.
unzip4 :: (Shape sh, Elt a, Elt b, Elt c, Elt d) => Acc (Array sh (a, b, c, d)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d))

-- | Take an array of 5-tuples and return five arrays, analogous to unzip.
unzip5 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e) => Acc (Array sh (a, b, c, d, e)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d), Acc (Array sh e))

-- | Take an array of 6-tuples and return six arrays, analogous to unzip.
unzip6 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f) => Acc (Array sh (a, b, c, d, e, f)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d), Acc (Array sh e), Acc (Array sh f))

-- | Take an array of 7-tuples and return seven arrays, analogous to unzip.
unzip7 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g) => Acc (Array sh (a, b, c, d, e, f, g)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d), Acc (Array sh e), Acc (Array sh f), Acc (Array sh g))

-- | Take an array of 8-tuples and return eight arrays, analogous to unzip.
unzip8 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h) => Acc (Array sh (a, b, c, d, e, f, g, h)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d), Acc (Array sh e), Acc (Array sh f), Acc (Array sh g), Acc (Array sh h))

-- | Take an array of 8-tuples and return eight arrays, analogous to unzip.
unzip9 :: (Shape sh, Elt a, Elt b, Elt c, Elt d, Elt e, Elt f, Elt g, Elt h, Elt i) => Acc (Array sh (a, b, c, d, e, f, g, h, i)) -> (Acc (Array sh a), Acc (Array sh b), Acc (Array sh c), Acc (Array sh d), Acc (Array sh e), Acc (Array sh f), Acc (Array sh g), Acc (Array sh h), Acc (Array sh i))

-- | Drop elements that do not satisfy the predicate
filter :: Elt a => (Exp a -> Exp Bool) -> Acc (Vector a) -> Acc (Vector a)

-- | Copy elements from source array to destination array according to an
--   index mapping. This is a forward-permute operation where a <tt>to</tt>
--   vector encodes an input to output index mapping. Output elements for
--   indices that are not mapped assume the default vector's value.
--   
--   For example:
--   
--   <pre>
--   default = [0, 0, 0, 0, 0, 0, 0, 0, 0]
--   to      = [1, 3, 7, 2, 5, 8]
--   input   = [1, 9, 6, 4, 4, 2, 5]
--   
--   output  = [0, 1, 4, 9, 0, 4, 0, 6, 2]
--   </pre>
--   
--   Note if the same index appears in the index mapping more than once,
--   the result is undefined. It does not makes sense for the <tt>to</tt>
--   vector to be larger than the <tt>input</tt> vector.
scatter :: Elt e => Acc (Vector Int) -> Acc (Vector e) -> Acc (Vector e) -> Acc (Vector e)

-- | Conditionally copy elements from source array to destination array
--   according to an index mapping. This is a forward-permute operation
--   where a <tt>to</tt> vector encodes an input to output index mapping.
--   In addition, there is a <tt>mask</tt> vector, and an associated
--   predicate function. The mapping will only occur if the predicate
--   function applied to the mask at that position resolves to <a>True</a>.
--   If not copied, the output array assumes the default vector's value.
--   
--   For example:
--   
--   <pre>
--   default = [0, 0, 0, 0, 0, 0, 0, 0, 0]
--   to      = [1, 3, 7, 2, 5, 8]
--   mask    = [3, 4, 9, 2, 7, 5]
--   pred    = (&gt;* 4)
--   input   = [1, 9, 6, 4, 4, 2, 5]
--   
--   output  = [0, 0, 0, 0, 0, 4, 0, 6, 2]
--   </pre>
--   
--   Note if the same index appears in the mapping more than once, the
--   result is undefined. The <tt>to</tt> and <tt>mask</tt> vectors must be
--   the same length. It does not make sense for these to be larger than
--   the <tt>input</tt> vector.
scatterIf :: (Elt e, Elt e') => Acc (Vector Int) -> Acc (Vector e) -> (Exp e -> Exp Bool) -> Acc (Vector e') -> Acc (Vector e') -> Acc (Vector e')

-- | Gather elements from a source array at the given indices. For example:
--   
--   <pre>
--   input  = [1, 9, 6, 4, 4, 2, 0, 1, 2]
--   from   = [1, 3, 7, 2, 5, 3]
--   
--   output = [9, 4, 1, 6, 2, 4]
--   </pre>
gather :: (Shape sh, Elt e) => Acc (Array sh Int) -> Acc (Vector e) -> Acc (Array sh e)

-- | Conditionally copy elements from source array to destination array
--   according to an index mapping. This is a backpermute operation where a
--   <tt>from</tt> vector encodes the output to input index mapping. In
--   addition, there is a <tt>mask</tt> vector, and an associated
--   predication function, that specifies whether an element will be
--   copied. If not copied, the output array assumes the default vector's
--   value.
--   
--   For example:
--   
--   <pre>
--   default = [6, 6, 6, 6, 6, 6]
--   from    = [1, 3, 7, 2, 5, 3]
--   mask    = [3, 4, 9, 2, 7, 5]
--   pred    = (&gt;* 4)
--   input   = [1, 9, 6, 4, 4, 2, 0, 1, 2]
--   
--   output  = [6, 6, 1, 6, 2, 4]
--   </pre>
gatherIf :: (Elt a, Elt b) => Acc (Vector Int) -> Acc (Vector a) -> (Exp a -> Exp Bool) -> Acc (Vector b) -> Acc (Vector b) -> Acc (Vector b)

-- | Reduction of the innermost dimension of an array of arbitrary rank.
--   The first argument needs to be an <i>associative</i> function to
--   enable an efficient parallel implementation.
fold :: (Shape ix, Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Array (ix :. Int) a) -> Acc (Array ix a)

-- | Variant of <a>fold</a> that requires the reduced array to be non-empty
--   and doesn't need an default value. The first argument needs to be an
--   <i>associative</i> function to enable an efficient parallel
--   implementation.
fold1 :: (Shape ix, Elt a) => (Exp a -> Exp a -> Exp a) -> Acc (Array (ix :. Int) a) -> Acc (Array ix a)

-- | Reduction of an array of arbitrary rank to a single scalar value.
foldAll :: (Shape sh, Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Array sh a) -> Acc (Scalar a)

-- | Variant of <a>foldAll</a> that requires the reduced array to be
--   non-empty and doesn't need an default value.
fold1All :: (Shape sh, Elt a) => (Exp a -> Exp a -> Exp a) -> Acc (Array sh a) -> Acc (Scalar a)

-- | Segmented reduction along the innermost dimension. Performs one
--   individual reduction per segment of the source array. These reductions
--   proceed in parallel.
--   
--   The source array must have at least rank 1. The <a>Segments</a> array
--   determines the lengths of the logical sub-arrays, each of which is
--   folded separately.
foldSeg :: (Shape ix, Elt a, Elt i, IsIntegral i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Array (ix :. Int) a) -> Acc (Segments i) -> Acc (Array (ix :. Int) a)

-- | Variant of <a>foldSeg</a> that requires <i>all</i> segments of the
--   reduced array to be non-empty and doesn't need a default value.
--   
--   The source array must have at least rank 1. The <a>Segments</a> array
--   determines the lengths of the logical sub-arrays, each of which is
--   folded separately.
fold1Seg :: (Shape ix, Elt a, Elt i, IsIntegral i) => (Exp a -> Exp a -> Exp a) -> Acc (Array (ix :. Int) a) -> Acc (Segments i) -> Acc (Array (ix :. Int) a)

-- | Check if all elements satisfy a predicate
all :: (Shape sh, Elt e) => (Exp e -> Exp Bool) -> Acc (Array sh e) -> Acc (Scalar Bool)

-- | Check if any element satisfies the predicate
any :: (Shape sh, Elt e) => (Exp e -> Exp Bool) -> Acc (Array sh e) -> Acc (Scalar Bool)

-- | Check if all elements are <a>True</a>
and :: Shape sh => Acc (Array sh Bool) -> Acc (Scalar Bool)

-- | Check if any element is <a>True</a>
or :: Shape sh => Acc (Array sh Bool) -> Acc (Scalar Bool)

-- | Compute the sum of elements
sum :: (Shape sh, Elt e, Num e) => Acc (Array sh e) -> Acc (Scalar e)

-- | Compute the product of the elements
product :: (Shape sh, Elt e, Num e) => Acc (Array sh e) -> Acc (Scalar e)

-- | Yield the minimum element of an array. The array must not be empty.
minimum :: (Shape sh, Elt e, Ord e) => Acc (Array sh e) -> Acc (Scalar e)

-- | Yield the maximum element of an array. The array must not be empty.
maximum :: (Shape sh, Elt e, Ord e) => Acc (Array sh e) -> Acc (Scalar e)

-- | Data.List style left-to-right scan, but with the additional
--   restriction that the first argument needs to be an <i>associative</i>
--   function to enable an efficient parallel implementation. The initial
--   value (second argument) may be arbitrary.
scanl :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Data.List style left-to-right scan without an initial value (aka
--   inclusive scan). Again, the first argument needs to be an
--   <i>associative</i> function. Denotationally, we have
--   
--   <pre>
--   scanl1 f e arr = tail (scanl f e arr)
--   </pre>
scanl1 :: Elt a => (Exp a -> Exp a -> Exp a) -> Acc (Vector a) -> Acc (Vector a)

-- | Variant of <a>scanl</a>, where the final result of the reduction is
--   returned separately. Denotationally, we have
--   
--   <pre>
--   scanl' f e arr = (init res, unit (res!len))
--     where
--       len = shape arr
--       res = scanl f e arr
--   </pre>
scanl' :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> (Acc (Vector a), Acc (Scalar a))

-- | Right-to-left variant of <a>scanl</a>.
scanr :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Right-to-left variant of <a>scanl1</a>.
scanr1 :: Elt a => (Exp a -> Exp a -> Exp a) -> Acc (Vector a) -> Acc (Vector a)

-- | Right-to-left variant of <a>scanl'</a>.
scanr' :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> (Acc (Vector a), Acc (Scalar a))

-- | Left-to-right prescan (aka exclusive scan). As for <tt>scan</tt>, the
--   first argument must be an <i>associative</i> function. Denotationally,
--   we have
--   
--   <pre>
--   prescanl f e = Prelude.fst . scanl' f e
--   </pre>
prescanl :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Left-to-right postscan, a variant of <a>scanl1</a> with an initial
--   value. Denotationally, we have
--   
--   <pre>
--   postscanl f e = map (e `f`) . scanl1 f
--   </pre>
postscanl :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Right-to-left prescan (aka exclusive scan). As for <tt>scan</tt>, the
--   first argument must be an <i>associative</i> function. Denotationally,
--   we have
--   
--   <pre>
--   prescanr f e = Prelude.fst . scanr' f e
--   </pre>
prescanr :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Right-to-left postscan, a variant of <a>scanr1</a> with an initial
--   value. Denotationally, we have
--   
--   <pre>
--   postscanr f e = map (e `f`) . scanr1 f
--   </pre>
postscanr :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Vector a)

-- | Segmented version of <a>scanl</a>
scanlSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>scanl1</a>.
--   
--   As with <a>scanl1</a>, the total number of elements considered, in
--   this case given by the <a>sum</a> of segment descriptor, must not be
--   zero. The input vector must contain at least this many elements.
--   
--   Zero length segments are allowed, and the behaviour is as if those
--   entries were not present in the segment descriptor; that is:
--   
--   <pre>
--   scanl1Seg f xs [n,0,0] == scanl1Seg f xs [n]   where n /= 0
--   </pre>
scanl1Seg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>scanl'</a>
--   
--   The first element of the resulting tuple is a vector of scanned
--   values. The second element is a vector of segment scan totals and has
--   the same size as the segment vector.
scanl'Seg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a, Vector a)

-- | Segmented version of <a>prescanl</a>.
prescanlSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>postscanl</a>.
postscanlSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>scanr</a>.
scanrSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>scanr1</a>.
scanr1Seg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>scanr'</a>.
scanr'Seg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a, Vector a)

-- | Segmented version of <a>prescanr</a>.
prescanrSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Segmented version of <a>postscanr</a>.
postscanrSeg :: (Elt a, Elt i, Integral i, Bits i, FromIntegral i Int, FromIntegral Int i) => (Exp a -> Exp a -> Exp a) -> Exp a -> Acc (Vector a) -> Acc (Segments i) -> Acc (Vector a)

-- | Map a stencil over an array. In contrast to <a>map</a>, the domain of
--   a stencil function is an entire <i>neighbourhood</i> of each array
--   element. Neighbourhoods are sub-arrays centred around a focal point.
--   They are not necessarily rectangular, but they are symmetric in each
--   dimension and have an extent of at least three in each dimensions —
--   due to the symmetry requirement, the extent is necessarily odd. The
--   focal point is the array position that is determined by the stencil.
--   
--   For those array positions where the neighbourhood extends past the
--   boundaries of the source array, a boundary condition determines the
--   contents of the out-of-bounds neighbourhood positions.
stencil :: (Shape ix, Elt a, Elt b, Stencil ix a stencil) => (stencil -> Exp b) -> Boundary a -> Acc (Array ix a) -> Acc (Array ix b)

-- | Map a binary stencil of an array. The extent of the resulting array is
--   the intersection of the extents of the two source arrays.
stencil2 :: (Shape ix, Elt a, Elt b, Elt c, Stencil ix a stencil1, Stencil ix b stencil2) => (stencil1 -> stencil2 -> Exp c) -> Boundary a -> Acc (Array ix a) -> Boundary b -> Acc (Array ix b) -> Acc (Array ix c)
collect :: Arrays arrs => Seq arrs -> Acc arrs
streamIn :: Arrays a => [a] -> Seq [a]

-- | Convert the given array to a sequence by dividing the array up into
--   subarrays. The first argument captures how to the division should be
--   performed. The presence of <a>All</a> in the division descriptor
--   indicates that elements in the corresponding dimension should be
--   retained in the subarrays, whereas <a>Split</a> indicates that the
--   input array should divided along this dimension.
toSeq :: (Division slsix, Elt a) => slsix -> Acc (Array (FullShape (DivisionSlice slsix)) a) -> Seq [Array (SliceShape (DivisionSlice slsix)) a]

-- | Generate a scalar sequence of a fixed given length, by applying the
--   given scalar function at each index.
generateSeq :: Elt a => Exp Int -> (Exp Int -> Exp a) -> Seq [Scalar a]

-- | Apply the given array function element-wise to the given sequence.
mapSeq :: (Arrays a, Arrays b) => (Acc a -> Acc b) -> Seq [a] -> Seq [b]

-- | Apply the given binary function element-wise to the two sequences. The
--   length of the resulting sequence is the minumum of the lengths of the
--   two source sequences.
zipWithSeq :: (Arrays a, Arrays b, Arrays c) => (Acc a -> Acc b -> Acc c) -> Seq [a] -> Seq [b] -> Seq [c]

-- | scanSeq (+) a0 x seq. Scan a sequence x by combining each element
--   using the given binary operation (+). (+) must be associative:
--   
--   Forall a b c. (a + b) + c = a + (b + c),
--   
--   and a0 must be the identity element for (+):
--   
--   Forall a. a0 + a = a = a + a0.
scanSeq :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Seq [Scalar a] -> Seq [Scalar a]

-- | foldSeq (+) a0 x seq. Fold a sequence x by combining each element
--   using the given binary operation (+). (+) must be associative:
--   
--   Forall a b c. (a + b) + c = a + (b + c),
--   
--   and a0 must be the identity element for (+):
--   
--   Forall a. a0 + a = a = a + a0.
foldSeq :: Elt a => (Exp a -> Exp a -> Exp a) -> Exp a -> Seq [Scalar a] -> Seq (Scalar a)

-- | foldSeqFlatten f a0 x seq. A specialized version of FoldSeqAct where
--   reduction with the companion operator corresponds to flattening. f
--   must be semi-associative, with vecotor append (++) as the companion
--   operator:
--   
--   Forall b sh1 a1 sh2 a2. f (f b sh1 a1) sh2 a2 = f b (sh1 ++ sh2) (a1
--   ++ a2).
--   
--   It is common to ignore the shape vectors, yielding the usual
--   semi-associativity law:
--   
--   f b a _ = b + a,
--   
--   for some (+) satisfying:
--   
--   Forall b a1 a2. (b + a1) + a2 = b + (a1 ++ a2).
foldSeqFlatten :: (Arrays a, Shape jx, Elt b) => (Acc a -> Acc (Vector jx) -> Acc (Vector b) -> Acc a) -> Acc a -> Seq [Array jx b] -> Seq a

-- | Reduce a sequence by appending all the shapes and all the elements in
--   two separate vectors.
fromSeq :: (Shape ix, Elt a) => Seq [Array ix a] -> Seq (Vector ix, Vector a)
fromSeqElems :: (Shape ix, Elt a) => Seq [Array ix a] -> Seq (Vector a)
fromSeqShapes :: (Shape ix, Elt a) => Seq [Array ix a] -> Seq (Vector ix)

-- | Sequence an array on the innermost dimension.
toSeqInner :: (Shape sh, Elt a) => Acc (Array (sh :. Int) a) -> Seq [Array sh a]

-- | Sequence a 2-dimensional array on the outermost dimension.
toSeqOuter2 :: Elt a => Acc (Array DIM2 a) -> Seq [Array DIM1 a]

-- | Sequence a 3-dimensional array on the outermost dimension.
toSeqOuter3 :: Elt a => Acc (Array DIM3 a) -> Seq [Array DIM2 a]
class (Elt (StencilRepr sh stencil), Stencil sh a (StencilRepr sh stencil)) => Stencil sh a stencil

-- | Boundary condition specification for stencil operations.
data Boundary a

-- | clamp coordinates to the extent of the array
Clamp :: Boundary a

-- | mirror coordinates beyond the array extent
Mirror :: Boundary a

-- | wrap coordinates around on each dimension
Wrap :: Boundary a

-- | use a constant value for outlying coordinates
Constant :: a -> Boundary a
type Stencil3 a = (Exp a, Exp a, Exp a)
type Stencil5 a = (Exp a, Exp a, Exp a, Exp a, Exp a)
type Stencil7 a = (Exp a, Exp a, Exp a, Exp a, Exp a, Exp a, Exp a)
type Stencil9 a = (Exp a, Exp a, Exp a, Exp a, Exp a, Exp a, Exp a, Exp a, Exp a)
type Stencil3x3 a = (Stencil3 a, Stencil3 a, Stencil3 a)
type Stencil5x3 a = (Stencil5 a, Stencil5 a, Stencil5 a)
type Stencil3x5 a = (Stencil3 a, Stencil3 a, Stencil3 a, Stencil3 a, Stencil3 a)
type Stencil5x5 a = (Stencil5 a, Stencil5 a, Stencil5 a, Stencil5 a, Stencil5 a)
type Stencil3x3x3 a = (Stencil3x3 a, Stencil3x3 a, Stencil3x3 a)
type Stencil5x3x3 a = (Stencil5x3 a, Stencil5x3 a, Stencil5x3 a)
type Stencil3x5x3 a = (Stencil3x5 a, Stencil3x5 a, Stencil3x5 a)
type Stencil3x3x5 a = (Stencil3x3 a, Stencil3x3 a, Stencil3x3 a, Stencil3x3 a, Stencil3x3 a)
type Stencil5x5x3 a = (Stencil5x5 a, Stencil5x5 a, Stencil5x5 a)
type Stencil5x3x5 a = (Stencil5x3 a, Stencil5x3 a, Stencil5x3 a, Stencil5x3 a, Stencil5x3 a)
type Stencil3x5x5 a = (Stencil3x5 a, Stencil3x5 a, Stencil3x5 a, Stencil3x5 a, Stencil3x5 a)
type Stencil5x5x5 a = (Stencil5x5 a, Stencil5x5 a, Stencil5x5 a, Stencil5x5 a, Stencil5x5 a)

-- | Call a foreign array function.
--   
--   The form the first argument takes is dependent on the backend being
--   targeted. Note that the foreign function only has access to the input
--   array(s) passed in as its argument.
--   
--   In case the operation is being executed on a backend which does not
--   support this foreign implementation, the fallback implementation is
--   used instead, which itself could be a foreign implementation for a
--   (presumably) different backend, or an implementation of pure
--   Accelerate. In this way, multiple foreign implementations can be
--   supplied, and will be tested for suitability against the target
--   backend in sequence.
foreignAcc :: (Arrays as, Arrays bs, Foreign asm) => asm (as -> bs) -> (Acc as -> Acc bs) -> Acc as -> Acc bs

-- | Call a foreign scalar expression.
--   
--   The form of the first argument is dependent on the backend being
--   targeted. Note that the foreign function only has access to the input
--   element(s) passed in as its first argument.
--   
--   As with <a>foreignAcc</a>, the fallback implementation itself may be a
--   (sequence of) foreign implementation(s) for a different backend(s), or
--   implemented purely in Accelerate.
foreignExp :: (Elt x, Elt y, Foreign asm) => asm (x -> y) -> (Exp x -> Exp y) -> Exp x -> Exp y

-- | Scalar expressions for plain array computations.
data Exp t

-- | The <a>Eq</a> class defines equality <a>==*</a> and inequality
--   <a>/=*</a> for scalar Accelerate expressions.
--   
--   For convenience, we include <a>Elt</a> as a superclass.
class Elt a => Eq a where x ==* y = mkLNot (x /=* y) x /=* y = mkLNot (x ==* y)
(==*) :: Eq a => Exp a -> Exp a -> Exp Bool
(/=*) :: Eq a => Exp a -> Exp a -> Exp Bool

-- | The <a>Ord</a> class for totally ordered datatypes
class Eq a => Ord a where x <* y = x /=* y &&* x <=* y x >* y = not (x <=* y) x <=* y = not (x >* y) x >=* y = x ==* y ||* not (x <=* y) min x y = Exp $ Cond (x <=* y) x y max x y = Exp $ Cond (x <=* y) y x
(<*) :: Ord a => Exp a -> Exp a -> Exp Bool
(>*) :: Ord a => Exp a -> Exp a -> Exp Bool
(<=*) :: Ord a => Exp a -> Exp a -> Exp Bool
(>=*) :: Ord a => Exp a -> Exp a -> Exp Bool
min :: Ord a => Exp a -> Exp a -> Exp a
max :: Ord a => Exp a -> Exp a -> Exp a

-- | Name the upper and lower limits of a type. Types which are not totally
--   ordered may still have upper and lower bounds.
type Bounded a = (Elt a, Bounded (Exp a))
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Basic numeric class
type Num a = (Elt a, Num (Exp a))
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Integral numbers, supporting integral division
type Integral a = (Enum a, Real a, Integral (Exp a))

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | Fractional numbers, supporting real division
type Fractional a = (Num a, Fractional (Exp a))

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a

-- | Trigonometric and hyperbolic functions and related functions
type Floating a = (Fractional a, Floating (Exp a))
pi :: Floating a => a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
exp :: Floating a => a -> a
sqrt :: Floating a => a -> a
log :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a
properFraction :: (RealFrac a, Num b, ToFloating b a, IsIntegral b) => Exp a -> (Exp b, Exp a)

-- | <tt>truncate x</tt> returns the integer nearest <tt>x</tt> between
--   zero and <tt>x</tt>
truncate :: (RealFrac a, Elt b, IsIntegral b) => Exp a -> Exp b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Elt b, IsIntegral b) => Exp a -> Exp b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Elt b, IsIntegral b) => Exp a -> Exp b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Elt b, IsIntegral b) => Exp a -> Exp b

-- | Efficient, machine-independent access to the components of a
--   floating-point number
class (RealFrac a, Floating a) => RealFloat a where floatRadix _ = fromInteger (floatRadix (undefined :: a)) floatDigits _ = constant (floatDigits (undefined :: a)) floatRange _ = let (m, n) = floatRange (undefined :: a) in (constant m, constant n) isIEEE _ = constant (isIEEE (undefined :: Float)) decodeFloat = \ format_abQLs kind_abQLt fn_abQLu msg_abQLv -> error (format_abQLs kind_abQLt (call fn_abQLu msg_abQLv)) (\ kind_abQLw msg_abQLx -> message kind_abQLw ("Data/Array/Accelerate/Classes/RealFloat.hs:100:21: " ++ msg_abQLx)) Internal "RealFloat.decodeFloat" "Not implemented yet" encodeFloat = \ format_abQLB kind_abQLC fn_abQLD msg_abQLE -> error (format_abQLB kind_abQLC (call fn_abQLD msg_abQLE)) (\ kind_abQLF msg_abQLG -> message kind_abQLF ("Data/Array/Accelerate/Classes/RealFloat.hs:101:21: " ++ msg_abQLG)) Internal "RealFloat.encodeFloat" "Not implemented yet" exponent = \ format_abQLK kind_abQLL fn_abQLM msg_abQLN -> error (format_abQLK kind_abQLL (call fn_abQLM msg_abQLN)) (\ kind_abQLO msg_abQLP -> message kind_abQLO ("Data/Array/Accelerate/Classes/RealFloat.hs:102:21: " ++ msg_abQLP)) Internal "RealFloat.exponent" "Not implemented yet" significand = \ format_abQLT kind_abQLU fn_abQLV msg_abQLW -> error (format_abQLT kind_abQLU (call fn_abQLV msg_abQLW)) (\ kind_abQLX msg_abQLY -> message kind_abQLX ("Data/Array/Accelerate/Classes/RealFloat.hs:103:21: " ++ msg_abQLY)) Internal "RealFloat.significand" "Not implemented yet" scaleFloat = \ format_abQM2 kind_abQM3 fn_abQM4 msg_abQM5 -> error (format_abQM2 kind_abQM3 (call fn_abQM4 msg_abQM5)) (\ kind_abQM6 msg_abQM7 -> message kind_abQM6 ("Data/Array/Accelerate/Classes/RealFloat.hs:104:21: " ++ msg_abQM7)) Internal "RealFloat.scaleFloat" "Not implemented yet" isInfinite = \ format_abQMb kind_abQMc fn_abQMd msg_abQMe -> error (format_abQMb kind_abQMc (call fn_abQMd msg_abQMe)) (\ kind_abQMf msg_abQMg -> message kind_abQMf ("Data/Array/Accelerate/Classes/RealFloat.hs:105:21: " ++ msg_abQMg)) Internal "RealFloat.isInfinite" "Not implemented yet" isDenormalized = \ format_abQMk kind_abQMl fn_abQMm msg_abQMn -> error (format_abQMk kind_abQMl (call fn_abQMm msg_abQMn)) (\ kind_abQMo msg_abQMp -> message kind_abQMo ("Data/Array/Accelerate/Classes/RealFloat.hs:106:21: " ++ msg_abQMp)) Internal "RealFloat.isDenormalized" "Not implemented yet" isNegativeZero = \ format_abQMt kind_abQMu fn_abQMv msg_abQMw -> error (format_abQMt kind_abQMu (call fn_abQMv msg_abQMw)) (\ kind_abQMx msg_abQMy -> message kind_abQMx ("Data/Array/Accelerate/Classes/RealFloat.hs:107:21: " ++ msg_abQMy)) Internal "RealFloat.isNegativeZero" "Not implemented yet"

-- | The radix of the representation (often 2) (constant)
floatRadix :: RealFloat a => Exp a -> Exp Int64

-- | The number of digits of <a>floatRadix</a> in the significand
--   (constant)
floatDigits :: RealFloat a => Exp a -> Exp Int

-- | The lowest and highest values the exponent may assume (constant)
floatRange :: RealFloat a => Exp a -> (Exp Int, Exp Int)

-- | Return the significand and an appropriately scaled exponent. if
--   <tt>(m,n) = <a>decodeFloat</a> x</tt> then <tt>x = m*b^^n</tt>, where
--   <tt>b</tt> is the floating-point radix (<a>floatRadix</a>).
--   Furthermore, either <tt>m</tt> and <tt>n</tt> are both zero, or
--   <tt>b^(d-1) &lt;= <tt>abs</tt> m &lt; b^d</tt>, where <tt>d =
--   <a>floatDigits</a> x</tt>.
decodeFloat :: RealFloat a => Exp a -> (Exp Int64, Exp Int)

-- | Inverse of <a>decodeFloat</a>
encodeFloat :: RealFloat a => Exp Int64 -> Exp Int -> Exp a

-- | Corresponds to the second component of <a>decodeFloat</a>
exponent :: RealFloat a => Exp a -> Exp Int

-- | Corresponds to the first component of <a>decodeFloat</a>
significand :: RealFloat a => Exp a -> Exp a

-- | Multiply a floating point number by an integer power of the radix
scaleFloat :: RealFloat a => Exp Int -> Exp a -> Exp a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => Exp a -> Exp Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative-infinity
isInfinite :: RealFloat a => Exp a -> Exp Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => Exp a -> Exp Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => Exp a -> Exp Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => Exp a -> Exp Bool

-- | A version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>].
atan2 :: RealFloat a => Exp a -> Exp a -> Exp a

-- | Accelerate lacks a most-general lossless <a>Integer</a> type, which
--   the standard <a>fromIntegral</a> function uses as an intermediate
--   value when coercing from integral types. Instead, we use this class to
--   capture a direct coercion between two types.
class FromIntegral a b

-- | General coercion from integral types
fromIntegral :: (FromIntegral a b, Integral a) => Exp a -> Exp b

-- | Accelerate lacks an arbitrary-precision <a>Rational</a> type, which
--   the standard <a>realToFrac</a> uses as an intermediate value when
--   coercing to floating-point types. Instead, we use this class to
--   capture a direct coercion between to types.
class ToFloating a b

-- | General coercion to floating types
toFloating :: (ToFloating a b, Num a, Floating b) => Exp a -> Exp b

-- | All scalar types
class Typeable a => IsScalar a

-- | Numeric types
class (Num a, IsScalar a) => IsNum a

-- | Bounded types
class IsBounded a

-- | Integral types
class (IsScalar a, IsNum a, IsBounded a) => IsIntegral a

-- | Floating types
class (Floating a, IsScalar a, IsNum a) => IsFloating a

-- | Non-numeric types
class IsNonNum a

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | 8-bit signed integer type
data Int8 :: *

-- | 16-bit signed integer type
data Int16 :: *

-- | 32-bit signed integer type
data Int32 :: *

-- | 64-bit signed integer type
data Int64 :: *

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word :: *

-- | 8-bit unsigned integer type
data Word8 :: *

-- | 16-bit unsigned integer type
data Word16 :: *

-- | 32-bit unsigned integer type
data Word32 :: *

-- | 64-bit unsigned integer type
data Word64 :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
data Bool :: *
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | Haskell type representing the C <tt>float</tt> type.
data CFloat :: *

-- | Haskell type representing the C <tt>double</tt> type.
data CDouble :: *

-- | Haskell type representing the C <tt>short</tt> type.
data CShort :: *

-- | Haskell type representing the C <tt>unsigned short</tt> type.
data CUShort :: *

-- | Haskell type representing the C <tt>int</tt> type.
data CInt :: *

-- | Haskell type representing the C <tt>unsigned int</tt> type.
data CUInt :: *

-- | Haskell type representing the C <tt>long</tt> type.
data CLong :: *

-- | Haskell type representing the C <tt>unsigned long</tt> type.
data CULong :: *

-- | Haskell type representing the C <tt>long long</tt> type.
data CLLong :: *

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
data CULLong :: *

-- | Haskell type representing the C <tt>char</tt> type.
data CChar :: *

-- | Haskell type representing the C <tt>signed char</tt> type.
data CSChar :: *

-- | Haskell type representing the C <tt>unsigned char</tt> type.
data CUChar :: *

-- | The class of types <tt>e</tt> which can be lifted into <tt>c</tt>.
class Lift c e where type family Plain e

-- | Lift the given value into a surface type <tt>c</tt> --- either
--   <a>Exp</a> for scalar expressions or <a>Acc</a> for array
--   computations. The value may already contain subexpressions in
--   <tt>c</tt>.
lift :: Lift c e => e -> c (Plain e)

-- | A limited subset of types which can be lifted, can also be unlifted.
class Lift c e => Unlift c e

-- | Unlift the outermost constructor through the surface type. This is
--   only possible if the constructor is fully determined by its type -
--   i.e., it is a singleton.
unlift :: Unlift c e => c (Plain e) -> e

-- | Lift a unary function into <a>Exp</a>.
lift1 :: (Unlift Exp a, Lift Exp b) => (a -> b) -> Exp (Plain a) -> Exp (Plain b)

-- | Lift a binary function into <a>Exp</a>.
lift2 :: (Unlift Exp a, Unlift Exp b, Lift Exp c) => (a -> b -> c) -> Exp (Plain a) -> Exp (Plain b) -> Exp (Plain c)

-- | Lift a ternary function into <a>Exp</a>.
lift3 :: (Unlift Exp a, Unlift Exp b, Unlift Exp c, Lift Exp d) => (a -> b -> c -> d) -> Exp (Plain a) -> Exp (Plain b) -> Exp (Plain c) -> Exp (Plain d)

-- | Lift a unary function to a computation over rank-1 indices.
ilift1 :: (Exp Int -> Exp Int) -> Exp DIM1 -> Exp DIM1

-- | Lift a binary function to a computation over rank-1 indices.
ilift2 :: (Exp Int -> Exp Int -> Exp Int) -> Exp DIM1 -> Exp DIM1 -> Exp DIM1

-- | Lift a ternary function to a computation over rank-1 indices.
ilift3 :: (Exp Int -> Exp Int -> Exp Int -> Exp Int) -> Exp DIM1 -> Exp DIM1 -> Exp DIM1 -> Exp DIM1

-- | Scalar expression inlet: make a Haskell value available for processing
--   in an Accelerate scalar expression.
--   
--   Note that this embeds the value directly into the expression.
--   Depending on the backend used to execute the computation, this might
--   not always be desirable. For example, a backend that does external
--   code generation may embed this constant directly into the generated
--   code, which means new code will need to be generated and compiled
--   every time the value changes. In such cases, consider instead lifting
--   scalar values into (singleton) arrays so that they can be passed as an
--   input to the computation and thus the value can change without the
--   need to generate fresh code.
constant :: Elt t => t -> Exp t

-- | Extract the first component of a scalar pair.
fst :: (Elt a, Elt b) => Exp (a, b) -> Exp a

-- | Extract the first component of an array pair.
afst :: (Arrays a, Arrays b) => Acc (a, b) -> Acc a

-- | Extract the second component of a scalar pair.
snd :: (Elt a, Elt b) => Exp (a, b) -> Exp b

-- | Extract the second component of an array pair
asnd :: (Arrays a, Arrays b) => Acc (a, b) -> Acc b

-- | Converts an uncurried function to a curried function.
curry :: Lift f (f a, f b) => (f (Plain (f a), Plain (f b)) -> f c) -> f a -> f b -> f c

-- | Converts a curried function to a function on pairs.
uncurry :: Unlift f (f a, f b) => (f a -> f b -> f c) -> f (Plain (f a), Plain (f b)) -> f c

-- | An infix version of <a>cond</a>. If the predicate evaluates to
--   <a>True</a>, the first component of the tuple is returned, else the
--   second.
--   
--   See also: <a>ifThenElse</a>.
(?) :: Elt t => Exp Bool -> (Exp t, Exp t) -> Exp t

-- | A case-like control structure
caseof :: (Elt a, Elt b) => Exp a -> [(Exp a -> Exp Bool, Exp b)] -> Exp b -> Exp b

-- | A scalar-level if-then-else construct.
cond :: Elt t => Exp Bool -> Exp t -> Exp t -> Exp t

-- | While construct. Continue to apply the given function, starting with
--   the initial value, until the test function evaluates to <a>False</a>.
while :: Elt e => (Exp e -> Exp Bool) -> (Exp e -> Exp e) -> Exp e -> Exp e

-- | Repeatedly apply a function a fixed number of times
iterate :: Elt a => Exp Int -> (Exp a -> Exp a) -> Exp a -> Exp a

-- | Reduce along an innermost slice of an array <i>sequentially</i>, by
--   applying a binary operator to a starting value and the array from left
--   to right.
sfoldl :: (Shape sh, Slice sh, Elt a, Elt b) => (Exp a -> Exp b -> Exp a) -> Exp a -> Exp sh -> Acc (Array (sh :. Int) b) -> Exp a

-- | Conjunction: True if both arguments are true. This is a short-circuit
--   operator, so the second argument will be evaluate only if the first is
--   true.
(&&*) :: Exp Bool -> Exp Bool -> Exp Bool

-- | Disjunction: True if either argument is true. This is a short-circuit
--   operator, so the second argument will be evaluated only if the first
--   is false.
(||*) :: Exp Bool -> Exp Bool -> Exp Bool

-- | Logical negation
not :: Exp Bool -> Exp Bool

-- | <a>subtract</a> is the same as <tt><tt>flip</tt> (<a>-</a>)</tt>.
subtract :: Num a => Exp a -> Exp a -> Exp a

-- | Determine if a number is even
even :: Integral a => Exp a -> Exp Bool

-- | Determine if a number is odd
odd :: Integral a => Exp a -> Exp Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of both <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example:
--   
--   <pre>
--   &gt;&gt;&gt; gcd 4 2 = 2
--   
--   &gt;&gt;&gt; gcd (-4) 6 = 2
--   
--   &gt;&gt;&gt; gcd 0 4 = 4
--   
--   &gt;&gt;&gt; gcd 0 0 = 0
--   </pre>
--   
--   That is, the common divisor that is "greatest" in the divisibility
--   preordering.
gcd :: Integral a => Exp a -> Exp a -> Exp a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => Exp a -> Exp a -> Exp a

-- | The one index for a rank-0 array.
index0 :: Exp Z

-- | Turn an <a>Int</a> expression into a rank-1 indexing expression.
index1 :: Elt i => Exp i -> Exp (Z :. i)

-- | Turn a rank-1 indexing expression into an <a>Int</a> expression.
unindex1 :: Elt i => Exp (Z :. i) -> Exp i

-- | Creates a rank-2 index from two Exp Int`s
index2 :: (Elt i, Slice (Z :. i)) => Exp i -> Exp i -> Exp ((Z :. i) :. i)

-- | Destructs a rank-2 index to an Exp tuple of two Int`s.
unindex2 :: (Elt i, Slice (Z :. i)) => Exp ((Z :. i) :. i) -> Exp (i, i)

-- | Create a rank-3 index from three Exp Int`s
index3 :: (Elt i, Slice (Z :. i), Slice ((Z :. i) :. i)) => Exp i -> Exp i -> Exp i -> Exp (((Z :. i) :. i) :. i)

-- | Destruct a rank-3 index into an Exp tuple of Int`s
unindex3 :: (Elt i, Slice (Z :. i), Slice ((Z :. i) :. i)) => Exp (((Z :. i) :. i) :. i) -> Exp (i, i, i)

-- | Get the outermost dimension of a shape
indexHead :: (Slice sh, Elt a) => Exp (sh :. a) -> Exp a

-- | Get all but the outermost element of a shape
indexTail :: (Slice sh, Elt a) => Exp (sh :. a) -> Exp sh

-- | Map a multi-dimensional index into a linear, row-major representation
--   of an array. The first argument is the array shape, the second is the
--   index.
toIndex :: Shape sh => Exp sh -> Exp sh -> Exp Int

-- | Inverse of <a>toIndex</a>
fromIndex :: Shape sh => Exp sh -> Exp Int -> Exp sh

-- | Intersection of two shapes
intersect :: Shape sh => Exp sh -> Exp sh -> Exp sh

-- | Convert a character to an <a>Int</a>.
ord :: Exp Char -> Exp Int

-- | Convert an <a>Int</a> into a character.
chr :: Exp Int -> Exp Char

-- | Convert a Boolean value to an <a>Int</a>, where <a>False</a> turns
--   into '0' and <a>True</a> into '1'.
boolToInt :: Exp Bool -> Exp Int

-- | Reinterpret a value as another type. The two representations must have
--   the same bit size.
bitcast :: (Elt a, Elt b, IsScalar a, IsScalar b, BitSizeEq a b) => Exp a -> Exp b

-- | Rank of an array.
arrayRank :: Shape sh => sh -> Int

-- | Array shape in plain Haskell code.
arrayShape :: Shape sh => Array sh e -> sh

-- | Total number of elements in an array of the given <a>Shape</a>.
arraySize :: Shape sh => sh -> Int

-- | Array indexing in plain Haskell code.
indexArray :: Array sh e -> sh -> e

-- | Create an array from its representation function.
fromFunction :: (Shape sh, Elt e) => sh -> (sh -> e) -> Array sh e

-- | Convert a list, with elements in row-major order, into an accelerated
--   array.
fromList :: (Shape sh, Elt e) => sh -> [e] -> Array sh e

-- | Convert an accelerated array to a list in row-major order.
toList :: Array sh e -> [e]

-- | Convert an <a>IArray</a> to an accelerated array.
--   
--   While the type signature mentions Accelerate internals that are not
--   exported, in practice satisfying the type equality is straight
--   forward. The index type <tt>ix</tt> must be the unit type <tt>()</tt>
--   for singleton arrays, or an <tt>Int</tt> or tuple of <tt>Int</tt>'s
--   for multidimensional arrays.
fromIArray :: (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray a e, Ix ix, Shape sh, Elt ix, Elt e) => a ix e -> Array sh e

-- | Convert an accelerated array to an <a>IArray</a>.
toIArray :: (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray a e, Ix ix, Shape sh, Elt ix, Elt e) => Array sh e -> a ix e

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

-- | <a>error</a> stops execution and displays an error message.
error :: [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: a
