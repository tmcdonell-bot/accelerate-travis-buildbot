-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFI bindings to CUDA Solver, a LAPACK-like library
--   
--   The cuSolver library provides useful LAPACK-like features implemented
--   on NVIDIA GPUs, such as common matrix factorization and triangular
--   solve routines for dense matrices, a sparse least-squares solver
--   routine, and an eigenvalue solver. This package provides FFI bindings
--   to the functions of the cuSolver library. You will need to install the
--   CUDA driver and developer toolkit:
--   
--   <a>http://developer.nvidia.com/cuda-downloads</a>
--   
--   See the <a>travis-ci.org</a> build matrix for tested CUDA library
--   versions.
@package cusolver
@version 0.1.0.1


module Foreign.CUDA.Solver.Error

-- | Error codes used by cuSolver library functions
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverSPstatus</a>
data Status
Success :: Status
NotInitialized :: Status
AllocFailed :: Status
InvalidValue :: Status
ArchMismatch :: Status
MappingError :: Status
ExecutionFailed :: Status
InternalError :: Status
MatrixTypeNotSupported :: Status
NotSupported :: Status
ZeroPivot :: Status
InvalidLicense :: Status
describe :: Status -> String
data CUSolverException
ExitCode :: Status -> CUSolverException
UserError :: String -> CUSolverException

-- | Raise a CUSolverException in the IO Monad
cusolverError :: String -> IO a

-- | Return the results of a function on successful execution, otherwise
--   throw an exception with an error string associated with the return
--   code
resultIfOk :: (Status, a) -> IO a

-- | Throw an exception with an error string associated with an
--   unsuccessful return code, otherwise return unit.
nothingIfOk :: Status -> IO ()

-- | Throw an error if given error code is not CUSPARSE_STATUS_SUCCESS
checkStatus :: CInt -> IO ()
instance GHC.Show.Show Foreign.CUDA.Solver.Error.Status
instance GHC.Classes.Eq Foreign.CUDA.Solver.Error.Status
instance GHC.Exception.Exception Foreign.CUDA.Solver.Error.CUSolverException
instance GHC.Show.Show Foreign.CUDA.Solver.Error.CUSolverException
instance GHC.Enum.Enum Foreign.CUDA.Solver.Error.Status


module Foreign.CUDA.Solver.Dense.Context

-- | An opaque handle to the cuSolverDN context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDNhandle</a>
newtype Handle
Handle :: ((Ptr ())) -> Handle
[useHandle] :: Handle -> ((Ptr ()))

-- | This function initializes the cuSolverDN library and creates a handle
--   to the cuSolverDN context. It must be called before any other
--   cuSolverDN API function is invoked. It allocates hardware resources
--   necessary for accessing the GPU.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDNcreate</a>
create :: IO ((Handle))

-- | This function releases resources used by the cuSolverDN library.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDNdestroy</a>
destroy :: (Handle) -> IO ((()))


module Foreign.CUDA.Solver.Dense.Stream

-- | Sets the execution stream which all subsequent cuSolverDn library
--   functions will execute with. If not set, functions execute in the
--   default stream (which never overlaps any other operations).
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cudssetstream</a>
setStream :: (Handle) -> (Stream) -> IO ((()))


-- | For more information see the cuSolver function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuds-linearsolver-reference</a>
module Foreign.CUDA.Solver.Dense.Linear

-- | An opaque handle to the cuSolverDN context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDNhandle</a>
data Handle

-- | Indicates which part, upper or lower, of a dense matrix was filled and
--   consequently should be used by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasfillmode_t</a>
data Fill :: *
Lower :: Fill
Upper :: Fill

-- | Indicates whether the dense matrix is on the lift or right side in the
--   matrix equation solved by a particular function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassidemode_t</a>
data Side :: *
Left :: Side
Right :: Side
spotrf_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dpotrf_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((Int))
cpotrf_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zpotrf_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))
spotrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dpotrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cpotrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zpotrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
spotrs :: (Handle) -> (Fill) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dpotrs :: (Handle) -> (Fill) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cpotrs :: (Handle) -> (Fill) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zpotrs :: (Handle) -> (Fill) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sgetrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dgetrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((Int))
cgetrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zgetrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))
sgetrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> IO ()
dgetrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> IO ()
cgetrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> IO ()
zgetrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> IO ()
sgetrs :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dgetrs :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cgetrs :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zgetrs :: (Handle) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sgeqrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dgeqrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((Int))
cgeqrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zgeqrf_bufferSize :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))
sgeqrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dgeqrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cgeqrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zgeqrf :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sormqr :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dormqr :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cunmqr :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zunmqr :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
ssytrf_bufferSize :: (Handle) -> (Int) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dsytrf_bufferSize :: (Handle) -> (Int) -> (DevicePtr Double) -> (Int) -> IO ((Int))
csytrf_bufferSize :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zsytrf_bufferSize :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))
ssytrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dsytrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
csytrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zsytrf :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sorgqr_bufferSize :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dorgqr_bufferSize :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
cungqr_bufferSize :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zungqr_bufferSize :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
sorgqr :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dorgqr :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cungqr :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zungqr :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sormqr_bufferSize :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dormqr_bufferSize :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> IO ((Int))
cunmqr_bufferSize :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zunmqr_bufferSize :: (Handle) -> (Side) -> (Operation) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))


-- | For more information see the cuSolver function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuds-eigensolver-reference</a>
module Foreign.CUDA.Solver.Dense.Eigenvalue

-- | An opaque handle to the cuSolverDN context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDNhandle</a>
data Handle

-- | Indicates which part, upper or lower, of a dense matrix was filled and
--   consequently should be used by the function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasfillmode_t</a>
data Fill :: *
Lower :: Fill
Upper :: Fill

-- | Indicates whether the dense matrix is on the lift or right side in the
--   matrix equation solved by a particular function.
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublassidemode_t</a>
data Side :: *
Left :: Side
Right :: Side

-- | Indicates which operation needs to be performed with a dense matrix.
--   
--   <ul>
--   <li><tt>N</tt>: no transpose selected</li>
--   <li><tt>T</tt>: transpose operation</li>
--   <li><tt>C</tt>: conjugate transpose</li>
--   </ul>
--   
--   <a>http://docs.nvidia.com/cuda/cublas/index.html#cublasoperation_t</a>
data Operation :: *
N :: Operation
T :: Operation
C :: Operation

-- | This type indicates whether eigenvectors are computed.
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusolverEigMode</a>
data EigMode
NoVector :: EigMode
Vector :: EigMode

-- | This type indicates which type of eigenvalue solver is used. It
--   corresponds to the parameters used by legacy LAPACK implementations:
--   
--   <ul>
--   <li><tt>EigType1</tt>: &lt;math&gt;</li>
--   <li><tt>EigType2</tt>: &lt;math&gt;</li>
--   <li><tt>EigType3</tt>: &lt;math&gt;</li>
--   </ul>
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusolverEigType</a>
data EigType
EigType1 :: EigType
EigType2 :: EigType
EigType3 :: EigType
sgebrd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
dgebrd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
cgebrd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
zgebrd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
sgebrd :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dgebrd :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cgebrd :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zgebrd :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sgesvd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
dgesvd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
cgesvd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
zgesvd_bufferSize :: (Handle) -> (Int) -> (Int) -> IO ((Int))
sgesvd :: (Handle) -> (Char) -> (Char) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Int32) -> IO ()
dgesvd :: (Handle) -> (Char) -> (Char) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Int32) -> IO ()
cgesvd :: (Handle) -> (Char) -> (Char) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> IO ()
zgesvd :: (Handle) -> (Char) -> (Char) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> IO ()
sorgbr_bufferSize :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dorgbr_bufferSize :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
cungbr_bufferSize :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zungbr_bufferSize :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
sorgbr :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dorgbr :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cungbr :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zungbr :: (Handle) -> (Side) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
ssytrd_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> IO ((Int))
dsytrd_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> IO ((Int))
chetrd_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> IO ((Int))
zhetrd_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> IO ((Int))
ssytrd :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dsytrd :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
chetrd :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zhetrd :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sormtr_bufferSize :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> IO ((Int))
dormtr_bufferSize :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> IO ((Int))
cunmtr_bufferSize :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> IO ((Int))
zunmtr_bufferSize :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> IO ((Int))
sormtr :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dormtr :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cunmtr :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zunmtr :: (Handle) -> (Side) -> (Fill) -> (Operation) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
sorgtr_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dorgtr_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
cungtr_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zungtr_bufferSize :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
sorgtr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dorgtr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cungtr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zungtr :: (Handle) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
ssyevd_bufferSize :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dsyevd_bufferSize :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
cheevd_bufferSize :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zheevd_bufferSize :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
ssyevd :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dsyevd :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
cheevd :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zheevd :: (Handle) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()
ssygvd_bufferSize :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dsygvd_bufferSize :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
chegvd_bufferSize :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zhegvd_bufferSize :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
ssygvd :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (DevicePtr Int32) -> IO ()
dsygvd :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (DevicePtr Int32) -> IO ()
chegvd :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (DevicePtr Int32) -> IO ()
zhegvd :: (Handle) -> (EigType) -> (EigMode) -> (Fill) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (DevicePtr Int32) -> IO ()


-- | The cuSolver library provides useful LAPACK-like features implemented
--   on NVIDIA GPUs. This module implements a subset of LAPACK functions on
--   dense matrices.
--   
--   To use operations from the cuSolver library, the user must allocate
--   the required vectors and matrices in the GPU memory space, fill them
--   with data, call the desired sequence of cuSolver functions, then copy
--   the results from the GPU memory space back to the host.
--   
--   The <a>cuda</a> package can be used for writing to and retrieving data
--   from the GPU.
--   
--   <ul>
--   <li><i><i>Example</i></i></li>
--   </ul>
--   
--   <i>TODO</i>
--   
--   <ul>
--   <li><i><i>Additional information</i></i></li>
--   </ul>
--   
--   For more information, see the NVIDIA cuSolver documentation:
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html</a>
module Foreign.CUDA.Solver.Dense


module Foreign.CUDA.Solver.Sparse.Analysis
newtype Info_csrqr
Info_csrqr :: ((Ptr ())) -> Info_csrqr
[useInfo_csrqr] :: Info_csrqr -> ((Ptr ()))
createInfo_csrqr :: IO ((Info_csrqr))
destroyInfo_csrqr :: (Info_csrqr) -> IO ((()))
newtype Info_csrchol
Info_csrchol :: ((Ptr ())) -> Info_csrchol
[useInfo_csrchol] :: Info_csrchol -> ((Ptr ()))
createInfo_csrchol :: IO ((Info_csrchol))
destroyInfo_csrchol :: (Info_csrchol) -> IO ((()))


module Foreign.CUDA.Solver.Sparse.Context

-- | An opaque handle to the cuSolverSP context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverSPhandle</a>
newtype Handle
Handle :: ((Ptr ())) -> Handle
[useHandle] :: Handle -> ((Ptr ()))

-- | This function initializes the cuSolverSP library and creates a handle
--   to the cuSolverSP context. It must be called before any other
--   cuSolverSP API function is invoked. It allocates hardware resources
--   necessary for accessing the GPU.
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusolverecreate</a>
create :: IO ((Handle))

-- | This function releases resources used by the cuSolverSP library.
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusparsedestroy</a>
destroy :: (Handle) -> IO ((()))


-- | For more information see the cuSolver function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusolver-high-level-function-reference</a>
module Foreign.CUDA.Solver.Sparse.High

-- | An opaque handle to the cuSolverSP context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverSPhandle</a>
data Handle

-- | An opaque type used to describe the shape and properties of a matrix.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusparse/index.html#cusparsematdescrt</a>
data MatrixDescriptor :: *
scsrlsvqr :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Float) -> (Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dcsrlsvqr :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Double) -> (Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
ccsrlsvqr :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Float)) -> (Float) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zcsrlsvqr :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Double)) -> (Double) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
scsrlsvchol :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Float) -> (Float) -> (Int) -> (DevicePtr Float) -> IO ((Int))
dcsrlsvchol :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Double) -> (Double) -> (Int) -> (DevicePtr Double) -> IO ((Int))
ccsrlsvchol :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Float)) -> (Float) -> (Int) -> (DevicePtr (Complex Float)) -> IO ((Int))
zcsrlsvchol :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Double)) -> (Double) -> (Int) -> (DevicePtr (Complex Double)) -> IO ((Int))
scsreigvsi :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Float) -> (DevicePtr Float) -> (Int) -> (Float) -> (DevicePtr Float) -> (DevicePtr Float) -> IO ()
dcsreigvsi :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Double) -> (DevicePtr Double) -> (Int) -> (Double) -> (DevicePtr Double) -> (DevicePtr Double) -> IO ()
ccsreigvsi :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> ((Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Float) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> IO ()
zcsreigvsi :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> ((Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Double) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> IO ()


-- | For more information see the cuSolver function reference:
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusolver-low-level-function-reference</a>
module Foreign.CUDA.Solver.Sparse.Low

-- | An opaque handle to the cuSolverSP context, which is passed to all
--   library function calls.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cuSolverSPhandle</a>
data Handle

-- | An opaque type used to describe the shape and properties of a matrix.
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusparse/index.html#cusparsematdescrt</a>
data MatrixDescriptor :: *
data Info_csrqr
data Info_csrchol
xcsrqrAnalysisBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ()
scsrqrBufferInfoBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Int) -> (Info_csrqr) -> IO ((Int), (Int))
dcsrqrBufferInfoBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Int) -> (Info_csrqr) -> IO ((Int), (Int))
ccsrqrBufferInfoBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Int) -> (Info_csrqr) -> IO ((Int), (Int))
zcsrqrBufferInfoBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Int) -> (Info_csrqr) -> IO ((Int), (Int))
scsrqrsvBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Float) -> (DevicePtr Float) -> (Int) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
dcsrqrsvBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr Double) -> (DevicePtr Double) -> (Int) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
ccsrqrsvBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Int) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
zcsrqrsvBatched :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Int) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
xcsrqrAnalysis :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ()
scsrqrBufferInfo :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ((Int), (Int))
dcsrqrBufferInfo :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ((Int), (Int))
ccsrqrBufferInfo :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ((Int), (Int))
zcsrqrBufferInfo :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrqr) -> IO ((Int), (Int))
scsrqrSetup :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Float) -> (Info_csrqr) -> IO ()
dcsrqrSetup :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Double) -> (Info_csrqr) -> IO ()
ccsrqrSetup :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> ((Complex Float)) -> (Info_csrqr) -> IO ()
zcsrqrSetup :: (Handle) -> (Int) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> ((Complex Double)) -> (Info_csrqr) -> IO ()
scsrqrFactor :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
dcsrqrFactor :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
ccsrqrFactor :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
zcsrqrFactor :: (Handle) -> (Int) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
scsrqrZeroPivot :: (Handle) -> (Info_csrqr) -> (Float) -> IO ((Int))
dcsrqrZeroPivot :: (Handle) -> (Info_csrqr) -> (Double) -> IO ((Int))
ccsrqrZeroPivot :: (Handle) -> (Info_csrqr) -> (Float) -> IO ((Int))
zcsrqrZeroPivot :: (Handle) -> (Info_csrqr) -> (Double) -> IO ((Int))
scsrqrSolve :: (Handle) -> (Int) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
dcsrqrSolve :: (Handle) -> (Int) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
ccsrqrSolve :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
zcsrqrSolve :: (Handle) -> (Int) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Info_csrqr) -> (DevicePtr ()) -> IO ()
xcsrcholAnalysis :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> IO ()
scsrcholBufferInfo :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> IO ((Int), (Int))
dcsrcholBufferInfo :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> IO ((Int), (Int))
ccsrcholBufferInfo :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> IO ((Int), (Int))
zcsrcholBufferInfo :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> IO ((Int), (Int))
scsrcholFactor :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Float) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
dcsrcholFactor :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr Double) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
ccsrcholFactor :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Float)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
zcsrcholFactor :: (Handle) -> (Int) -> (Int) -> (MatrixDescriptor) -> (DevicePtr (Complex Double)) -> (DevicePtr Int32) -> (DevicePtr Int32) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
scsrcholZeroPivot :: (Handle) -> (Info_csrchol) -> (Float) -> IO ((Int))
dcsrcholZeroPivot :: (Handle) -> (Info_csrchol) -> (Double) -> IO ((Int))
ccsrcholZeroPivot :: (Handle) -> (Info_csrchol) -> (Float) -> IO ((Int))
zcsrcholZeroPivot :: (Handle) -> (Info_csrchol) -> (Double) -> IO ((Int))
scsrcholSolve :: (Handle) -> (Int) -> (DevicePtr Float) -> (DevicePtr Float) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
dcsrcholSolve :: (Handle) -> (Int) -> (DevicePtr Double) -> (DevicePtr Double) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
ccsrcholSolve :: (Handle) -> (Int) -> (DevicePtr (Complex Float)) -> (DevicePtr (Complex Float)) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()
zcsrcholSolve :: (Handle) -> (Int) -> (DevicePtr (Complex Double)) -> (DevicePtr (Complex Double)) -> (Info_csrchol) -> (DevicePtr ()) -> IO ()


module Foreign.CUDA.Solver.Sparse.Stream

-- | Sets the execution stream which all subsequent cuSolverSp library
--   functions will execute with. If not set, functions execute in the
--   default stream (which never overlaps any other operations).
--   
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html#cusparsesetstream</a>
setStream :: (Handle) -> (Stream) -> IO ((()))


-- | The cuSolver library provides useful LAPACK-like features implemented
--   on NVIDIA GPUs. This module implements a subset of LAPACK functions on
--   sparse matrices in CSR or CSC format.
--   
--   To use operations from the cuSolver library, the user must allocate
--   the required vectors and matrices in the GPU memory space, fill them
--   with data, call the desired sequence of cuSolver functions, then copy
--   the results from the GPU memory space back to the host.
--   
--   The <a>cuda</a> package can be used for writing to and retrieving data
--   from the GPU.
--   
--   <ul>
--   <li><i><i>Example</i></i></li>
--   </ul>
--   
--   <i>TODO</i>
--   
--   <ul>
--   <li><i><i>Additional information</i></i></li>
--   </ul>
--   
--   For more information, see the NVIDIA cuSolver documentation:
--   
--   <a>http://docs.nvidia.com/cuda/cusolver/index.html</a>
module Foreign.CUDA.Solver.Sparse
