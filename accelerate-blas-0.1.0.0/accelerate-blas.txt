-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Numeric Linear Algebra in Accelerate
--   
--   Linear systems, matrix decompositions, and other numerical
--   computations for use in Accelerate. Most operations are implemented
--   efficiently via FFI calls to BLAS and LAPACK
--   
--   For further information refer to the main <i>Accelerate</i> package:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-blas
@version 0.1.0.0


-- | Level 1 (vector-vector) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level1
class (Elt a, Num a) => Numeric a

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e

-- | Computes a vector-vector dot product, using double precision
--   accumulation of the intermediate result. Includes a scalar (initial)
--   value to be added to the inner product.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-sdot</a>
sdot :: forall e. Numeric e => Exp e -> Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)

-- | Computes a vector-vector dot product
--   
--   &lt;math&gt;
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-dotu</a>
dotu :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)

-- | Computes a dot product of a conjugated vector with another vector
--   
--   &lt;math&gt;
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-dotc</a>
dotc :: forall e. Numeric (Complex e) => Acc (Vector (Complex e)) -> Acc (Vector (Complex e)) -> Acc (Scalar (Complex e))

-- | Computes the sum of magnitudes of the vector elements. For complex
--   values, this is given by &lt;math&gt;.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-asum</a>
asum :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar (NumericBaseT e))

-- | Return the index of the element with the maximum absolute value.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-i-amax</a>
amax :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar Int)

-- | Return the index of the element with the minimum absolute value.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-i-amin</a>
amin :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar Int)


-- | Level 2 (matrix-vector) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level2
class (Elt a, Num a) => Numeric a

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e
type Matrix e = Array DIM2 e

-- | Many operations allow you to implicitly transpose the arguments. For a
--   given input matrix <tt>mat</tt> with dimensions <tt>Z :. m :. n</tt>
--   (that is; <tt>m</tt> rows and <tt>n</tt> columns):
data Transpose

-- | Leave the matrix as is.
N :: Transpose

-- | Treat the matrix as implicitly transposed, with dimensions <tt>Z :. n
--   :. m</tt>. Entry <tt>Z :. j :. i</tt> is treated as actually being
--   entry <tt>Z :. i :. j</tt>.
T :: Transpose

-- | Implicitly transpose and conjugate the input matrix. For
--   complex-valued matrices a given element <tt>mat ! Z:.j:.i == x :+
--   y</tt> will be treated as actually being <tt>mat ! Z:.i:.j == x :+
--   (-y)</tt>.
H :: Transpose

-- | Computes the matrix-vector product of a general matrix.
--   
--   &lt;math&gt;
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemv</a>
gemv :: forall e. Numeric e => Exp e -> Transpose -> Acc (Matrix e) -> Acc (Vector e) -> Acc (Vector e)


-- | Level 3 (matrix-matrix) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level3
class (Elt a, Num a) => Numeric a
type Matrix e = Array DIM2 e

-- | Many operations allow you to implicitly transpose the arguments. For a
--   given input matrix <tt>mat</tt> with dimensions <tt>Z :. m :. n</tt>
--   (that is; <tt>m</tt> rows and <tt>n</tt> columns):
data Transpose

-- | Leave the matrix as is.
N :: Transpose

-- | Treat the matrix as implicitly transposed, with dimensions <tt>Z :. n
--   :. m</tt>. Entry <tt>Z :. j :. i</tt> is treated as actually being
--   entry <tt>Z :. i :. j</tt>.
T :: Transpose

-- | Implicitly transpose and conjugate the input matrix. For
--   complex-valued matrices a given element <tt>mat ! Z:.j:.i == x :+
--   y</tt> will be treated as actually being <tt>mat ! Z:.i:.j == x :+
--   (-y)</tt>.
H :: Transpose

-- | General matrix-matrix multiply
--   
--   &lt;math&gt;
--   
--   where:
--   
--   <ul>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m :. k</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. k :. n</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m :. n</tt></li>
--   </ul>
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemm</a>
gemm :: forall e. Numeric e => Exp e -> Transpose -> Acc (Matrix e) -> Transpose -> Acc (Matrix e) -> Acc (Matrix e)


module Data.Array.Accelerate.Numeric.LinearAlgebra
class (Elt a, Num a) => Numeric a

-- | Scalars arrays hold a single element
type Scalar e = Array DIM0 e

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e
type Matrix e = Array DIM2 e

-- | An infix synonym for <a>dotu</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z:.4) [1..]
--   
--   &gt;&gt;&gt; let b = fromList (Z:.4) [-2,0,1,1]
--   
--   &gt;&gt;&gt; a &lt;.&gt; b
--   Scalar Z [5.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let c = fromList (Z:.2) [1:+1, 1:+0]
--   
--   &gt;&gt;&gt; let d = fromList (Z:.2) [1:+0, 1:+(-1)]
--   
--   &gt;&gt;&gt; c &lt;.&gt; d
--   Scalar Z [2.0 :+ 0.0]
--   </pre>
(<.>) :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)
infixr 8 <.>

-- | Outer product of two vectors
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z :. 3) [1,2,3]
--   
--   &gt;&gt;&gt; let b = fromList (Z :. 3) [5,2,3]
--   
--   &gt;&gt;&gt; a &gt;&lt; b
--    Matrix (Z :. 3 :. 3)
--      [  5.0, 2.0, 3.0
--      , 10.0, 4.0, 6.0
--      , 15.0, 6.0, 9.0 ]
--   </pre>
(><) :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Matrix e)
infixr 8 ><

-- | Dense matrix-vector product
--   
--   <pre>
--   &gt;&gt;&gt; let m = fromList (Z :. 2 :. 3) [1..]
--   
--   &gt;&gt;&gt; m
--   Matrix (Z :. 2 :. 3)
--    [ 1.0, 2.0, 3.0
--    , 4.0, 5.0, 6.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let x = fromList (Z :. 3) [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m #&gt; x
--   Vector (Z :. 2) [140.0,320.0]
--   </pre>
--   
--   See <a>gemv</a> for a more general version of this operation.
(#>) :: Numeric e => Acc (Matrix e) -> Acc (Vector e) -> Acc (Vector e)
infixr 8 #>

-- | Dense vector-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; let m = fromList (Z :. 2 :. 3) [1..]
--   
--   &gt;&gt;&gt; m
--   Matrix (Z :. 2 :. 3)
--    [1.0,2.0,3.0,
--     4.0,5.0,6.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let v = fromList (Z :. 2) [5,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; v &lt;# m
--   Vector (Z :. 3) [45.0,60.0,75.0]
--   </pre>
--   
--   See <a>gemv</a> for a more general version of this operation.
(<#) :: Numeric e => Acc (Vector e) -> Acc (Matrix e) -> Acc (Vector e)
infixr 8 <#

-- | Dense matrix-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z :. 3 :. 5) [1..]
--   
--   &gt;&gt;&gt; a
--   Matrix (Z:.3:.5)
--    [  1.0,  2.0,  3.0,  4.0,  5.0
--    ,  6.0,  7.0,  8.0,  9.0, 10.0
--    , 11.0, 12.0, 13.0, 14.0, 15.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b = fromList (Z :. 5 :. 2) [1,3, 0,2, -1,5, 7,7, 6,0]
--   
--   &gt;&gt;&gt; b
--   Matrix (Z :. 5 :. 2)
--    [  1.0, 3.0
--    ,  0.0, 2.0
--    , -1.0, 5.0
--    ,  7.0, 7.0
--    ,  6.0, 0.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;&gt; b
--   Matrix (Z :. 3 :. 2)
--    [  56.0,  50.0
--    , 121.0, 135.0
--    , 186.0, 220.0 ]
--   </pre>
--   
--   See <a>gemm</a> for a more general version of this operation.
(<>) :: Numeric e => Acc (Matrix e) -> Acc (Matrix e) -> Acc (Matrix e)
infixr 8 <>

-- | Create a square identity matrix of the given dimension
ident :: Num e => Exp Int -> Acc (Matrix e)

-- | Create a square matrix with the given diagonal
diag :: Num e => Acc (Vector e) -> Acc (Matrix e)
