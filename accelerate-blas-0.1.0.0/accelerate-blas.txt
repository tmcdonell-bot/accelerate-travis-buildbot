-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Numeric Linear Algebra in Accelerate
--   
--   Linear systems, matrix decompositions, and other numerical
--   computations for use in Accelerate. Most operations are implemented
--   efficiently via FFI calls to BLAS and LAPACK
--   
--   For further information refer to the main <i>Accelerate</i> package:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-blas
@version 0.1.0.0


-- | Functions for summing floating point numbers more accurately than the
--   straightforward <a>sum</a> operation.
--   
--   In the worst case, the <a>sum</a> function accumulates error at a rate
--   proportional to the number of values being summed. The algorithms in
--   this module implement different methods of <i>compensated
--   summation</i>, which reduce the accumulation of numeric error so that
--   it grows much more slowly than the number of inputs (e.g.
--   logarithmically), or remains constant.
module Data.Array.Accelerate.Numeric.Sum

-- | A class for the summation of floating-point numbers
class (Elt a, Elt (s a)) => Summation s a

-- | Add a value to the sum
add :: Summation s a => Exp (s a) -> Exp (s a) -> Exp (s a)

-- | The identity of the summation
zero :: Summation s a => Exp (s a)

-- | Insert a value into the summation
into :: Summation s a => Proxy s -> Exp a -> Exp (s a)

-- | Summarise the result of summation
from :: Summation s a => Proxy s -> Exp (s a) -> Exp a

-- | Sum an array using a particular compensation scheme.
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [1.0, 1.0e100, 1.0, -1.0e100] :: [Double]
--   
--   &gt;&gt;&gt; Prelude.sum xs
--   0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let ys = fromList (Z:.4) [1.0, 1.0e100, 1.0, -1.0e100] :: Vector Double
--   
--   &gt;&gt;&gt; sum kbn (use ys)
--   Scalar Z [2.0]
--   </pre>
sum :: (Summation s a, Shape sh) => Proxy s -> Acc (Array (sh :. Int) a) -> Acc (Array sh a)

-- | Kahan-Babuška-Neumaier summation. This is a little more
--   computationally costly than plain Kahan summation, but is
--   <i>always</i> at least as accurate.
data KBN a
KBN :: a -> a -> KBN a

-- | Return the result of a Kahan-Babuška-Neumaier sum.
kbn :: Proxy KBN

-- | Second-order Kahan-Babuška summation. This is more computationally
--   costly than Kahan-Babuška-Neumaier summation. Its advantage is that it
--   can lose less precision (in admittedly obscure cases).
--   
--   This method compensates for error in both the sum and the first-order
--   compensation term, hence the use of "second order" in the name.
data KB2 a
KB2 :: a -> a -> a -> KB2 a

-- | Return the result of a second-order Kahan-Babuška sum.
kb2 :: Proxy KB2

-- | Kahan summation. This is the least accurate of the compensated
--   summation methods. This summation method is included only for
--   completeness.
data Kahan a
Kahan :: a -> a -> Kahan a

-- | Return the result of a Kahan sum.
kahan :: Proxy Kahan
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Numeric.Sum.Kahan a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Numeric.Sum.KB2 a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Array.Accelerate.Numeric.Sum.KBN a)
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KBN GHC.Types.Float
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KBN GHC.Types.Double
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KBN Foreign.C.Types.CFloat
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KBN Foreign.C.Types.CDouble
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.KBN a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.KBN a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.KBN a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.KBN (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KB2 GHC.Types.Float
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KB2 GHC.Types.Double
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KB2 Foreign.C.Types.CFloat
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.KB2 Foreign.C.Types.CDouble
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.KB2 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.KB2 a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.KB2 a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.KB2 (Data.Array.Accelerate.Smart.Exp a))
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.Kahan GHC.Types.Float
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.Kahan GHC.Types.Double
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.Kahan Foreign.C.Types.CFloat
instance Data.Array.Accelerate.Numeric.Sum.Summation Data.Array.Accelerate.Numeric.Sum.Kahan Foreign.C.Types.CDouble
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.Kahan a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Product.IsProduct Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Numeric.Sum.Kahan a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.Kahan a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Data.Array.Accelerate.Numeric.Sum.Kahan (Data.Array.Accelerate.Smart.Exp a))


-- | Level 3 (matrix-matrix) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level3
class (Elt a, Num a) => Numeric a

-- | Matrices as dense two-dimensional arrays in row-major ordering
type Matrix e = Array DIM2 e

-- | Many operations allow you to implicitly transpose the arguments. For a
--   given input matrix <tt>mat</tt> with dimensions <tt>Z :. m :. n</tt>
--   (that is; <tt>m</tt> rows and <tt>n</tt> columns):
data Transpose

-- | Leave the matrix as is.
N :: Transpose

-- | Treat the matrix as implicitly transposed, with dimensions <tt>Z :. n
--   :. m</tt>. Entry <tt>Z :. j :. i</tt> is treated as actually being
--   entry <tt>Z :. i :. j</tt>.
T :: Transpose

-- | Implicitly transpose and conjugate the input matrix. For
--   complex-valued matrices a given element <tt>mat ! Z:.j:.i == x :+
--   y</tt> will be treated as actually being <tt>mat ! Z:.i:.j == x :+
--   (-y)</tt>.
H :: Transpose

-- | General matrix-matrix multiply
--   
--   &lt;math&gt;
--   
--   where:
--   
--   <ul>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m :. k</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. k :. n</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m :. n</tt></li>
--   </ul>
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemm</a>
gemm :: forall e. Numeric e => Exp e -> Transpose -> Acc (Matrix e) -> Transpose -> Acc (Matrix e) -> Acc (Matrix e)


-- | Level 2 (matrix-vector) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level2
class (Elt a, Num a) => Numeric a

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e

-- | Matrices as dense two-dimensional arrays in row-major ordering
type Matrix e = Array DIM2 e

-- | Many operations allow you to implicitly transpose the arguments. For a
--   given input matrix <tt>mat</tt> with dimensions <tt>Z :. m :. n</tt>
--   (that is; <tt>m</tt> rows and <tt>n</tt> columns):
data Transpose

-- | Leave the matrix as is.
N :: Transpose

-- | Treat the matrix as implicitly transposed, with dimensions <tt>Z :. n
--   :. m</tt>. Entry <tt>Z :. j :. i</tt> is treated as actually being
--   entry <tt>Z :. i :. j</tt>.
T :: Transpose

-- | Implicitly transpose and conjugate the input matrix. For
--   complex-valued matrices a given element <tt>mat ! Z:.j:.i == x :+
--   y</tt> will be treated as actually being <tt>mat ! Z:.i:.j == x :+
--   (-y)</tt>.
H :: Transpose

-- | Computes the matrix-vector product of a general matrix.
--   
--   &lt;math&gt;
--   
--   where:
--   
--   <ul>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m :. n</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. n</tt></li>
--   <li><a>shape</a> &lt;math&gt; <tt>= Z :. m</tt></li>
--   </ul>
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-gemv</a>
gemv :: forall e. Numeric e => Exp e -> Transpose -> Acc (Matrix e) -> Acc (Vector e) -> Acc (Vector e)


-- | Level 1 (vector-vector) BLAS operations.
module Data.Array.Accelerate.Numeric.LinearAlgebra.BLAS.Level1
class (Elt a, Num a) => Numeric a

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e

-- | Computes a vector-vector dot product, using double precision
--   accumulation of the intermediate result. Includes a scalar (initial)
--   value to be added to the inner product.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-sdot</a>
sdot :: forall e. Numeric e => Exp e -> Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)

-- | Computes a vector-vector dot product
--   
--   &lt;math&gt;
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-dotu</a>
dotu :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)

-- | Computes a dot product of a conjugated vector with another vector
--   
--   &lt;math&gt;
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-dotc</a>
dotc :: forall e. Numeric (Complex e) => Acc (Vector (Complex e)) -> Acc (Vector (Complex e)) -> Acc (Scalar (Complex e))

-- | Computes the sum of magnitudes of the vector elements. For complex
--   values, this is given by &lt;math&gt;.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-asum</a>
asum :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar (NumericBaseT e))

-- | Return the index of the element with the maximum absolute value.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-i-amax</a>
amax :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar Int)

-- | Return the index of the element with the minimum absolute value.
--   
--   
--   <a>https://software.intel.com/en-us/mkl-developer-reference-c-cblas-i-amin</a>
amin :: forall e. Numeric e => Acc (Vector e) -> Acc (Scalar Int)


module Data.Array.Accelerate.Numeric.LinearAlgebra
class (Elt a, Num a) => Numeric a

-- | Scalars arrays hold a single element
type Scalar e = Array DIM0 e

-- | Vectors are one-dimensional arrays
type Vector e = Array DIM1 e

-- | Matrices as dense two-dimensional arrays in row-major ordering
type Matrix e = Array DIM2 e

-- | An infix synonym for <a>dotu</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z:.4) [1..]
--   
--   &gt;&gt;&gt; let b = fromList (Z:.4) [-2,0,1,1]
--   
--   &gt;&gt;&gt; a &lt;.&gt; b
--   Scalar Z [5.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let c = fromList (Z:.2) [1:+1, 1:+0]
--   
--   &gt;&gt;&gt; let d = fromList (Z:.2) [1:+0, 1:+(-1)]
--   
--   &gt;&gt;&gt; c &lt;.&gt; d
--   Scalar Z [2.0 :+ 0.0]
--   </pre>
(<.>) :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Scalar e)
infixr 8 <.>

-- | Outer product of two vectors
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z :. 3) [1,2,3]
--   
--   &gt;&gt;&gt; let b = fromList (Z :. 3) [5,2,3]
--   
--   &gt;&gt;&gt; a &gt;&lt; b
--    Matrix (Z :. 3 :. 3)
--      [  5.0, 2.0, 3.0
--      , 10.0, 4.0, 6.0
--      , 15.0, 6.0, 9.0 ]
--   </pre>
(><) :: Numeric e => Acc (Vector e) -> Acc (Vector e) -> Acc (Matrix e)
infixr 8 ><

-- | Dense matrix-vector product
--   
--   <pre>
--   &gt;&gt;&gt; let m = fromList (Z :. 2 :. 3) [1..]
--   
--   &gt;&gt;&gt; m
--   Matrix (Z :. 2 :. 3)
--    [ 1.0, 2.0, 3.0
--    , 4.0, 5.0, 6.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let x = fromList (Z :. 3) [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m #&gt; x
--   Vector (Z :. 2) [140.0,320.0]
--   </pre>
--   
--   See <a>gemv</a> for a more general version of this operation.
(#>) :: Numeric e => Acc (Matrix e) -> Acc (Vector e) -> Acc (Vector e)
infixr 8 #>

-- | Dense vector-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; let m = fromList (Z :. 2 :. 3) [1..]
--   
--   &gt;&gt;&gt; m
--   Matrix (Z :. 2 :. 3)
--    [1.0,2.0,3.0,
--     4.0,5.0,6.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let v = fromList (Z :. 2) [5,10]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; v &lt;# m
--   Vector (Z :. 3) [45.0,60.0,75.0]
--   </pre>
--   
--   See <a>gemv</a> for a more general version of this operation.
(<#) :: Numeric e => Acc (Vector e) -> Acc (Matrix e) -> Acc (Vector e)
infixr 8 <#

-- | Dense matrix-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList (Z :. 3 :. 5) [1..]
--   
--   &gt;&gt;&gt; a
--   Matrix (Z:.3:.5)
--    [  1.0,  2.0,  3.0,  4.0,  5.0
--    ,  6.0,  7.0,  8.0,  9.0, 10.0
--    , 11.0, 12.0, 13.0, 14.0, 15.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b = fromList (Z :. 5 :. 2) [1,3, 0,2, -1,5, 7,7, 6,0]
--   
--   &gt;&gt;&gt; b
--   Matrix (Z :. 5 :. 2)
--    [  1.0, 3.0
--    ,  0.0, 2.0
--    , -1.0, 5.0
--    ,  7.0, 7.0
--    ,  6.0, 0.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;&gt; b
--   Matrix (Z :. 3 :. 2)
--    [  56.0,  50.0
--    , 121.0, 135.0
--    , 186.0, 220.0 ]
--   </pre>
--   
--   See <a>gemm</a> for a more general version of this operation.
(<>) :: Numeric e => Acc (Matrix e) -> Acc (Matrix e) -> Acc (Matrix e)
infixr 8 <>

-- | Create a square identity matrix of the given dimension
identity :: Num e => Exp Int -> Acc (Matrix e)

-- | Create a square matrix with the given diagonal
diagonal :: Num e => Acc (Vector e) -> Acc (Matrix e)
