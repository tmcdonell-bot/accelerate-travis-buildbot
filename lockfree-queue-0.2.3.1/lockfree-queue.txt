-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Michael and Scott lock-free queues.
--   
--   Michael and Scott queues are described in their PODC 1996 paper:
--   
--   <a>http://dl.acm.org/citation.cfm?id=248052.248106</a>
--   
--   These are single-ended concurrent queues based on a singlly linked
--   list and using atomic CAS instructions to swap the tail pointers. As a
--   well-known efficient algorithm they became the basis for Java's
--   <tt>ConcurrentLinkedQueue</tt>.
@package lockfree-queue
@version 0.2.3.1


-- | Michael and Scott lock-free, single-ended queues.
--   
--   This is a straightforward implementation of classic Michael &amp;
--   Scott Queues. Pseudocode for this algorithm can be found here:
--   
--   
--   <a>http://www.cs.rochester.edu/research/synchronization/pseudocode/queues.html</a>
module Data.Concurrent.Queue.MichaelScott
data LinkedQueue a

-- | Create a new queue.
newQ :: IO (LinkedQueue a)

-- | Is the queue currently empty? Beware that this can be a highly
--   transient state.
nullQ :: LinkedQueue a -> IO Bool

-- | Push a new element onto the queue. Because the queue can grow, this
--   always succeeds.
pushL :: forall a. LinkedQueue a -> a -> IO ()

-- | Attempt to pop an element from the queue if one is available. tryPop
--   will return semi-promptly (depending on contention), but will return
--   <a>Nothing</a> if the queue is empty.
tryPopR :: forall a. LinkedQueue a -> IO (Maybe a)
instance Data.Concurrent.Deque.Class.DequeClass Data.Concurrent.Queue.MichaelScott.LinkedQueue

module Data.Concurrent.Queue.MichaelScott.DequeInstance
