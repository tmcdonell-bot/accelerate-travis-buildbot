-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFT using the Accelerate library
--   
--   Rank-polymorphic discrete Fourier transform (DFT), computed with a
--   fast Fourier transform (FFT) algorithm using the Accelerate library.
--   Note that optimised implementations are available via foreign
--   libraries, but must be explicitly enabled.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-fft
@version 1.2.0.0


-- | These transforms allow the centering of the frequency domain of a DFT
--   such that the zero frequency is in the middle. The centering
--   transform, when performed on the input of a DFT, will cause zero
--   frequency to be centred in the middle. The shifting transform however
--   takes the output of a DFT to give the same result. Therefore the
--   relationship between the two is:
--   
--   <pre>
--   fft(center(X)) = shift(fft(X))
--   </pre>
module Data.Array.Accelerate.Math.DFT.Centre

-- | Apply the centring transform to a vector
centre1D :: (Elt (Complex e), RealFloat e, FromIntegral Int e) => Acc (Array DIM1 (Complex e)) -> Acc (Array DIM1 (Complex e))

-- | Apply the centring transform to a matrix
centre2D :: (Elt (Complex e), RealFloat e, FromIntegral Int e) => Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))

-- | Apply the centring transform to a 3D array
centre3D :: (Elt (Complex e), RealFloat e, FromIntegral Int e) => Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))

-- | Apply the shifting transform to a vector
shift1D :: Elt e => Acc (Vector e) -> Acc (Vector e)

-- | Apply the shifting transform to a 2D array
shift2D :: Elt e => Acc (Array DIM2 e) -> Acc (Array DIM2 e)

-- | Apply the shifting transform to a 3D array
shift3D :: Elt e => Acc (Array DIM3 e) -> Acc (Array DIM3 e)


module Data.Array.Accelerate.Math.DFT.Roots

-- | Calculate the roots of unity for the forward transform
rootsOfUnity :: (Shape sh, Slice sh, Elt (Complex e), Floating e, FromIntegral Int e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))

-- | Calculate the roots of unity for an inverse transform
inverseRootsOfUnity :: (Shape sh, Slice sh, Elt (Complex e), Floating e, FromIntegral Int e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))


-- | Compute the Discrete Fourier Transform (DFT) along the lower order
--   dimension of an array.
--   
--   This uses a na√Øve algorithm which takes O(n^2) time. However, you can
--   transform an array with an arbitrary extent, unlike with FFT which
--   requires each dimension to be a power of two.
--   
--   The <a>dft</a> and <a>idft</a> functions compute the roots of unity as
--   needed. If you need to transform several arrays with the same extent
--   than it is faster to compute the roots once using <a>rootsOfUnity</a>
--   or <a>inverseRootsOfUnity</a> respectively, then call <a>dftG</a>
--   directly.
--   
--   You can also compute single values of the transform using <a>dftGS</a>
module Data.Array.Accelerate.Math.DFT

-- | Compute the DFT along the low order dimension of an array
dft :: (Shape sh, Slice sh, Elt (Complex e), RealFloat e, FromIntegral Int e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute the inverse DFT along the low order dimension of an array
idft :: (Shape sh, Slice sh, Elt (Complex e), RealFloat e, FromIntegral Int e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Generic function for computation of forward and inverse DFT. This
--   function is also useful if you transform many arrays of the same
--   extent, and don't want to recompute the roots for each one.
--   
--   The extent of the input and roots must match.
dftG :: forall sh e. (Shape sh, Slice sh, Elt (Complex e), RealFloat e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute a single value of the DFT.
dftGS :: forall sh e. (Shape sh, Slice sh, Elt (Complex e), RealFloat e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Scalar (Complex e))


-- | For performance, compile against the foreign library bindings (using
--   any number of '-fllvm-ptx', and '-fllvm-cpu' for the
--   accelerate-llvm-ptx, and accelerate-llvm-native backends,
--   respectively).
module Data.Array.Accelerate.Math.FFT
data Mode

-- | Forward DFT
Forward :: Mode

-- | Inverse DFT, un-normalised
Reverse :: Mode

-- | Inverse DFT, normalised
Inverse :: Mode
class (RealFloat a, FromIntegral Int a, Elt (Complex a)) => Numeric a

-- | Discrete Fourier Transform along the innermost dimension of an array.
--   
--   Notes for FFI implementations:
--   
--   <ul>
--   <li>fftw supports arrays of dimension 1-5</li>
--   <li>cuFFT supports arrays of dimension 1-3</li>
--   </ul>
--   
--   The pure implementation will be used otherwise.
fft :: forall sh e. (Shape sh, Slice sh, Numeric e) => Mode -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Discrete Fourier Transform of a vector.
fft1D :: forall e. Numeric e => Mode -> Acc (Array DIM1 (Complex e)) -> Acc (Array DIM1 (Complex e))

-- | Discrete Fourier Transform of a matrix.
fft2D :: forall e. Numeric e => Mode -> Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))

-- | Discrete Fourier Transform of a 3D array.
fft3D :: forall e. Numeric e => Mode -> Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))
