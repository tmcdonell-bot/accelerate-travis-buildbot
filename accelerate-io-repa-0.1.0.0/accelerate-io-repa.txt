-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Read and write Accelerate arrays in various formats
--   
--   This package provides efficient conversion routines between a range of
--   array types and Accelerate arrays.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-io-repa
@version 0.1.0.0


-- | This provides an efficient non-copying Repa manifest array
--   representation that can be passed directly to Accelerate.
--   
--   The standard rules for dealing with manifest Repa arrays apply:
--   
--   <ul>
--   <li>If you want to have Repa <a>computeP</a> directly into an
--   Accelerate array, the source array must have a delayed
--   representation.</li>
--   <li>If you want to copy between manifest arrays, use <a>copyP</a>
--   instead.</li>
--   </ul>
module Data.Array.Repa.Repr.Accelerate

-- | The representation tag for manifest arrays based on
--   Data.Array.Accelerate.
--   
--   The Accelerate array implementation is based on type families and
--   picks an efficient, unboxed representation for every element type.
--   Moreover, these arrays can be handed efficiently (without copying) to
--   Accelerate programs for further computation.
data A

-- | Index conversion and equivalence statement between Repa and Accelerate
--   array shapes. That is, a n-dimensional Repa array will produce an
--   n-dimensional Accelerate array of the same extent, and vice-versa.
class (Shape r, Shape a) => Shapes r a | a -> r, r -> a

-- | <i>O(1)</i>. Unpack to an Accelerate array.
fromRepa :: (Shapes sh sh', Elt e) => Array A sh e -> Array sh' e

-- | <i>O(1)</i>. Wrap an Accelerate array.
toRepa :: Shapes sh sh' => Array sh' e -> Array A sh e

-- | Sequential computation of array elements
computeAccS :: (Load r sh e, Elt e) => Array r sh e -> Array A sh e

-- | Parallel computation of array elements
computeAccP :: (Load r sh e, Elt e, Monad m) => Array r sh e -> m (Array A sh e)
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Accelerate.A e
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Array.Repa.Eval.Target.Target Data.Array.Repa.Repr.Accelerate.A e
instance Data.Array.Repa.Repr.Accelerate.Shapes Data.Array.Repa.Index.Z Data.Array.Accelerate.Array.Sugar.Z
instance Data.Array.Repa.Repr.Accelerate.Shapes sr sa => Data.Array.Repa.Repr.Accelerate.Shapes (sr Data.Array.Repa.Index.:. GHC.Types.Int) (sa Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
