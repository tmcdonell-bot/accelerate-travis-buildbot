-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Painless 2D vector graphics, animations and simulations.
--   
--   Gloss hides the pain of drawing simple vector graphics behind a nice
--   data type and a few display functions. Gloss uses OpenGL under the
--   hood, but you won't need to worry about any of that. Get something
--   cool on the screen in under 10 minutes.
@package gloss
@version 1.13.0.1


-- | Functions to load bitmap data from various places.
module Graphics.Gloss.Data.Bitmap

-- | Represents a rectangular section in a bitmap
data Rectangle
Rectangle :: (Int, Int) -> (Int, Int) -> Rectangle

-- | x- and y-pos in the bitmap in pixels
[rectPos] :: Rectangle -> (Int, Int)

-- | width/height of the area in pixelsi
[rectSize] :: Rectangle -> (Int, Int)

-- | Abstract 32-bit RGBA bitmap data.
data BitmapData

-- | width, height in pixels
bitmapSize :: BitmapData -> (Int, Int)

-- | Description of how the bitmap is layed out in memory.
--   
--   <ul>
--   <li>Prior version of Gloss assumed `BitmapFormat BottomToTop
--   PxAGBR`</li>
--   </ul>
data BitmapFormat
BitmapFormat :: RowOrder -> PixelFormat -> BitmapFormat
[rowOrder] :: BitmapFormat -> RowOrder
[pixelFormat] :: BitmapFormat -> PixelFormat

-- | Order of rows in an image are either:
--   
--   <ul>
--   <li><a>TopToBottom</a> - the top row, followed by the next-lower row
--   and so on.</li>
--   <li><a>BottomToTop</a> - the bottom row followed by the next-higher
--   row and so on.</li>
--   </ul>
data RowOrder
TopToBottom :: RowOrder
BottomToTop :: RowOrder

-- | Pixel formats describe the order of the color channels in memory.
data PixelFormat
PxRGBA :: PixelFormat
PxABGR :: PixelFormat

-- | O(1). Use a <a>ForeignPtr</a> of RGBA data as a bitmap with the given
--   width and height.
--   
--   The boolean flag controls whether Gloss should cache the data between
--   frames for speed. If you are programatically generating the image for
--   each frame then use <a>False</a>. If you have loaded it from a file
--   then use <a>True</a>.
bitmapOfForeignPtr :: Int -> Int -> BitmapFormat -> ForeignPtr Word8 -> Bool -> Picture
bitmapDataOfForeignPtr :: Int -> Int -> BitmapFormat -> ForeignPtr Word8 -> Bool -> BitmapData

-- | O(size). Copy a <a>ByteString</a> of RGBA data into a bitmap with the
--   given width and height.
--   
--   The boolean flag controls whether Gloss should cache the data between
--   frames for speed. If you are programatically generating the image for
--   each frame then use <a>False</a>. If you have loaded it from a file
--   then use <a>True</a>.
bitmapOfByteString :: Int -> Int -> BitmapFormat -> ByteString -> Bool -> Picture
bitmapDataOfByteString :: Int -> Int -> BitmapFormat -> ByteString -> Bool -> BitmapData

-- | O(size). Copy a <a>BMP</a> file into a bitmap.
bitmapOfBMP :: BMP -> Picture

-- | O(size). Copy a <a>BMP</a> file into a bitmap.
bitmapDataOfBMP :: BMP -> BitmapData

-- | Load an uncompressed 24 or 32bit RGBA BMP file as a bitmap.
loadBMP :: FilePath -> IO Picture


-- | Predefined and custom colors.
module Graphics.Gloss.Data.Color

-- | An abstract color value. We keep the type abstract so we can be sure
--   that the components are in the required range. To make a custom color
--   use <a>makeColor</a>.
data Color

-- | Make a custom color. All components are clamped to the range [0..1].
makeColor :: Float -> Float -> Float -> Float -> Color

-- | Make a custom color. All components are clamped to the range [0..255].
makeColorI :: Int -> Int -> Int -> Int -> Color

-- | Take the RGBA components of a color.
rgbaOfColor :: Color -> (Float, Float, Float, Float)

-- | Mix two colors with the given ratios.
mixColors :: Float -> Float -> Color -> Color -> Color

-- | Add RGB components of a color component-wise, then normalise them to
--   the highest resulting one. The alpha components are averaged.
addColors :: Color -> Color -> Color

-- | Make a dimmer version of a color, scaling towards black.
dim :: Color -> Color

-- | Make a brighter version of a color, scaling towards white.
bright :: Color -> Color

-- | Lighten a color, adding white.
light :: Color -> Color

-- | Darken a color, adding black.
dark :: Color -> Color

-- | Set the red value of a <a>Color</a>.
withRed :: Float -> Color -> Color

-- | Set the green value of a <a>Color</a>.
withGreen :: Float -> Color -> Color

-- | Set the blue value of a <a>Color</a>.
withBlue :: Float -> Color -> Color

-- | Set the alpha value of a <a>Color</a>.
withAlpha :: Float -> Color -> Color

-- | A greyness of a given order.
--   
--   Range is 0 = black, to 1 = white.
greyN :: Float -> Color
black :: Color
white :: Color
red :: Color
green :: Color
blue :: Color
yellow :: Color
cyan :: Color
magenta :: Color
rose :: Color
violet :: Color
azure :: Color
aquamarine :: Color
chartreuse :: Color
orange :: Color

module Graphics.Gloss.Data.Display

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen.
FullScreen :: Display
instance GHC.Show.Show Graphics.Gloss.Data.Display.Display
instance GHC.Read.Read Graphics.Gloss.Data.Display.Display
instance GHC.Classes.Eq Graphics.Gloss.Data.Display.Display


-- | <h2>Point and vector arithmetic</h2>
--   
--   Vectors aren't numbers according to Haskell, because they don't
--   support all numeric operations sensibly. We define component-wise
--   addition, subtraction, and negation along with scalar multiplication
--   in this module, which is intended to be imported qualified.
module Graphics.Gloss.Data.Point.Arithmetic

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | Add two vectors, or add a vector to a point.
(+) :: Point -> Point -> Point
infixl 6 +

-- | Subtract two vectors, or subtract a vector from a point.
(-) :: Point -> Point -> Point
infixl 6 -

-- | Multiply a scalar by a vector.
(*) :: Float -> Point -> Point
infixl 7 *

-- | Negate a vector.
negate :: Point -> Point


-- | Geometric functions concerning angles. If not otherwise specified, all
--   angles are in radians.
module Graphics.Gloss.Geometry.Angle

-- | Convert degrees to radians
degToRad :: Float -> Float

-- | Convert radians to degrees
radToDeg :: Float -> Float

-- | Normalize an angle to be between 0 and 2*pi radians
normalizeAngle :: Float -> Float

module Graphics.Gloss.Data.Picture

-- | A 2D picture
data Picture

-- | A blank picture, with nothing in it.
Blank :: Picture

-- | A convex polygon filled with a solid color.
Polygon :: Path -> Picture

-- | A line along an arbitrary path.
Line :: Path -> Picture

-- | A circle with the given radius.
Circle :: Float -> Picture

-- | A circle with the given radius and thickness. If the thickness is 0
--   then this is equivalent to <a>Circle</a>.
ThickCircle :: Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in degrees)
--   at the given radius.
Arc :: Float -> Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in
--   degrees), with the given radius and thickness. If the thickness is 0
--   then this is equivalent to <a>Arc</a>.
ThickArc :: Float -> Float -> Float -> Float -> Picture

-- | Some text to draw with a vector font.
Text :: String -> Picture

-- | A bitmap image.
Bitmap :: BitmapData -> Picture

-- | A subsection of a bitmap image where the first argument selects a sub
--   section in the bitmap, and second argument determines the bitmap data.
BitmapSection :: Rectangle -> BitmapData -> Picture

-- | A picture drawn with this color.
Color :: Color -> Picture -> Picture

-- | A picture translated by the given x and y coordinates.
Translate :: Float -> Float -> Picture -> Picture

-- | A picture rotated clockwise by the given angle (in degrees).
Rotate :: Float -> Picture -> Picture

-- | A picture scaled by the given x and y factors.
Scale :: Float -> Float -> Picture -> Picture

-- | A picture consisting of several others.
Pictures :: [Picture] -> Picture

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | A vector can be treated as a point, and vis-versa.
type Vector = Point

-- | A path through the x-y plane.
type Path = [Point]

-- | A blank picture, with nothing in it.
blank :: Picture

-- | A convex polygon filled with a solid color.
polygon :: Path -> Picture

-- | A line along an arbitrary path.
line :: Path -> Picture

-- | A circle with the given radius.
circle :: Float -> Picture

-- | A circle with the given thickness and radius. If the thickness is 0
--   then this is equivalent to <a>Circle</a>.
thickCircle :: Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in degrees)
--   at the given radius.
arc :: Float -> Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in
--   degrees), with the given radius and thickness. If the thickness is 0
--   then this is equivalent to <a>Arc</a>.
thickArc :: Float -> Float -> Float -> Float -> Picture

-- | Some text to draw with a vector font.
text :: String -> Picture

-- | A bitmap image
bitmap :: BitmapData -> Picture

-- | a subsection of a bitmap image first argument selects a sub section in
--   the bitmap second argument determines the bitmap data
bitmapSection :: Rectangle -> BitmapData -> Picture

-- | A picture drawn with this color.
color :: Color -> Picture -> Picture

-- | A picture translated by the given x and y coordinates.
translate :: Float -> Float -> Picture -> Picture

-- | A picture rotated clockwise by the given angle (in degrees).
rotate :: Float -> Picture -> Picture

-- | A picture scaled by the given x and y factors.
scale :: Float -> Float -> Picture -> Picture

-- | A picture consisting of several others.
pictures :: [Picture] -> Picture

-- | A closed loop along a path.
lineLoop :: Path -> Picture

-- | A solid circle with the given radius.
circleSolid :: Float -> Picture

-- | A solid arc, drawn counter-clockwise between two angles at the given
--   radius.
arcSolid :: Float -> Float -> Float -> Picture

-- | A wireframe sector of a circle. An arc is draw counter-clockwise from
--   the first to the second angle at the given radius. Lines are drawn
--   from the origin to the ends of the arc.
sectorWire :: Float -> Float -> Float -> Picture

-- | A path representing a rectangle centered about the origin
rectanglePath :: Float -> Float -> Path

-- | A wireframe rectangle centered about the origin.
rectangleWire :: Float -> Float -> Picture

-- | A solid rectangle centered about the origin.
rectangleSolid :: Float -> Float -> Picture

-- | A path representing a rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperPath :: Float -> Float -> Path

-- | A wireframe rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperWire :: Float -> Float -> Picture

-- | A solid rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperSolid :: Float -> Float -> Picture

module Graphics.Gloss.Data.ViewPort

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
[viewPortTranslate] :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
[viewPortRotate] :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
[viewPortScale] :: ViewPort -> !Float

-- | The initial state of the viewport.
viewPortInit :: ViewPort

-- | Translates, rotates, and scales an image according to the
--   <a>ViewPort</a>.
applyViewPortToPicture :: ViewPort -> Picture -> Picture

-- | Takes a point using screen coordinates, and uses the <a>ViewPort</a>
--   to convert it to Picture coordinates. This is the inverse of
--   <a>applyViewPortToPicture</a> for points.
invertViewPort :: ViewPort -> Point -> Point

module Graphics.Gloss.Data.Controller

-- | Functions to asynchronously control a <tt>Gloss</tt> display.
data Controller
Controller :: IO () -> ((ViewPort -> IO ViewPort) -> IO ()) -> Controller

-- | Indicate that we want the picture to be redrawn.
[controllerSetRedraw] :: Controller -> IO ()

-- | Modify the current viewport, also indicating that it should be
--   redrawn.
[controllerModifyViewPort] :: Controller -> (ViewPort -> IO ViewPort) -> IO ()


-- | Geometric functions concerning vectors.
module Graphics.Gloss.Data.Vector

-- | A vector can be treated as a point, and vis-versa.
type Vector = Point

-- | The magnitude of a vector.
magV :: Vector -> Float

-- | The angle of this vector, relative to the +ve x-axis.
argV :: Vector -> Float

-- | The dot product of two vectors.
dotV :: Vector -> Vector -> Float

-- | The determinant of two vectors.
detV :: Vector -> Vector -> Float

-- | Multiply a vector by a scalar.
mulSV :: Float -> Vector -> Vector

-- | Rotate a vector by an angle (in radians). +ve angle is
--   counter-clockwise.
rotateV :: Float -> Vector -> Vector

-- | Compute the inner angle (in radians) between two vectors.
angleVV :: Vector -> Vector -> Float

-- | Normalise a vector, so it has a magnitude of 1.
normalizeV :: Vector -> Vector

-- | Produce a unit vector at a given angle relative to the +ve x-axis. The
--   provided angle is in radians.
unitVectorAtAngle :: Float -> Vector

module Graphics.Gloss.Data.Point

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | A path through the x-y plane.
type Path = [Point]

-- | Test whether a point lies within a rectangular box that is oriented on
--   the x-y plane. The points P1-P2 are opposing points of the box, but
--   need not be in a particular order.
--   
--   <pre>
--   P2 +-------+
--      |       |
--      | + P0  |
--      |       |
--      +-------+ P1
--   </pre>
pointInBox :: Point -> Point -> Point -> Bool


-- | Geometric functions concerning lines and segments.
--   
--   A <tt>Line</tt> is taken to be infinite in length, while a
--   <tt>Seg</tt> is finite length line segment represented by its two
--   endpoints.
module Graphics.Gloss.Geometry.Line

-- | Check if line segment (P1-P2) clears a box (P3-P4) by being well
--   outside it.
segClearsBox :: Point -> Point -> Point -> Point -> Bool

-- | Given an infinite line which intersects <tt>P1</tt> and <tt>P1</tt>,
--   return the point on that line that is closest to <tt>P3</tt>
closestPointOnLine :: Point -> Point -> Point -> Point

-- | Given an infinite line which intersects P1 and P2, let P4 be the point
--   on the line that is closest to P3.
--   
--   Return an indication of where on the line P4 is relative to P1 and P2.
--   
--   <pre>
--   if P4 == P1 then 0
--   if P4 == P2 then 1
--   if P4 is halfway between P1 and P2 then 0.5
--   </pre>
--   
--   <pre>
--      |
--     P1
--      |
--   P4 +---- P3
--      |
--     P2
--      |
--   </pre>
closestPointOnLineParam :: Point -> Point -> Point -> Float

-- | Given four points specifying two lines, get the point where the two
--   lines cross, if any. Note that the lines extend off to infinity, so
--   the intersection point might not line between either of the two pairs
--   of points.
--   
--   <pre>
--   \      /
--    P1  P4
--     \ /
--      +
--     / \
--    P3  P2
--   /     \
--   </pre>
intersectLineLine :: Point -> Point -> Point -> Point -> Maybe Point

-- | Get the point where a segment <tt>P1-P2</tt> crosses an infinite line
--   <tt>P3-P4</tt>, if any.
intersectSegLine :: Point -> Point -> Point -> Point -> Maybe Point

-- | Get the point where a segment crosses a horizontal line, if any.
--   
--   <pre>
--            + P1
--           /
--   -------+---------
--         /        y0
--     P2 +
--   </pre>
intersectSegHorzLine :: Point -> Point -> Float -> Maybe Point

-- | Get the point where a segment crosses a vertical line, if any.
--   
--   <pre>
--          |
--          |   + P1
--          | /
--          +
--        / |
--   P2 +   |
--          | x0
--   </pre>
intersectSegVertLine :: Point -> Point -> Float -> Maybe Point

-- | Get the point where a segment <tt>P1-P2</tt> crosses another segement
--   <tt>P3-P4</tt>, if any.
intersectSegSeg :: Point -> Point -> Point -> Point -> Maybe Point

-- | Check if an arbitrary segment intersects a horizontal segment.
--   
--   <pre>
--                   + P2
--                  /
--   (xa, y3)  +---+----+ (xb, y3)
--                /
--            P1 +
--   </pre>
intersectSegHorzSeg :: Point -> Point -> Float -> Float -> Float -> Maybe Point

-- | Check if an arbitrary segment intersects a vertical segment.
--   
--   <pre>
--   (x3, yb) +
--            |   + P1
--            | /
--            +
--          / |
--     P2 +   |
--            + (x3, ya)
--   </pre>
intersectSegVertSeg :: Point -> Point -> Float -> Float -> Float -> Maybe Point

module Graphics.Gloss.Interface.Environment

-- | Get the size of the screen, in pixels.
--   
--   This will be the size of the rendered gloss image when fullscreen mode
--   is enabled.
getScreenSize :: IO (Int, Int)

module Graphics.Gloss.Data.ViewState

-- | The commands suported by the view controller.
data Command
CRestore :: Command
CTranslate :: Command
CRotate :: Command
CScale :: Command
CBumpZoomOut :: Command
CBumpZoomIn :: Command
CBumpLeft :: Command
CBumpRight :: Command
CBumpUp :: Command
CBumpDown :: Command
CBumpClockwise :: Command
CBumpCClockwise :: Command
type CommandConfig = [(Command, [(Key, Maybe Modifiers)])]

-- | The default commands. Left click pans, wheel zooms, right click
--   rotates, "r" key resets.
defaultCommandConfig :: CommandConfig

-- | State for controlling the viewport. These are used by the viewport
--   control component.
data ViewState
ViewState :: !Map Command [(Key, Maybe Modifiers)] -> !Float -> !Float -> !Float -> !Maybe (Float, Float) -> !Maybe (Float, Float) -> !Maybe (Float, Float) -> ViewPort -> ViewState

-- | The command list for the viewport controller. These can be safely
--   overwridden at any time by deleting or adding entries to the list.
--   Entries at the front of the list take precedence.
[viewStateCommands] :: ViewState -> !Map Command [(Key, Maybe Modifiers)]

-- | How much to scale the world by for each step of the mouse wheel.
[viewStateScaleStep] :: ViewState -> !Float

-- | How many degrees to rotate the world by for each pixel of x motion.
[viewStateRotateFactor] :: ViewState -> !Float

-- | Ratio to scale the world by for each pixel of y motion.
[viewStateScaleFactor] :: ViewState -> !Float

-- | During viewport translation, where the mouse was clicked on the window
--   to start the translate.
[viewStateTranslateMark] :: ViewState -> !Maybe (Float, Float)

-- | During viewport rotation, where the mouse was clicked on the window to
--   starte the rotate.
[viewStateRotateMark] :: ViewState -> !Maybe (Float, Float)

-- | During viewport scale, where the mouse was clicked on the window to
--   start the scale.
[viewStateScaleMark] :: ViewState -> !Maybe (Float, Float)

-- | The current viewport.
[viewStateViewPort] :: ViewState -> ViewPort

-- | The initial view state.
viewStateInit :: ViewState

-- | Initial view state, with user defined config.
viewStateInitWithConfig :: CommandConfig -> ViewState

-- | Apply an event to a <a>ViewState</a>.
updateViewStateWithEvent :: Event -> ViewState -> ViewState

-- | Like <a>updateViewStateWithEvent</a>, but returns <a>Nothing</a> if no
--   update was needed.
updateViewStateWithEventMaybe :: Event -> ViewState -> Maybe ViewState
instance GHC.Classes.Ord Graphics.Gloss.Data.ViewState.Command
instance GHC.Classes.Eq Graphics.Gloss.Data.ViewState.Command
instance GHC.Show.Show Graphics.Gloss.Data.ViewState.Command


-- | Simulate mode is for producing an animation of some model who's
--   picture changes over finite time steps. The behavior of the model can
--   also depent on the current <a>ViewPort</a>.
module Graphics.Gloss.Interface.Pure.Simulate

-- | Run a finite-time-step simulation in a window. You decide how the
--   model is represented, how to convert the model to a picture, and how
--   to advance the model for each unit of time. This function does the
--   rest.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
simulate :: Display -> Color -> Int -> model -> (model -> Picture) -> (ViewPort -> Float -> model -> model) -> IO ()

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
[viewPortTranslate] :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
[viewPortRotate] :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
[viewPortScale] :: ViewPort -> !Float


-- | Simulate mode is for producing an animation of some model who's
--   picture changes over finite time steps. The behavior of the model can
--   also depent on the current <a>ViewPort</a>.
module Graphics.Gloss.Interface.IO.Simulate
simulateIO :: forall model. Display -> Color -> Int -> model -> (model -> IO Picture) -> (ViewPort -> Float -> model -> IO model) -> IO ()

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
[viewPortTranslate] :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
[viewPortRotate] :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
[viewPortScale] :: ViewPort -> !Float


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.IO.Interact

-- | Open a new window and interact with an infrequently updated picture.
--   
--   Similar to <tt>displayIO</tt>, except that you manage your own events.
interactIO :: Display -> Color -> world -> (world -> IO Picture) -> (Event -> world -> IO world) -> (Controller -> IO ()) -> IO ()

-- | Functions to asynchronously control a <tt>Gloss</tt> display.
data Controller
Controller :: IO () -> ((ViewPort -> IO ViewPort) -> IO ()) -> Controller

-- | Indicate that we want the picture to be redrawn.
[controllerSetRedraw] :: Controller -> IO ()

-- | Modify the current viewport, also indicating that it should be
--   redrawn.
[controllerModifyViewPort] :: Controller -> (ViewPort -> IO ViewPort) -> IO ()

-- | Possible input events.
data Event
EventKey :: Key -> KeyState -> Modifiers -> (Float, Float) -> Event
EventMotion :: (Float, Float) -> Event
EventResize :: (Int, Int) -> Event
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key
data SpecialKey
KeyUnknown :: SpecialKey
KeySpace :: SpecialKey
KeyEsc :: SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyF13 :: SpecialKey
KeyF14 :: SpecialKey
KeyF15 :: SpecialKey
KeyF16 :: SpecialKey
KeyF17 :: SpecialKey
KeyF18 :: SpecialKey
KeyF19 :: SpecialKey
KeyF20 :: SpecialKey
KeyF21 :: SpecialKey
KeyF22 :: SpecialKey
KeyF23 :: SpecialKey
KeyF24 :: SpecialKey
KeyF25 :: SpecialKey
KeyUp :: SpecialKey
KeyDown :: SpecialKey
KeyLeft :: SpecialKey
KeyRight :: SpecialKey
KeyTab :: SpecialKey
KeyEnter :: SpecialKey
KeyBackspace :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey
KeyPad0 :: SpecialKey
KeyPad1 :: SpecialKey
KeyPad2 :: SpecialKey
KeyPad3 :: SpecialKey
KeyPad4 :: SpecialKey
KeyPad5 :: SpecialKey
KeyPad6 :: SpecialKey
KeyPad7 :: SpecialKey
KeyPad8 :: SpecialKey
KeyPad9 :: SpecialKey
KeyPadDivide :: SpecialKey
KeyPadMultiply :: SpecialKey
KeyPadSubtract :: SpecialKey
KeyPadAdd :: SpecialKey
KeyPadDecimal :: SpecialKey
KeyPadEqual :: SpecialKey
KeyPadEnter :: SpecialKey
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton
data KeyState
Down :: KeyState
Up :: KeyState
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
[shift] :: Modifiers -> KeyState
[ctrl] :: Modifiers -> KeyState
[alt] :: Modifiers -> KeyState


-- | This game mode lets you manage your own input. Pressing ESC will still
--   abort the program, but you don't get automatic pan and zoom controls
--   like with <tt>displayInWindow</tt>.
module Graphics.Gloss.Interface.Pure.Game

-- | Play a game in a window. Like <tt>simulate</tt>, but you manage your
--   own input events.
play :: Display -> Color -> Int -> world -> (world -> Picture) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()

-- | Possible input events.
data Event
EventKey :: Key -> KeyState -> Modifiers -> (Float, Float) -> Event
EventMotion :: (Float, Float) -> Event
EventResize :: (Int, Int) -> Event
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key
data SpecialKey
KeyUnknown :: SpecialKey
KeySpace :: SpecialKey
KeyEsc :: SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyF13 :: SpecialKey
KeyF14 :: SpecialKey
KeyF15 :: SpecialKey
KeyF16 :: SpecialKey
KeyF17 :: SpecialKey
KeyF18 :: SpecialKey
KeyF19 :: SpecialKey
KeyF20 :: SpecialKey
KeyF21 :: SpecialKey
KeyF22 :: SpecialKey
KeyF23 :: SpecialKey
KeyF24 :: SpecialKey
KeyF25 :: SpecialKey
KeyUp :: SpecialKey
KeyDown :: SpecialKey
KeyLeft :: SpecialKey
KeyRight :: SpecialKey
KeyTab :: SpecialKey
KeyEnter :: SpecialKey
KeyBackspace :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey
KeyPad0 :: SpecialKey
KeyPad1 :: SpecialKey
KeyPad2 :: SpecialKey
KeyPad3 :: SpecialKey
KeyPad4 :: SpecialKey
KeyPad5 :: SpecialKey
KeyPad6 :: SpecialKey
KeyPad7 :: SpecialKey
KeyPad8 :: SpecialKey
KeyPad9 :: SpecialKey
KeyPadDivide :: SpecialKey
KeyPadMultiply :: SpecialKey
KeyPadSubtract :: SpecialKey
KeyPadAdd :: SpecialKey
KeyPadDecimal :: SpecialKey
KeyPadEqual :: SpecialKey
KeyPadEnter :: SpecialKey
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton
data KeyState
Down :: KeyState
Up :: KeyState
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
[shift] :: Modifiers -> KeyState
[ctrl] :: Modifiers -> KeyState
[alt] :: Modifiers -> KeyState


-- | This game mode lets you manage your own input. Pressing ESC will not
--   abort the program. You also don't get automatic pan and zoom controls
--   like with <tt>display</tt>.
module Graphics.Gloss.Interface.IO.Game

-- | Play a game in a window, using IO actions to build the pictures.
playIO :: forall world. Display -> Color -> Int -> world -> (world -> IO Picture) -> (Event -> world -> IO world) -> (Float -> world -> IO world) -> IO ()

-- | Possible input events.
data Event
EventKey :: Key -> KeyState -> Modifiers -> (Float, Float) -> Event
EventMotion :: (Float, Float) -> Event
EventResize :: (Int, Int) -> Event
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key
data SpecialKey
KeyUnknown :: SpecialKey
KeySpace :: SpecialKey
KeyEsc :: SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyF13 :: SpecialKey
KeyF14 :: SpecialKey
KeyF15 :: SpecialKey
KeyF16 :: SpecialKey
KeyF17 :: SpecialKey
KeyF18 :: SpecialKey
KeyF19 :: SpecialKey
KeyF20 :: SpecialKey
KeyF21 :: SpecialKey
KeyF22 :: SpecialKey
KeyF23 :: SpecialKey
KeyF24 :: SpecialKey
KeyF25 :: SpecialKey
KeyUp :: SpecialKey
KeyDown :: SpecialKey
KeyLeft :: SpecialKey
KeyRight :: SpecialKey
KeyTab :: SpecialKey
KeyEnter :: SpecialKey
KeyBackspace :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey
KeyPad0 :: SpecialKey
KeyPad1 :: SpecialKey
KeyPad2 :: SpecialKey
KeyPad3 :: SpecialKey
KeyPad4 :: SpecialKey
KeyPad5 :: SpecialKey
KeyPad6 :: SpecialKey
KeyPad7 :: SpecialKey
KeyPad8 :: SpecialKey
KeyPad9 :: SpecialKey
KeyPadDivide :: SpecialKey
KeyPadMultiply :: SpecialKey
KeyPadSubtract :: SpecialKey
KeyPadAdd :: SpecialKey
KeyPadDecimal :: SpecialKey
KeyPadEqual :: SpecialKey
KeyPadEnter :: SpecialKey
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton
data KeyState
Down :: KeyState
Up :: KeyState
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
[shift] :: Modifiers -> KeyState
[ctrl] :: Modifiers -> KeyState
[alt] :: Modifiers -> KeyState


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.Pure.Display

-- | Open a new window and display the given picture.
display :: Display -> Color -> Picture -> IO ()


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.IO.Display

-- | Open a new window and display an infrequently updated picture.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
--   
--   <ul>
--   <li>This wrapper is intended for mostly static pictures that do not
--   need to be updated more than once per second. For example, the picture
--   could show network activity over the last minute, a daily stock price,
--   or a weather forecast. If you want to show a real-time animation where
--   the frames are redrawn more frequently then use the <tt>animate</tt>
--   wrapper instead.</li>
--   <li>The provided picture generating action will be invoked, and the
--   display redrawn in two situation: 1) We receive a display event, like
--   someone clicks on the window. 2) When <a>controllerSetRedraw</a> has
--   been set, some indeterminate time between the last redraw, and one
--   second from that.</li>
--   <li>Note that calling <a>controllerSetRedraw</a> indicates that the
--   picture should be redrawn, but does not cause this to happen
--   immediately, due to limitations in the GLUT and GLFW window managers.
--   The display runs on a one second timer interrupt, and if there have
--   been no display events we need to wait for the next timer interrupt
--   before redrawing. Having the timer interrupt period at 1 second keeps
--   the CPU usage due to the context switches at under 1%.</li>
--   <li>Also note that the picture generating action is called for every
--   display event, so if the user pans the display then it will be invoked
--   at 10hz or more during the pan. If you are generating the picture by
--   reading some on-disk files then you should track when the files were
--   last updated and cache the picture between updates. Caching the
--   picture avoids repeatedly reading and re-parsing your files during a
--   pan. Consider storing your current picture in an IORef, passing an
--   action that just reads this IORef, and forking a new thread that
--   watches your files for updates.</li>
--   </ul>
displayIO :: Display -> Color -> IO Picture -> (Controller -> IO ()) -> IO ()

-- | Functions to asynchronously control a <tt>Gloss</tt> display.
data Controller
Controller :: IO () -> ((ViewPort -> IO ViewPort) -> IO ()) -> Controller

-- | Indicate that we want the picture to be redrawn.
[controllerSetRedraw] :: Controller -> IO ()

-- | Modify the current viewport, also indicating that it should be
--   redrawn.
[controllerModifyViewPort] :: Controller -> (ViewPort -> IO ViewPort) -> IO ()


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.Pure.Animate

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animate :: Display -> Color -> (Float -> Picture) -> IO ()


-- | Gloss hides the pain of drawing simple vector graphics behind a nice
--   data type and a few display functions.
--   
--   Getting something on the screen is as easy as:
--   
--   <pre>
--   import Graphics.Gloss
--   main = <a>display</a> (InWindow "Nice Window" (200, 200) (10, 10)) <a>white</a> (<a>Circle</a> 80)
--   
--   </pre>
--   
--   Once the window is open you can use the following:
--   
--   <pre>
--   * Quit
--     - esc-key
--   
--   * Move Viewport
--     - arrow keys
--     - left-click drag
--   
--   * Zoom Viewport
--     - page up/down-keys
--     - control-left-click drag
--     - right-click drag
--     - mouse wheel
--   
--   * Rotate Viewport
--     - home/end-keys
--     - alt-left-click drag
--   
--   * Reset Viewport
--     <tt>r</tt>-key
--   </pre>
--   
--   Animations can be constructed similarly using the <a>animate</a>.
--   
--   If you want to run a simulation based around finite time steps then
--   try <a>simulate</a>.
--   
--   If you want to manage your own key/mouse events then use <a>play</a>.
--   
--   Gloss uses OpenGL under the hood, but you don't have to worry about
--   any of that.
--   
--   Gloss programs should be compiled with <tt>-threaded</tt>, otherwise
--   the GHC runtime will limit the frame-rate to around 20Hz.
--   
--   To build gloss using the GLFW window manager instead of GLUT use
--   <tt>cabal install gloss --flags="GLFW -GLUT"</tt>
--   
--   <pre>
--   Release Notes:
--   
--    For 1.13.1:
--     Thanks to Thaler Jonathan
--     * Repaired GLFW backend.
--     Thanks to Samuel Gfrörer
--     * Support for bitmap sections.
--     Thanks to Basile Henry
--     * Handle resize events in playField driver.
--   
--    For 1.12.1:
--     Thanks to Trevor McDonell
--     * Travis CI integration, general cleanups.
--   
--    For 1.11.1:
--     Thanks to Lars Wyssard
--     * Use default display resolution in full-screen mode.
--   
--    For 1.10.1:
--     * Gloss no longer consumes CPU time when displaying static pictures.
--     * Added displayIO wrapper for mostly static pictures, eg when
--       plotting graphs generated from infrequently updated files.
--     * Allow viewport to be scaled with control-left-click drag.
--     * Rotation of viewport changed to alt-left-click drag.
--     * Preserve current colour when rendering bitmpaps.
--     * Changed to proper sum-of-squares colour mixing, rather than naive
--       addition of components which was causing mixed colours to be too dark.
--    Thanks to Thomas DuBuisson
--     * Allow bitmaps to be specified in RGBA byte order as well as ABGR.
--    Thanks to Gabriel Gonzalez
--     * Package definitions for building with Stack.
--   </pre>
--   
--   For more information, check out <a>http://gloss.ouroborus.net</a>.
module Graphics.Gloss

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen.
FullScreen :: Display

-- | Open a new window and display the given picture.
display :: Display -> Color -> Picture -> IO ()

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animate :: Display -> Color -> (Float -> Picture) -> IO ()

-- | Run a finite-time-step simulation in a window. You decide how the
--   model is represented, how to convert the model to a picture, and how
--   to advance the model for each unit of time. This function does the
--   rest.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
simulate :: Display -> Color -> Int -> model -> (model -> Picture) -> (ViewPort -> Float -> model -> model) -> IO ()

-- | Play a game in a window. Like <tt>simulate</tt>, but you manage your
--   own input events.
play :: Display -> Color -> Int -> world -> (world -> Picture) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()


-- | Animate a picture in a window.
module Graphics.Gloss.Interface.IO.Animate

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animateIO :: Display -> Color -> (Float -> IO Picture) -> (Controller -> IO ()) -> IO ()

-- | Like <a>animateIO</a> but don't allow the display to be panned around.
animateFixedIO :: Display -> Color -> (Float -> IO Picture) -> (Controller -> IO ()) -> IO ()

-- | Functions to asynchronously control a <tt>Gloss</tt> display.
data Controller
Controller :: IO () -> ((ViewPort -> IO ViewPort) -> IO ()) -> Controller

-- | Indicate that we want the picture to be redrawn.
[controllerSetRedraw] :: Controller -> IO ()

-- | Modify the current viewport, also indicating that it should be
--   redrawn.
[controllerModifyViewPort] :: Controller -> (ViewPort -> IO ViewPort) -> IO ()
