-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFT using the Accelerate library
--   
--   Rank-polymorphic discrete Fourier transform (DFT), computed with a
--   fast Fourier transform (FFT) algorithm using the Accelerate library.
--   Note that optimised implementations are available via foreign
--   libraries, but must be explicitly enabled.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-fft
@version 2.0.0.0


-- | These transforms allow the centering of the frequency domain of a DFT
--   such that the the zero frequency is in the middle. The centering
--   transform, when performed on the input of a DFT, will cause zero
--   frequency to be centred in the middle. The shifting transform however
--   takes the output of a DFT to give the same result. Therefore the
--   relationship between the two is:
--   
--   <pre>
--   fft(center(X)) = shift(fft(X))
--   </pre>
module Data.Array.Accelerate.Math.DFT.Centre

-- | Apply the centring transform to a vector
centre1D :: (RealFloat e, FromIntegral Int e) => Acc (Array DIM1 (Complex e)) -> Acc (Array DIM1 (Complex e))

-- | Apply the centring transform to a matrix
centre2D :: (RealFloat e, FromIntegral Int e) => Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))

-- | Apply the centring transform to a 3D array
centre3D :: (RealFloat e, FromIntegral Int e) => Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))

-- | Apply the shifting transform to a vector
shift1D :: Elt e => Acc (Vector e) -> Acc (Vector e)

-- | Apply the shifting transform to a 2D array
shift2D :: Elt e => Acc (Array DIM2 e) -> Acc (Array DIM2 e)

-- | Apply the shifting transform to a 3D array
shift3D :: Elt e => Acc (Array DIM3 e) -> Acc (Array DIM3 e)


module Data.Array.Accelerate.Math.DFT.Roots

-- | Calculate the roots of unity for the forward transform
rootsOfUnity :: (Shape sh, Slice sh, Floating e, FromIntegral Int e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))

-- | Calculate the roots of unity for an inverse transform
inverseRootsOfUnity :: (Shape sh, Slice sh, Floating e, FromIntegral Int e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e))


-- | Compute the Discrete Fourier Transform (DFT) along the lower order
--   dimension of an array.
--   
--   This uses a naïve algorithm which takes O(n^2) time. However, you can
--   transform an array with an arbitrary extent, unlike with FFT which
--   requires each dimension to be a power of two.
--   
--   The <a>dft</a> and <a>idft</a> functions compute the roots of unity as
--   needed. If you need to transform several arrays with the same extent
--   than it is faster to compute the roots once using <a>rootsOfUnity</a>
--   or <a>inverseRootsOfUnity</a> respectively, then call <a>dftG</a>
--   directly.
--   
--   You can also compute single values of the transform using <a>dftGS</a>
module Data.Array.Accelerate.Math.DFT

-- | Compute the DFT along the low order dimension of an array
dft :: (Shape sh, Slice sh, RealFloat e, FromIntegral Int e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute the inverse DFT along the low order dimension of an array
idft :: (Shape sh, Slice sh, RealFloat e, FromIntegral Int e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Generic function for computation of forward and inverse DFT. This
--   function is also useful if you transform many arrays of the same
--   extent, and don't want to recompute the roots for each one.
--   
--   The extent of the input and roots must match.
dftG :: forall sh e. (Shape sh, Slice sh, RealFloat e) => Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))

-- | Compute a single value of the DFT.
dftGS :: forall sh e. (Shape sh, Slice sh, RealFloat e) => Exp (sh :. Int) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Scalar (Complex e))


-- | Computation of a Discrete Fourier Transform using the Cooley-Tuckey
--   algorithm. The time complexity is O(n log n) in the size of the input.
--   
--   The base (default) implementation uses a naïve divide-and-conquer
--   algorithm whose absolute performance is appalling. It also requires
--   that you know on the Haskell side the size of the data being
--   transformed, and that this is a power-of-two in each dimension.
--   
--   For performance, compile against the foreign library bindings (using
--   any number of '-fcuda', '-fllvm-gpu', and '-fllvm-cpu' for the
--   accelerate-cuda, accelerate-llvm-ptx, and accelerate-llvm-native
--   backends respectively), which have none of the above restrictions.
module Data.Array.Accelerate.Math.FFT
data Mode

-- | Forward DFT
Forward :: Mode

-- | Inverse DFT, un-normalised
Reverse :: Mode

-- | Inverse DFT, normalised
Inverse :: Mode
type FFTElt e = (Num e, RealFloat e, FromIntegral Int e, IsFloating e)

-- | Discrete Fourier Transform of a vector.
--   
--   The default implementation requires the array dimension to be a power
--   of two (else error).
fft1D :: FFTElt e => Mode -> Array DIM1 (Complex e) -> Acc (Array DIM1 (Complex e))

-- | Discrete Fourier Transform of a vector.
--   
--   The default implementation requires the array dimension to be a power
--   of two. The FFI-backed implementations ignore the Haskell-side size
--   parameter (second argument).
fft1D' :: forall e. FFTElt e => Mode -> DIM1 -> Acc (Array DIM1 (Complex e)) -> Acc (Array DIM1 (Complex e))

-- | Discrete Fourier Transform of a matrix.
--   
--   The default implementation requires the array dimensions to be powers
--   of two (else error).
fft2D :: FFTElt e => Mode -> Array DIM2 (Complex e) -> Acc (Array DIM2 (Complex e))

-- | Discrete Fourier Transform of a matrix.
--   
--   The default implementation requires the array dimensions to be powers
--   of two. The FFI-backed implementations ignore the Haskell-side size
--   parameter (second argument).
fft2D' :: forall e. FFTElt e => Mode -> DIM2 -> Acc (Array DIM2 (Complex e)) -> Acc (Array DIM2 (Complex e))

-- | Discrete Fourier Transform of a 3D array.
--   
--   The default implementation requires the array dimensions to be powers
--   of two (else error).
fft3D :: FFTElt e => Mode -> Array DIM3 (Complex e) -> Acc (Array DIM3 (Complex e))

-- | Discrete Fourier Transform of a 3D array.
--   
--   The default implementation requires the array dimensions to be powers
--   of two. The FFI-backed implementations ignore the Haskell-side size
--   parameter (second argument).
fft3D' :: forall e. FFTElt e => Mode -> DIM3 -> Acc (Array DIM3 (Complex e)) -> Acc (Array DIM3 (Complex e))
fft :: forall sh e. (Slice sh, Shape sh, RealFloat e, FromIntegral Int e) => e -> sh -> Int -> Acc (Array (sh :. Int) (Complex e)) -> Acc (Array (sh :. Int) (Complex e))
