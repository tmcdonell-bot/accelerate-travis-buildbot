-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Read and write Accelerate arrays in various formats
--   
--   This package provides efficient conversion routines between a range of
--   array types and Accelerate arrays.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-io
@version 1.1.0.0


-- | Convert between immutable <a>IArray</a>s and Accelerate <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Array.IArray

-- | <i>O(n)</i>. Convert an <a>IArray</a> to an Accelerate <a>Array</a>.
--   
--   The index type <tt>ix</tt> of the <a>IArray</a> corresponds to the
--   shape <tt>sh</tt> of the Accelerate <a>Array</a> in the following way:
--   
--   <pre>
--   DIM0 ~ ()
--   DIM1 ~ Int
--   DIM2 ~ (Int,Int)
--   DIM3 ~ (Int,Int,Int)
--   </pre>
--   
--   ...and so forth.
fromIArray :: (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray a e, Ix ix, Shape sh, Elt ix, Elt e) => a ix e -> Array sh e

-- | <i>O(n)</i>. Convert an Accelerate <a>Array</a> to an <a>IArray</a>.
--   
--   See <a>fromIArray</a> for a discussion on the expected shape types.
toIArray :: forall ix sh a e. (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray a e, Ix ix, Shape sh, Elt ix) => Maybe ix -> Array sh e -> a ix e


-- | Conversion between strict <a>ByteString</a>s and Accelerate
--   <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.ByteString

-- | A family of types that represents a collection of <a>ByteString</a>s.
--   The structure of the collection depends on the element type
--   <tt>e</tt>.

-- | <i>O(1)</i>. Treat a set of strict <a>ByteStrings</a> as an Accelerate
--   array. The type of the elements <tt>e</tt> in the output Accelerate
--   array determines the structure of the collection.
--   
--   Data is considered to be in row-major order. You must ensure that each
--   input contains the right number of bytes (this is not checked).
--   
--   The input data may not be modified through the <a>ByteString</a>s
--   afterwards.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromByteStrings :: (Shape sh, Elt e) => sh -> ByteStrings (EltRepr e) -> Array sh e

-- | <i>O(1)</i>. Convert an Accelerate <a>Array</a> into a collection of
--   strict <a>ByteStrings</a>. The element type <tt>e</tt> will determine
--   the structure of the output collection.
--   
--   Data is considered to be in row-major order.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toByteStrings :: (Shape sh, Elt e) => Array sh e -> ByteStrings (EltRepr e)


-- | Read and write uncompressed 24 or 32-bit Windows BMP images into a
--   packed-word RGBA format. See the <i>colour-accelerate</i> package for
--   colour representations and utilities such as packing and unpacking.
module Data.Array.Accelerate.IO.Codec.BMP

-- | Packed RGBA pixel data
type RGBA32 = Word32

-- | Read RGBA components from a BMP file.
readImageFromBMP :: FilePath -> IO (Either Error (Array DIM2 RGBA32))

-- | Write the image data to a file.
writeImageToBMP :: FilePath -> Array DIM2 RGBA32 -> IO ()


-- | Efficient conversion between <a>Primitive</a> vectors and Accelerate
--   <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Primitive

-- | A family of types which represent a collection of Primitive Vectors.
--   The structure of the collection depends on the element type <tt>e</tt>
--   of the corresponding Accelerate array.

-- | <i>O(1)</i> (typically). Convert an Accelerate array into a collection
--   of primitive vectors.
--   
--   If the array data was allocated by Accelerate, this can typically be
--   done without copying.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toVectors :: (Shape sh, Elt e) => Array sh e -> Vectors (EltRepr e)

-- | <i>O(n)</i> (typically). Convert a collection of primitive vectors
--   into an Accelerate array.
--   
--   If the underlying vectors are pinned then this can be done without.
--   
--   See also: <a>https://ghc.haskell.org/trac/ghc/ticket/5556</a>
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromVectors :: (Shape sh, Elt e) => sh -> Vectors (EltRepr e) -> Array sh e


-- | Efficient conversion between immutable unboxed <a>IArray</a>s and
--   Accelerate <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Array.Unboxed

-- | <i>O(n)</i>. Convert an unboxed <a>UArray</a> into an Accelerate
--   array.
--   
--   See <a>fromIArray</a> for more information about the array index type.
--   
--   If the underlying vectors are pinned then this can be done without
--   copying.
--   
--   See also: <a>https://ghc.haskell.org/trac/ghc/ticket/5556</a>
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromUArray :: forall ix sh e. (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray UArray e, Ix ix, Shape sh, Elt ix, Elt e) => UArray ix e -> Array sh e

-- | <i>O(1)</i> (typically). Convert an Accelerate <a>Array</a> to an
--   unboxed <a>UArray</a>.
--   
--   See <a>fromIArray</a> for more information about the array index type.
--   
--   If the array data was allocated by Accelerate, this can typically be
--   done without copying.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toUArray :: forall ix sh e. (IxShapeRepr (EltRepr ix) ~ EltRepr sh, IArray UArray e, Ix ix, Shape sh, Elt ix) => Maybe ix -> Array sh e -> UArray ix e


-- | Efficient non-copying conversion between <a>Storable</a> vectors and
--   Accelerate <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Storable

-- | A family of types that represents a collection of storable
--   <a>Vector</a>s. The structure of the collection depends on the element
--   type <tt>e</tt>.
--   
--   For example:
--   
--   <ul>
--   <li>if <tt>e :: Int</tt>, then <tt>Vectors (EltRepr e) :: Vector
--   Int</tt></li>
--   <li>if <tt>e :: (Double, Float)</tt>, then <tt>Vectors (EltRepr e) ::
--   (((), Vector Double), Vector Float)</tt></li>
--   </ul>

-- | <i>O(1)</i>. Turn the Accelerate array into a collection of storable
--   <a>Vector</a>s. The element type of the array <tt>e</tt> will
--   determine the structure of the output collection. See <a>Vectors</a>.
--   
--   Data will be output in row-major order.
toVectors :: (Shape sh, Elt e) => Array sh e -> Vectors (EltRepr e)

-- | <i>O(1)</i>. Treat a set of storable vectors as Accelerate arrays. The
--   type of elements <tt>e</tt> in the output Accelerate array determines
--   the structure of the collection that will be required as the second
--   argument. See <a>Vectors</a>.
--   
--   Data will be consumed from the vector in row-major order. You must
--   make sure that each of the input vectors contains the right number of
--   elements
fromVectors :: (Shape sh, Elt e) => sh -> Vectors (EltRepr e) -> Array sh e


-- | Efficient conversion between <a>Unboxed</a> vectors and Accelerate
--   <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Unboxed
class (Unbox e, Elt e) => Unbox e
arrayDataOfUnboxed :: Unbox e => Vector e -> ArrayData (EltRepr e)
unboxedOfArrayData :: Unbox e => Int -> ArrayData (EltRepr e) -> Vector e

-- | <i>O(1)</i> (typically). Convert an Accelerate array into an Unboxed
--   vector.
--   
--   If the array data was allocated by Accelerate, this can typically be
--   done without copying. The resulting vector will be pinned.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toUnboxed :: (Shape sh, Unbox e) => Array sh e -> Vector e

-- | <i>O(n)</i> (typically). Convert an Unboxed vector into an Accelerate
--   array Accelerate array.
--   
--   If the underlying vectors are pinned then this can be done without
--   copying.
--   
--   See also: <a>https://ghc.haskell.org/trac/ghc/ticket/5556</a>
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromUnboxed :: Unbox e => Vector e -> Array DIM1 e
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Int
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int8
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int16
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int32
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int64
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Word
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word8
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word16
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word32
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word64
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Float
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Double
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Char
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Bool
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox ()
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox e) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d, e)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox e, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox f) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d, e, f)
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (Data.Complex.Complex a)


module Data.Array.Accelerate.IO.Foreign.ForeignPtr

-- | A family of types which represent a collection of <a>ForeignPtr</a>s.
--   The structure of the collection depends on the element type
--   <tt>e</tt>.

-- | <i>O(1)</i>. Treat the set of <a>ForeignPtrs</a> as an Accelerate
--   array. The type of elements <tt>e</tt> in the output Accelerate array
--   determines the structure of the collection.
--   
--   Data is considered to be in row-major order. You must ensure that each
--   of the input pointers contains the right number of elements.
--   
--   The data may not be modified through the <a>ForeignPtr</a>s
--   afterwards.
--   
--   You should make sure that the data is suitably aligned.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromForeignPtrs :: (Shape sh, Elt e) => sh -> ForeignPtrs (EltRepr e) -> Array sh e

-- | <i>O(1)</i>. Yield the <a>ForeignPtr</a>s underlying the given
--   Accelerate <a>Array</a>. The element type <tt>e</tt> will determine
--   the structure of the output collection.
--   
--   Data is considered to be in row-major order.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toForeignPtrs :: (Shape sh, Elt e) => Array sh e -> ForeignPtrs (EltRepr e)


module Data.Array.Accelerate.IO.Foreign.Ptr

-- | A family of types which represent a collection of <a>Ptr</a>s. The
--   structure of the collection depends on the element type <tt>e</tt>.
type Ptrs e = ArrayPtrs e

-- | <i>O(1)</i>. Treat the set of <a>Ptrs</a> as an Accelerate array. The
--   type of elements <tt>e</tt> in the output Accelerate array determines
--   the structure of the collection.
--   
--   Data is considered to be in row-major order. You must ensure that each
--   of the input pointers contains the right number of elements.
--   
--   The data may not be modified through the <a>Ptrs</a> afterwards.
--   
--   You are responsible for ensuring that the data remains alive for the
--   duration of the Accelerate computation, and for freeing it afterwards.
--   
--   You should make sure that the data is suitably aligned.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromPtrs :: (Shape sh, Elt e) => sh -> Ptrs (EltRepr e) -> Array sh e

-- | <i>O(1)</i>. Yield the underlying <a>Ptrs</a> backing the given
--   Accelerate array. The element type <tt>e</tt> will determine the
--   structure of the output collection.
--   
--   Data is considered to be in row-major order.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toPtrs :: (Shape sh, Elt e) => Array sh e -> Ptrs (EltRepr e)


-- | This provides an efficient non-copying Repa manifest array
--   representation that can be passed directly to Accelerate.
--   
--   The standard rules for dealing with manifest Repa arrays apply:
--   
--   <ul>
--   <li>If you want to have Repa <a>computeP</a> directly into an
--   Accelerate array, the source array must have a delayed
--   representation.</li>
--   <li>If you want to copy between manifest arrays, use <a>copyP</a>
--   instead.</li>
--   </ul>
module Data.Array.Repa.Repr.Accelerate

-- | The representation tag for manifest arrays based on
--   Data.Array.Accelerate.
--   
--   The Accelerate array implementation is based on type families and
--   picks an efficient, unboxed representation for every element type.
--   Moreover, these arrays can be handed efficiently (without copying) to
--   Accelerate programs for further computation.
data A

-- | Index conversion and equivalence statement between Repa and Accelerate
--   array shapes. That is, a n-dimensional Repa array will produce an
--   n-dimensional Accelerate array of the same extent, and vice-versa.
class (Shape r, Shape a) => Shapes r a | a -> r, r -> a

-- | <i>O(1)</i>. Unpack to an Accelerate array.
fromRepa :: (Shapes sh sh', Elt e) => Array A sh e -> Array sh' e

-- | <i>O(1)</i>. Wrap an Accelerate array.
toRepa :: Shapes sh sh' => Array sh' e -> Array A sh e

-- | Sequential computation of array elements
computeAccS :: (Load r sh e, Elt e) => Array r sh e -> Array A sh e

-- | Parallel computation of array elements
computeAccP :: (Load r sh e, Elt e, Monad m) => Array r sh e -> m (Array A sh e)
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Accelerate.A e
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Array.Repa.Eval.Target.Target Data.Array.Repa.Repr.Accelerate.A e
instance Data.Array.Repa.Repr.Accelerate.Shapes Data.Array.Repa.Index.Z Data.Array.Accelerate.Array.Sugar.Z
instance Data.Array.Repa.Repr.Accelerate.Shapes sr sa => Data.Array.Repa.Repr.Accelerate.Shapes (sr Data.Array.Repa.Index.:. GHC.Types.Int) (sa Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
