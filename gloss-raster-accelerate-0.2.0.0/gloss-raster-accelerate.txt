-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parallel rendering of raster images using Accelerate
--   
--   Parallel rendering of raster images using Accelerate
@package gloss-raster-accelerate
@version 0.2.0.0

module Graphics.Gloss.Accelerate.Render

-- | The type of executing Accelerate computations. The CUDA and
--   Interpreter backends both provide a function <a>run1</a> that can be
--   used.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b

-- | The set of backends available to execute Accelerate programs. The
--   default chooses the fastest available, which is currently the CUDA
--   backend. This is controlled via the import statements.
defaultRender :: Render


-- | Rendering of Accelerate arrays as raster images
module Graphics.Gloss.Accelerate.Raster.Array

-- | The type of executing Accelerate computations. The CUDA and
--   Interpreter backends both provide a function <a>run1</a> that can be
--   used.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b
data Display :: *
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display
FullScreen :: (Int, Int) -> Display

-- | Animate a bitmap generated by an Accelerate computation, using the
--   default backend.
animateArray :: Display -> (Int, Int) -> (Exp Float -> Acc (Array DIM2 Colour)) -> IO ()

-- | Animate a bitmap generated by an Accelerate computation, specifying
--   the backend used to render the image.
animateArrayWith :: Render -> Display -> (Int, Int) -> (Exp Float -> Acc (Array DIM2 Colour)) -> IO ()

-- | Animate a bitmap generated by an Accelerate computation and IO
--   actions, using the default backend.
animateArrayIO :: Arrays world => Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> IO ()

-- | Animate a bitmap generated by an Accelerate computation and IO
--   actions, specifying the backend used to render the image.
animateArrayIOWith :: Arrays world => Render -> Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation, using the
--   default backend.
playArray :: Arrays world => Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation, specifying
--   the method used to render the world.
playArrayWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation and IO
--   actions, using the default backend.
playArrayIO :: Arrays world => Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Play with a bitmap generated by an Accelerate computation and IO
--   actions, specifying the method used to render the world.
playArrayIOWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Acc (Array DIM2 Colour)) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Lift an Accelerate computation from a <tt>world</tt> to an image into
--   a real Haskell-land function that executes the computation of the
--   image and wraps it as a Gloss picture ready for display.
makePicture :: Arrays world => Render -> Int -> Int -> (Acc world -> Acc (Array DIM2 Colour)) -> (world -> Picture)


-- | Rendering of 2D functions as raster fields
module Graphics.Gloss.Accelerate.Raster.Field

-- | The type of executing Accelerate computations. The CUDA and
--   Interpreter backends both provide a function <a>run1</a> that can be
--   used.
--   
--   Some variants of the display functions take an argument of this type,
--   which determine how computations are executed.
type Render = forall a b. (Arrays a, Arrays b) => (Acc a -> Acc b) -> a -> b
data Display :: *
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display
FullScreen :: (Int, Int) -> Display

-- | Animate a continuous 2D function using the default backend
animateField :: Display -> (Int, Int) -> (Exp Float -> Exp Point -> Exp Colour) -> IO ()

-- | Animate a continuous 2D function, specifying the backend used to
--   render the field.
animateFieldWith :: Render -> Display -> (Int, Int) -> (Exp Float -> Exp Point -> Exp Colour) -> IO ()

-- | Animate a continuous 2D function using IO actions and the default
--   backend
animateFieldIO :: Arrays world => Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> IO ()

-- | Animate a continuous 2D function using IO actions, specifying the
--   backend used to render the field.
animateFieldIOWith :: Arrays world => Render -> Display -> (Int, Int) -> (Float -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> IO ()

-- | Play a game with a continuous 2D function using the default backend.
playField :: Arrays world => Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play a game with a continuous 2D function, specifying the method used
--   to render the field.
playFieldWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> state) -> (Float -> state -> state) -> IO ()

-- | Play a game with a continuous 2D function using IO actions, and the
--   default backend.
playFieldIO :: Arrays world => Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Play a game with a continuous 2D function using IO actions, specifying
--   the method used to render the field.
playFieldIOWith :: Arrays world => Render -> Display -> (Int, Int) -> Int -> state -> (state -> IO world) -> (Acc world -> Exp Point -> Exp Colour) -> (Event -> state -> IO state) -> (Float -> state -> IO state) -> IO ()

-- | Lift a point-wise colouring function into an image creation function.
--   
--   The parameter <tt>world</tt> at this point can be arbitrary. However
--   if you use this function standalone, you will probably at some point
--   want the result of this function to plug into <a>makePicture</a> and
--   thus <a>Render</a>, and thus be a unary function from <a>Arrays</a> to
--   <a>Arrays</a>.
makeField :: Int -> Int -> (world -> Exp Point -> Exp Colour) -> (world -> Acc (Array DIM2 Colour))
