-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lifting numeric-prelude into Accelerate
--   
--   Lifting numeric-prelude into Accelerate
@package numeric-prelude-accelerate
@version 0.1.0.0


module Data.Array.Accelerate.Algebra.Additive
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp b)) => Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp (a, b))


module Data.Array.Accelerate.Algebra.ZeroTestable
class C a
isZero :: C a => a -> Exp Bool

-- | Checks if a number is the zero element. This test is not possible for
--   all <a>C</a> types, since e.g. a function type does not belong to Eq.
--   isZero is possible for some types where (==zero) fails because there
--   is no unique zero.
--   
--   Examples are vector (the length of the zero vector is unknown),
--   physical values (the unit of a zero quantity is unknown), residue
--   class (the modulus is unknown).
defltIsZero :: (C (Exp a), Eq a, Elt a) => Exp a -> Exp Bool
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp Data.Array.Accelerate.Array.Sugar.Z)
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp sh), Data.Array.Accelerate.Array.Sugar.Slice sh) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp e), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d, Data.Array.Accelerate.Array.Sugar.Elt e) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d, e))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp e), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp f), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d, Data.Array.Accelerate.Array.Sugar.Elt e, Data.Array.Accelerate.Array.Sugar.Elt f) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d, e, f))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp e), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp f), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp g), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d, Data.Array.Accelerate.Array.Sugar.Elt e, Data.Array.Accelerate.Array.Sugar.Elt f, Data.Array.Accelerate.Array.Sugar.Elt g) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d, e, f, g))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp e), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp f), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp g), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp h), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d, Data.Array.Accelerate.Array.Sugar.Elt e, Data.Array.Accelerate.Array.Sugar.Elt f, Data.Array.Accelerate.Array.Sugar.Elt g, Data.Array.Accelerate.Array.Sugar.Elt h) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d, e, f, g, h))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp d), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp e), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp f), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp g), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp h), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp i), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Data.Array.Accelerate.Array.Sugar.Elt c, Data.Array.Accelerate.Array.Sugar.Elt d, Data.Array.Accelerate.Array.Sugar.Elt e, Data.Array.Accelerate.Array.Sugar.Elt f, Data.Array.Accelerate.Array.Sugar.Elt g, Data.Array.Accelerate.Array.Sugar.Elt h, Data.Array.Accelerate.Array.Sugar.Elt i) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c, d, e, f, g, h, i))
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance (Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b)) => Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b))
instance (Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp b), Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp c)) => Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (a, b, c))


module Data.Array.Accelerate.Algebra.Ring
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance (Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b, Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp b)) => Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp (a, b))


module Data.Array.Accelerate.Algebra.Field
instance Algebra.Field.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Field.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)
instance (Algebra.Field.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Field.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Algebra.Field.C (Data.Array.Accelerate.Smart.Exp (a, b))


module Data.Array.Accelerate.Algebra.Algebraic
instance Algebra.Algebraic.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Algebraic.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.Transcendental
instance Algebra.Transcendental.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Transcendental.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.IntegralDomain

-- | Allows division by zero. If the denominator is zero, the numerator is
--   returned as the remainder.
divModZero :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp (a, a)

-- | Test if the first argument evenly divides the second
divides :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp Bool
sameResidueClass :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp a -> Exp a -> Exp Bool
even :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp Bool
odd :: (C (Exp a), C (Exp a), Elt a) => Exp a -> Exp Bool
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance (Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp a), Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp b), Data.Array.Accelerate.Array.Sugar.Elt a, Data.Array.Accelerate.Array.Sugar.Elt b) => Algebra.IntegralDomain.C (Data.Array.Accelerate.Smart.Exp (a, b))


module Data.Array.Accelerate.Algebra.Module
instance Algebra.Module.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int) (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.Module.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float) (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Module.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double) (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.Absolute
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.Units

-- | This class lets us deal with units in a ring. <a>isUnit</a> tells us
--   whether an element is a unit, while the other operations let us
--   canonically write an element as a unit times another element.
--   
--   This instance shadows <a>C</a> with an instance of <a>isUnit</a>
--   compatible with Accelerate.
class C a => C a where stdAssociate x = x * stdUnitInv x stdUnit x = one `div` stdUnitInv x stdUnitInv x = one `div` stdUnit x
isUnit :: C a => a -> Exp Bool
stdAssociate :: C a => a -> a
stdUnit :: C a => a -> a
stdUnitInv :: C a => a -> a
instance Data.Array.Accelerate.Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Data.Array.Accelerate.Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Data.Array.Accelerate.Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Data.Array.Accelerate.Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Data.Array.Accelerate.Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.Units.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)


module Data.Array.Accelerate.Algebra.PrincipalIdealDomain
class (C a, C a) => C a
extendedGCD :: C a => a -> a -> (a, (a, a))
gcd :: C a => a -> a -> a
lcm :: C a => a -> a -> a

-- | Two integers <tt>a</tt> and <tt>b</tt> are coprime (aka: relatively
--   prime, mutually prime) if the only positive integer that divides them
--   both is one.
coprime :: (C (Exp a), C (Exp a)) => Exp a -> Exp a -> Exp Bool

-- | An efficient method for computing the greatest common divisor of two
--   numbers.
euclid :: (C (Exp a), C (Exp a), Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Exp a -> Exp a

-- | Implementation of the extended Euclid algorithm which computes,
--   besides the greatest common divisor of integers <tt>a</tt> and
--   <tt>b</tt>, the coefficients of Bézout's identity <tt>x</tt> and
--   <tt>y</tt> such that:
--   
--   <pre>
--   ax + by = gcd(a, b)
--   </pre>
--   
--   
--   <a>https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode</a>
extendedEuclid :: (C (Exp a), C (Exp a), C (Exp a), C (Exp a), Elt a) => (Exp a -> Exp a -> Exp a) -> Exp a -> Exp a -> Exp (a, (a, a))
instance Algebra.PrincipalIdealDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.PrincipalIdealDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.PrincipalIdealDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.PrincipalIdealDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.PrincipalIdealDomain.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)


module Data.Array.Accelerate.Algebra.RealIntegral
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.RealIntegral.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)


module Data.Array.Accelerate.Algebra.ToRational
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.ToRational.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)


-- | Vacuous implementation of the numeric-prelude <tt>ToInteger</tt>
--   module. The NP.fromIntegral function is completely untenable for
--   Accelerate, but maybe we can get around that sometimes with rewrite
--   rules.
module Data.Array.Accelerate.Algebra.ToInteger
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Word)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32)
instance Algebra.ToInteger.C (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64)


module Data.Array.Accelerate.Algebra.RealRing
instance Algebra.RealRing.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Int)
instance Algebra.RealRing.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.RealRing.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.RealField
instance Algebra.RealField.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.RealField.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


module Data.Array.Accelerate.Algebra.RealTranscendental
instance Algebra.RealTranscendental.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Float)
instance Algebra.RealTranscendental.C (Data.Array.Accelerate.Smart.Exp GHC.Types.Double)


-- | Complex numbers
module Data.Array.Accelerate.Number.Complex
data T a :: * -> *

-- | Real part
real :: Elt a => Exp (T a) -> Exp a

-- | Imaginary part
imag :: Elt a => Exp (T a) -> Exp a

-- | Construct a complex number from the real and imaginary parts
(+:) :: Elt a => Exp a -> Exp a -> Exp (T a)

-- | Construct a complex number with negated imaginary part
(-:) :: (Elt a, C (Exp a)) => Exp a -> Exp a -> Exp (T a)

-- | Scale a complex number by a real number.
scale :: (C (Exp a), Elt a) => Exp a -> Exp (T a) -> Exp (T a)

-- | Exponential of a complex number with minimal type class constraints.
exp :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | Turn the point one quarter to the left
quarterLeft :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | Turn the point one quarter to the right.
quarterRight :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | The function <a>toPolar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   non-negative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
toPolar :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp (a, a)

-- | Form a complex number from polar components of magnitude and phase.
fromPolar :: (C (Exp a), Elt a) => Exp a -> Exp a -> Exp (T a)

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: (C (Exp a), Elt a) => Exp a -> Exp (T a)

-- | Scale a complex number to magnitude 1.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
signum :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp (T a)

-- | The non-negative magnitude of a complex number. This implementation
--   respects the limited range of floating point numbers. The trivial
--   implementation <a>magnitude</a> would overflow for floating point
--   exponents greater than the half of the maximum admissible exponent.
--   
--   floatMagnitude :: (P.RealFloat a, Algebraic.C a) =&gt; T a -&gt; a
--   floatMagnitude (Cons x y) = let k = max (P.exponent x) (P.exponent y)
--   mk = - k in P.scaleFloat k (sqrt (P.scaleFloat mk x ^ 2 + P.scaleFloat
--   mk y ^ 2))
--   
--   The non-negative magnitude of a complex number.
magnitude :: (C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | Like NormedEuc.normSqr with lifted class constraints
magnitudeSqr :: (C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: (C (Exp a), C (Exp a), Elt a) => Exp (T a) -> Exp a

-- | The conjugate of a complex number.
conjugate :: (C (Exp a), Elt a) => Exp (T a) -> Exp (T a)
instance (Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Additive.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Ring.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Algebra.Field.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Field.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Algebraic.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Array.Sugar.Elt a) => Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Algebra.Absolute.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Algebraic.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Field.C (Data.Array.Accelerate.Smart.Exp a), Algebra.RealTranscendental.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Transcendental.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Classes.Ord.Ord a, Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Algebraic.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance (Algebra.Field.C (Data.Array.Accelerate.Smart.Exp a), Algebra.RealTranscendental.C (Data.Array.Accelerate.Smart.Exp a), Algebra.Transcendental.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Algebra.ZeroTestable.C (Data.Array.Accelerate.Smart.Exp a), Data.Array.Accelerate.Classes.Ord.Ord a, Data.Array.Accelerate.Array.Sugar.Elt a) => Algebra.Transcendental.C (Data.Array.Accelerate.Smart.Exp (Number.Complex.T a))
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Array.Sugar.Elt (Number.Complex.T a)
instance cst a => Data.Array.Accelerate.Product.IsProduct cst (Number.Complex.T a)
instance (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a, Data.Array.Accelerate.Array.Sugar.Elt (Data.Array.Accelerate.Lift.Plain a)) => Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp (Number.Complex.T a)
instance Data.Array.Accelerate.Array.Sugar.Elt a => Data.Array.Accelerate.Lift.Unlift Data.Array.Accelerate.Smart.Exp (Number.Complex.T (Data.Array.Accelerate.Smart.Exp a))
