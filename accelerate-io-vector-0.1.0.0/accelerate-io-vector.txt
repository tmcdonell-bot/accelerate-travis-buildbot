-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Read and write Accelerate arrays in various formats
--   
--   This package provides efficient conversion routines between a range of
--   array types and Accelerate arrays.
--   
--   Refer to the main <i>Accelerate</i> package for more information:
--   <a>http://hackage.haskell.org/package/accelerate</a>
@package accelerate-io-vector
@version 0.1.0.0


-- | This module provides instance for <a>MVector</a>, for generic mutable
--   vectors backed by Accelerate.
module Data.Array.Accelerate.IO.Data.Vector.Generic.Mutable

-- | Dense, regular, mutable, multi-dimensional arrays
data MArray sh s e
[MArray] :: (Shape sh, Elt e) => EltRepr sh -> MutableArrayData (EltRepr e) -> MArray sh s e
type MVector = MArray DIM1
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Vector.Generic.Mutable.Base.MVector Data.Array.Accelerate.IO.Data.Vector.Generic.Mutable.MVector e


-- | This module provides an instance for <a>Vector</a>, for immutable
--   vectors from the <tt>vector</tt> package backed by Accelerate arrays.
--   
--   This allows computations written with the <tt>vector</tt> library to
--   read from and store into, arrays which can then be passed directly to
--   an Accelerate computation.
module Data.Array.Accelerate.IO.Data.Vector.Generic
instance Data.Array.Accelerate.Array.Sugar.Elt e => Data.Vector.Generic.Base.Vector Data.Array.Accelerate.Array.Sugar.Vector e


-- | Efficient conversion between <a>Primitive</a> vectors and Accelerate
--   <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Primitive

-- | A family of types which represent a collection of Primitive Vectors.
--   The structure of the collection depends on the element type <tt>e</tt>
--   of the corresponding Accelerate array.
type family Vectors e :: *

-- | <i>O(1)</i> (typically). Convert an Accelerate array into a collection
--   of primitive vectors.
--   
--   If the array data was allocated by Accelerate, this can typically be
--   done without copying.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toVectors :: (Shape sh, Elt e) => Array sh e -> Vectors (EltRepr e)

-- | <i>O(n)</i> (typically). Convert a collection of primitive vectors
--   into an Accelerate array.
--   
--   If the underlying vectors are pinned then this can be done without.
--   
--   See also: <a>https://ghc.haskell.org/trac/ghc/ticket/5556</a>
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromVectors :: (Shape sh, Elt e) => sh -> Vectors (EltRepr e) -> Array sh e


-- | Efficient non-copying conversion between <a>Storable</a> vectors and
--   Accelerate <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Storable

-- | A family of types that represents a collection of storable
--   <a>Vector</a>s. The structure of the collection depends on the element
--   type <tt>e</tt>.
--   
--   For example:
--   
--   <ul>
--   <li>if <tt>e :: Int</tt>, then <tt>Vectors (EltRepr e) :: Vector
--   Int</tt></li>
--   <li>if <tt>e :: (Double, Float)</tt>, then <tt>Vectors (EltRepr e) ::
--   (((), Vector Double), Vector Float)</tt></li>
--   </ul>
type family Vectors e

-- | <i>O(1)</i>. Turn the Accelerate array into a collection of storable
--   <a>Vector</a>s. The element type of the array <tt>e</tt> will
--   determine the structure of the output collection. See <a>Vectors</a>.
--   
--   Data will be output in row-major order.
toVectors :: (Shape sh, Elt e) => Array sh e -> Vectors (EltRepr e)

-- | <i>O(1)</i>. Treat a set of storable vectors as Accelerate arrays. The
--   type of elements <tt>e</tt> in the output Accelerate array determines
--   the structure of the collection that will be required as the second
--   argument. See <a>Vectors</a>.
--   
--   Data will be consumed from the vector in row-major order. You must
--   make sure that each of the input vectors contains the right number of
--   elements
fromVectors :: (Shape sh, Elt e) => sh -> Vectors (EltRepr e) -> Array sh e


-- | Efficient conversion between <a>Unboxed</a> vectors and Accelerate
--   <a>Array</a>s.
module Data.Array.Accelerate.IO.Data.Vector.Unboxed
class (Unbox e, Elt e) => Unbox e
arrayDataOfUnboxed :: Unbox e => Vector e -> ArrayData (EltRepr e)
unboxedOfArrayData :: Unbox e => Int -> ArrayData (EltRepr e) -> Vector e

-- | <i>O(1)</i> (typically). Convert an Accelerate array into an Unboxed
--   vector.
--   
--   If the array data was allocated by Accelerate, this can typically be
--   done without copying. The resulting vector will be pinned.
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
toUnboxed :: (Shape sh, Unbox e) => Array sh e -> Vector e

-- | <i>O(n)</i> (typically). Convert an Unboxed vector into an Accelerate
--   array.
--   
--   If the underlying vectors are pinned then this can be done without
--   copying.
--   
--   See also: <a>https://ghc.haskell.org/trac/ghc/ticket/5556</a>
--   
--   <pre>
--   since 1.1.0.0
--   </pre>
fromUnboxed :: Unbox e => Vector e -> Array DIM1 e
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Int
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int8
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int16
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int32
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Int.Int64
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Word
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word8
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word16
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word32
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Word.Word64
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Float
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Double
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Char
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox GHC.Types.Bool
instance Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox ()
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox e) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d, e)
instance (Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox a, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox b, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox c, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox d, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox e, Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox f) => Data.Array.Accelerate.IO.Data.Vector.Unboxed.Unbox (a, b, c, d, e, f)
