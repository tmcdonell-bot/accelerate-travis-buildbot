-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | base-compat with extra batteries
--   
--   Provides functions available in later versions of <tt>base</tt> to a
--   wider range of compilers, without requiring you to use CPP pragmas in
--   your code.
--   
--   This package provides the same API as the <tt><a>base-compat</a></tt>
--   library, but depends on compatibility packages (such as
--   <tt>semigroups</tt>) to offer a wider support window than
--   <tt>base-compat</tt>, which has no dependencies. Most of the modules
--   in this library have the same names as in <tt>base-compat</tt> to make
--   it easier to switch between the two. There also exist versions of each
--   module with the suffix <tt>.Repl.Batteries</tt>, which are distinct
--   from anything in <tt>base-compat</tt>, to allow for easier use in
--   GHCi.
--   
--   See <tt><a>here</a></tt> for a more comprehensive list of differences
--   between <tt>base-compat</tt> and <tt>base-compat-batteries</tt>.
@package base-compat-batteries
@version 0.10.5

module Control.Concurrent.Compat


-- | Reexports <a>Control.Concurrent.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.Compat.Repl.Batteries

module Control.Concurrent.MVar.Compat


-- | Reexports <a>Control.Concurrent.MVar.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.MVar.Compat.Repl.Batteries

module Control.Exception.Compat


-- | Reexports <a>Control.Exception.Compat</a> from a globally unique
--   namespace.
module Control.Exception.Compat.Repl.Batteries

module Control.Monad.Compat


-- | Reexports <a>Control.Monad.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Compat.Repl.Batteries

module Control.Monad.Fail.Compat


-- | Reexports <a>Control.Monad.Fail.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Fail.Compat.Repl.Batteries

module Control.Monad.IO.Class.Compat


-- | Reexports <a>Control.Monad.IO.Class.Compat</a> from a globally unique
--   namespace.
module Control.Monad.IO.Class.Compat.Repl.Batteries

module Control.Monad.ST.Lazy.Unsafe.Compat


-- | Reexports <a>Control.Monad.ST.Lazy.Unsafe.Compat</a> from a globally
--   unique namespace.
module Control.Monad.ST.Lazy.Unsafe.Compat.Repl.Batteries

module Control.Monad.ST.Unsafe.Compat


-- | Reexports <a>Control.Monad.ST.Unsafe.Compat</a> from a globally unique
--   namespace.
module Control.Monad.ST.Unsafe.Compat.Repl.Batteries

module Data.Bifoldable.Compat


-- | Reexports <a>Data.Bifoldable.Compat</a> from a globally unique
--   namespace.
module Data.Bifoldable.Compat.Repl.Batteries

module Data.Bifunctor.Compat


-- | Reexports <a>Data.Bifunctor.Compat</a> from a globally unique
--   namespace.
module Data.Bifunctor.Compat.Repl.Batteries

module Data.Bitraversable.Compat


-- | Reexports <a>Data.Bitraversable.Compat</a> from a globally unique
--   namespace.
module Data.Bitraversable.Compat.Repl.Batteries

module Data.Bits.Compat


-- | Reexports <a>Data.Bits.Compat</a> from a globally unique namespace.
module Data.Bits.Compat.Repl.Batteries

module Data.Bool.Compat


-- | Reexports <a>Data.Bool.Compat</a> from a globally unique namespace.
module Data.Bool.Compat.Repl.Batteries

module Data.Complex.Compat


-- | Reexports <a>Data.Complex.Compat</a> from a globally unique namespace.
module Data.Complex.Compat.Repl.Batteries

module Data.Either.Compat


-- | Reexports <a>Data.Either.Compat</a> from a globally unique namespace.
module Data.Either.Compat.Repl.Batteries

module Data.Foldable.Compat


-- | Reexports <a>Data.Foldable.Compat</a> from a globally unique
--   namespace.
module Data.Foldable.Compat.Repl.Batteries

module Data.Function.Compat


-- | Reexports <a>Data.Function.Compat</a> from a globally unique
--   namespace.
module Data.Function.Compat.Repl.Batteries

module Data.Functor.Compat

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>


-- | Reexports <a>Data.Functor.Compat</a> from a globally unique namespace.
module Data.Functor.Compat.Repl.Batteries

module Data.Functor.Compose.Compat


-- | Reexports <a>Data.Functor.Compose.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Compose.Compat.Repl.Batteries

module Data.Functor.Const.Compat


-- | Reexports <a>Data.Functor.Const.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Const.Compat.Repl.Batteries

module Data.Functor.Contravariant.Compat


-- | Reexports <a>Data.Functor.Contravariant.Compat</a> from a globally
--   unique namespace.
module Data.Functor.Contravariant.Compat.Repl.Batteries

module Data.Functor.Identity.Compat


-- | Reexports <a>Data.Functor.Identity.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Identity.Compat.Repl.Batteries

module Data.Functor.Product.Compat


-- | Reexports <a>Data.Functor.Product.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Product.Compat.Repl.Batteries

module Data.Functor.Sum.Compat


-- | Reexports <a>Data.Functor.Sum.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Sum.Compat.Repl.Batteries

module Data.IORef.Compat


-- | Reexports <a>Data.IORef.Compat</a> from a globally unique namespace.
module Data.IORef.Compat.Repl.Batteries

module Data.List.Compat


-- | Reexports <a>Data.List.Compat</a> from a globally unique namespace.
module Data.List.Compat.Repl.Batteries


-- | This backports the modern <a>Data.Semigroup</a> interface back to
--   <tt>base-4.9</tt>/GHC 8.0.
module Data.List.NonEmpty.Compat

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: () => (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: () => a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: () => (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: () => (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: () => NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: () => (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: () => NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: () => NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: () => NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: () => NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: () => NonEmpty a -> [a]

-- | Prepend an element to the stream.
(<|) :: () => a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: () => a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: () => NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: () => (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: () => NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>.
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>.
tails :: Foldable f => f a -> NonEmpty [a]

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: () => (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: () => a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: () => NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.
unfold :: () => (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: () => Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: () => Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: () => Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: () => (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: () => (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: () => (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: () => (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: () => (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: () => (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: () => (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <tt>isPrefix</tt> function returns <tt>True</tt> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: () => (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: () => NonEmpty a -> Int -> a
infixl 9 !!

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: () => NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: () => (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: () => [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: () => NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: () => [a] -> Maybe (NonEmpty a)

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | Reexports <a>Data.List.NonEmpty.Compat</a> from a globally unique
--   namespace.
module Data.List.NonEmpty.Compat.Repl.Batteries

module Data.Monoid.Compat

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.First x === Maybe (Data.Semigroup.First x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.Last x === Maybe (Data.Semigroup.Last x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
newtype Ap (f :: k -> Type) (a :: k) :: forall k. () => k -> Type -> k -> Type
Ap :: f a -> Ap
[getAp] :: Ap -> f a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Monoid under <a>&lt;|&gt;</a>.
newtype Alt (f :: k -> Type) (a :: k) :: forall k. () => k -> Type -> k -> Type
Alt :: f a -> Alt
[getAlt] :: Alt -> f a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>


-- | Reexports <a>Data.Monoid.Compat</a> from a globally unique namespace.
module Data.Monoid.Compat.Repl.Batteries

module Data.Proxy.Compat


-- | Reexports <a>Data.Proxy.Compat</a> from a globally unique namespace.
module Data.Proxy.Compat.Repl.Batteries

module Data.Ratio.Compat


-- | Reexports <a>Data.Ratio.Compat</a> from a globally unique namespace.
module Data.Ratio.Compat.Repl.Batteries

module Data.STRef.Compat


-- | Reexports <a>Data.STRef.Compat</a> from a globally unique namespace.
module Data.STRef.Compat.Repl.Batteries

module Data.Semigroup.Compat

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <a>Data.Monoid</a>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <a>Data.Monoid</a>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: () => b -> (a -> b) -> Option a -> b

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min Arg a b
type ArgMax a b = Max Arg a b


-- | Reexports <a>Data.Semigroup.Compat</a> from a globally unique
--   namespace.
module Data.Semigroup.Compat.Repl.Batteries

module Data.String.Compat


-- | Reexports <a>Data.String.Compat</a> from a globally unique namespace.
module Data.String.Compat.Repl.Batteries

module Data.Type.Coercion.Compat


-- | Reexports <a>Data.Type.Coercion.Compat</a> from a globally unique
--   namespace.
module Data.Type.Coercion.Compat.Repl.Batteries

module Data.Version.Compat


-- | Reexports <a>Data.Version.Compat</a> from a globally unique namespace.
module Data.Version.Compat.Repl.Batteries

module Data.Void.Compat

-- | Uninhabited data type
data Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: () => Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a


-- | Reexports <a>Data.Void.Compat</a> from a globally unique namespace.
module Data.Void.Compat.Repl.Batteries

module Data.Word.Compat


-- | Reexports <a>Data.Word.Compat</a> from a globally unique namespace.
module Data.Word.Compat.Repl.Batteries

module Debug.Trace.Compat


-- | Reexports <a>Debug.Trace.Compat</a> from a globally unique namespace.
module Debug.Trace.Compat.Repl.Batteries

module Foreign.Compat


-- | Reexports <a>Foreign.Compat</a> from a globally unique namespace.
module Foreign.Compat.Repl.Batteries

module Foreign.ForeignPtr.Compat


-- | Reexports <a>Foreign.ForeignPtr.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Compat.Repl.Batteries

module Foreign.ForeignPtr.Safe.Compat


-- | Reexports <a>Foreign.ForeignPtr.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Safe.Compat.Repl.Batteries

module Foreign.ForeignPtr.Unsafe.Compat


-- | Reexports <a>Foreign.ForeignPtr.Unsafe.Compat</a> from a globally
--   unique namespace.
module Foreign.ForeignPtr.Unsafe.Compat.Repl.Batteries

module Foreign.Marshal.Alloc.Compat


-- | Reexports <a>Foreign.Marshal.Alloc.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Alloc.Compat.Repl.Batteries

module Foreign.Marshal.Array.Compat


-- | Reexports <a>Foreign.Marshal.Array.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Array.Compat.Repl.Batteries

module Foreign.Marshal.Compat


-- | Reexports <a>Foreign.Marshal.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Compat.Repl.Batteries

module Foreign.Marshal.Safe.Compat


-- | Reexports <a>Foreign.Marshal.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Safe.Compat.Repl.Batteries

module Foreign.Marshal.Unsafe.Compat


-- | Reexports <a>Foreign.Marshal.Unsafe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Unsafe.Compat.Repl.Batteries

module Foreign.Marshal.Utils.Compat


-- | Reexports <a>Foreign.Marshal.Utils.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Utils.Compat.Repl.Batteries

module Numeric.Compat


-- | Reexports <a>Numeric.Compat</a> from a globally unique namespace.
module Numeric.Compat.Repl.Batteries

module Numeric.Natural.Compat


-- | Reexports <a>Numeric.Natural.Compat</a> from a globally unique
--   namespace.
module Numeric.Natural.Compat.Repl.Batteries

module Prelude.Compat


-- | Reexports <a>Prelude.Compat</a> from a globally unique namespace.
module Prelude.Compat.Repl.Batteries

module System.Environment.Compat


-- | Reexports <a>System.Environment.Compat</a> from a globally unique
--   namespace.
module System.Environment.Compat.Repl.Batteries

module System.Exit.Compat


-- | Reexports <a>System.Exit.Compat</a> from a globally unique namespace.
module System.Exit.Compat.Repl.Batteries

module System.IO.Unsafe.Compat


-- | Reexports <a>System.IO.Unsafe.Compat</a> from a globally unique
--   namespace.
module System.IO.Unsafe.Compat.Repl.Batteries

module Text.Read.Compat


-- | Reexports <a>Text.Read.Compat</a> from a globally unique namespace.
module Text.Read.Compat.Repl.Batteries

module Type.Reflection.Compat


-- | Reexports <a>Type.Reflection.Compat</a> from a globally unique
--   namespace.
module Type.Reflection.Compat.Repl.Batteries
